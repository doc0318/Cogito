{"task_id": "9ce37bc2d361f5bb8a0568fb479b8a38", "completion": "def max_characters_removed(s):\n    removed = 0\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        while i < len(s):\n            if (i == 0 and s[i+1] == chr(ord(s[i]) - 1)) or (i == len(s) - 1 and s[i-1] == chr(ord(s[i]) - 1)) or (s[i-1] == chr(ord(s[i]) - 1) or s[i+1] == chr(ord(s[i]) - 1)):\n                s = s[:i] + s[i+1:]\n                removed += 1\n                changed = True\n                i = max(0, i-1)\n            else:\n                i += 1\n    \n    return removed"}
{"task_id": "8de14db41d0acee116bd5d8079cb2b02", "completion": "def min_chars_to_remove(file_name):\n    count = 0\n    result = 0\n    \n    for char in file_name:\n        if char == 'x':\n            count += 1\n            if count >= 3:\n                result += 1\n        else:\n            count = 0\n\n    return result"}
{"task_id": "d0a8604b78ba19ab769fd1ec90a72e4e", "completion": "def find_Nth_suitable_number(input_str):\n    N = int(input_str)\n    \n    a = 1\n    b = 1\n    suitable_numbers = set()\n    \n    while len(suitable_numbers) < N:\n        while a * b in suitable_numbers:\n            a += 1\n            b = a\n        x = a * b\n        suitable_numbers.add(x)\n        b += 1\n    \n    return str(a * (b - 1))"}
{"task_id": "711d15e11016d0164fb2b0c3756e4857", "completion": "def count_chainwords(instructions):\n    mod = 998244353\n\n    n, m, *words = instructions.split()\n    \n    def count_segments(word):\n        segments = set()\n        for i in range(1, int(m) + 1):\n            for j in range(i, int(m) + 1):\n                segments.add(word[i - 1:j])\n        return segments\n\n    total_instances = set()\n    for word1 in words:\n        segments1 = count_segments(word1)\n        for word2 in words:\n            segments2 = count_segments(word2)\n            instances = len(segments1) * len(segments2)\n            total_instances.add(instances)\n\n    total_count = sum(total_instances) % mod\n    return str(total_count)"}
{"task_id": "788ed59a964264bd0e755e155a37e14d", "completion": "def min_maps_to_study(input_str):\n    n, p = map(float, input_str.split())\n    \n    min_maps = 0\n    curr_prob = 0\n    remaining_maps = n\n    \n    while curr_prob < p and remaining_maps > 0:\n        curr_prob += (2 / (n - min_maps)) * ((remaining_maps - 2) / (n - 1))\n        min_maps += 1\n        remaining_maps -= 1\n        \n    return str(min_maps)\n\n\ntest_case = {'input': '7 1.0000', 'output': '6'}\nassert min_maps_to_study(test_case['input']) == test_case['output']"}
{"task_id": "ad014bde729222db14f38caa521e4167", "completion": "def process_queries(input_string):\n    queries = input_string.split('\\n')\n    n, m, q = map(int, queries[0].split())\n    vertices = list(map(int, queries[1].split()))\n\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n\n    for i in range(2, m + 2):\n        u, v = map(int, queries[i].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    def dfs(start):\n        nonlocal vertices, graph\n        stack = [start]\n        visited = [False] * n\n        max_val = 0\n\n        while stack:\n            node = stack.pop()\n            visited[node] = True\n            max_val = max(max_val, vertices[node])\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n\n        for i in range(n):\n            if vertices[i] == max_val:\n                vertices[i] = 0\n                return max_val\n\n    output = []\n    for i in range(m + 2, m + q + 2):\n        query_type, *args = map(int, queries[i].split())\n        if query_type == 1:\n            vertex = args[0] - 1\n            max_value = dfs(vertex)\n            output.append(str(max_value))\n        elif query_type == 2:\n            edge_index = args[0] - 1\n            u, v = map(int, queries[m + 1 + edge_index].split())\n\n            graph[u - 1].remove(v - 1)\n            graph[v - 1].remove(u - 1)\n\n    return \"\\n\".join(output)"}
{"task_id": "24e2f10463f440affccc2755f4462d8a", "completion": "def count_permutations(input_str):\n    MOD = 10**9 + 7\n\n    n, x, pos = map(int, input_str.split())\n\n    def factorial(n):\n        result = 1\n        for i in range(1, n+1):\n            result = (result * i) % MOD\n        return result\n\n    def power(base, exp):\n        result = 1\n        base = base % MOD\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % MOD\n            base = (base * base) % MOD\n            exp //= 2\n        return result\n\n    def compute_ways(val, pos, size):\n        left = 0\n        right = size\n        count = 1\n\n        while left < right:\n            mid = (left + right) // 2\n            if mid == pos:\n                left = mid + 1\n                continue\n\n            if val <= mid:\n                count = (count * (mid - 1 - (val - 1) + 1)) % MOD\n                right = mid\n            else:\n                count = (count * (size - (val - 1) - (size - mid))) % MOD\n                left = mid + 1\n\n        return count\n\n    left_count = compute_ways(x, pos, n)\n    right_count = compute_ways(x, pos, n)\n\n    total_permutations = factorial(n - 1) * left_count * right_count\n    result = (total_permutations * factorial(n - 1)) % MOD\n\n    return str(result)\n\n# Test cases\ntest_cases = [\n    {'input': '4 1 2', 'output': '6'},\n    {'input': '123 42 24', 'output': '824071958'}\n]\n\nfor test_case in test_cases:\n    input_data = test_case['input']\n    expected_output = test_case['output']\n    assert count_permutations(input_data) == expected_output"}
{"task_id": "9812de5f2d272511a63ead8765b23190", "completion": "from itertools import product\n\ndef sum_of_madness(input_string):\n    n, m, p = map(int, input_string.split())\n\n    def calculate_madness(a, b):\n        occupied = set()\n        total_madness = 0\n\n        for i in range(m):\n            pos = a[i]\n            direction = -1 if b[i] == 'L' else 1\n\n            while pos in occupied or pos < 1 or pos > n:\n                pos += direction\n\n            if pos < 1 or pos > n:\n                return float('inf')\n\n            total_madness += abs(a[i] - pos)\n            occupied.add(pos)\n\n        return total_madness\n\n    result = 0\n\n    for a in product(range(1, n+1), repeat=m):\n        for b in product(['L', 'R'], repeat=m):\n            if any(a[i] == a[j] and b[i] == b[j] for i in range(m) for j in range(m)):\n                continue\n\n            madness = calculate_madness(a, b)\n            if madness != float('inf'):\n                result = (result + madness) % p\n\n    return str(result)\n\n# Test the function with the provided examples\ntests = [{'input': '3 1 1000000007', 'output': '0'},\n         {'input': '2 2 1000000009', 'output': '4'},\n         {'input': '3 2 998244353', 'output': '8'},\n         {'input': '20 10 1000000009', 'output': '352081045'}]\n\nfor test in tests:\n    input_data = test['input']\n    expected_output = test['output']\n\n    assert sum_of_madness(input_data) == expected_output"}
{"task_id": "19a0c05eb2d1559ccfe60e210c6fcd6a", "completion": "def min_max_rebuilds(input_str):\n    def dijkstra(adj_list, start, target):\n        dist = {node: float('inf') for node in adj_list}\n        dist[start] = 0\n        heap = [(0, start)]\n        \n        while heap:\n            d, u = heapq.heappop(heap)\n            if d > dist[u]:\n                continue\n            for v, w in adj_list[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(heap, (dist[v], v))\n        \n        return dist[target]\n\n    lines = input_str.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    adj_list = {i: [] for i in range(1, n + 1)}\n\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        adj_list[u].append((v, 1))\n    \n    path = list(map(int, lines[m + 1].split()))\n    rebuilds_min = rebuilds_max = 0\n\n    for i in range(len(path) - 1):\n        u, v = path[i], path[i + 1]\n        shortest_path_uv = dijkstra(adj_list, u, v)\n\n        if i < len(path) - 2:\n            shortest_path_u_next = dijkstra(adj_list, u, path[i + 2])\n\n            if shortest_path_uv + 1 < shortest_path_u_next:\n                rebuilds_min += 1\n        \n        for w in range(i + 2, len(path)):\n            shortest_path_vw = dijkstra(adj_list, v, path[w])\n            if shortest_path_uv + 1 < shortest_path_vw:\n                rebuilds_max += 1\n\n    return f\"{rebuilds_min} {rebuilds_max}\""}
{"task_id": "dc466d9c24b7dcb37c0e99337b4124d2", "completion": "def expected_value_after_k_steps(s):\n    mod = 10**9 + 7\n\n    n, k = map(int, s.split())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(1, k + 1):\n        new_dp = [0] * (n + 1)\n        for j in range(1, n + 1):\n            total_divs = sum(1 for d in range(1, j + 1) if j % d == 0)\n            expected = sum(dp[d] for d in range(1, j + 1) if j % d == 0) % mod\n            new_dp[j] = (expected + total_divs * j) * pow(total_divs, -1, mod) % mod\n        dp = new_dp\n\n    P = sum(dp) % mod\n    Q = pow(n, k, mod)\n\n    return (P * pow(Q, -1, mod)) % mod"}
{"task_id": "04610fbaa746c083dda30e21fa6e1a0c", "completion": "def calculate_f_multiplication(input_str):\n    MOD = 10**9 + 7\n\n    def prime(x):\n        factors = set()\n        d = 2\n        while d * d <= x:\n            if x % d == 0:\n                factors.add(d)\n                x //= d\n            else:\n                d += 1\n        if x != 1:\n            factors.add(x)\n        return factors\n\n    def g(x, p):\n        k = 0\n        while x % p == 0:\n            x //= p\n            k += 1\n        return pow(p, k, MOD)\n\n    def f(x, y):\n        result = 1\n        primes = prime(x)\n        for p in primes:\n            result *= g(y, p)\n            result %= MOD\n        return result\n\n    x, n = map(int, input_str.split())\n    result = 1\n    for y in range(1, n + 1):\n        result *= f(x, y)\n        result %= MOD\n\n    return result"}
{"task_id": "11e6559cfb71b8f6ca88242094b17a2b", "completion": "def max_dominoes_placed(input_str: str) -> str:\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    \n    edges = [[] for _ in range(n)]\n    for i in range(1, m+1):\n        u, v = map(int, input_lines[i].split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n    \n    distinct_combinations = set()\n    for i in range(1, 7):\n        for j in range(i, 7):\n            distinct_combinations.add((i, j))\n    \n    repeated_combinations = 21 - len(distinct_combinations)\n    \n    max_possible_dominoes = min(repeated_combinations, m)\n    \n    return str(max_possible_dominoes)"}
{"task_id": "3ff1c25a1026c90aeb14d148d7fb96ba", "completion": "def find_pair(input_str):\n    r = int(input_str)\n\n    for x in range(1, int(r ** 0.5) + 1):\n        y = (r - x ** 2 - x - 1) / (2 * x)\n        if y == int(y) and y > 0:\n            return f\"{x} {int(y)}\"\n\n    return \"NO\""}
{"task_id": "1bd29d7a8793c22e81a1f6fd3991307a", "completion": "def minWeightTriangulation(n):\n    n = int(n)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n):\n        for i in range(0, n-length):\n            j = i + length\n            if length == 2:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i+1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + (i+1) * (j+1) * (k+1))\n    \n    return dp[0][n-1]"}
{"task_id": "42f25d492bddc12d3d89d39315d63cb9", "completion": "def max_bourles_after_evening(input_str):\n    def find_max_bourles(n, m, r, s, b):\n        max_bourles = r\n        for buy_price in s:\n            max_shares_buyable = r // buy_price\n            for sell_price in b:\n                amount_after_selling = max_shares_buyable * sell_price + r % buy_price\n                max_bourles = max(max_bourles, amount_after_selling)\n        return max_bourles\n\n    n, m, r, *data = map(int, input_str.split())\n    s = data[:n]\n    b = data[n:]\n\n    return str(find_max_bourles(n, m, r, s, b))"}
{"task_id": "c9e79e83928d5d034123ebc3b2f5e064", "completion": "def calculate_expected_length(input_str):\n    MOD = 998244353\n\n    f = [1] * 10010\n    invf = [1] * 10010\n    for i in range(2, 10010):\n        f[i] = f[i - 1] * i % MOD\n\n    invf[10009] = pow(f[10009], MOD - 2, MOD)\n    for i in range(10009, 0, -1):\n        invf[i - 1] = invf[i] * i % MOD\n\n    l, n, k = map(int, input_str.split())\n    intervals = 2 * n + 1\n    expected_length = 0\n\n    for m in range(k, n + 1):\n        contribution = (f[n] * invf[m] % MOD) * invf[n - m] % MOD\n        contribution *= (f[n - 1] * invf[m - 1] % MOD) * (n - m) % MOD\n        contribution %= MOD\n        contribution *= m\n        contribution %= MOD\n        contribution *= pow(2, MOD - 2, MOD)\n        contribution %= MOD\n\n        length_covered = (l * m) % MOD\n        expected_length = (expected_length + (contribution * length_covered) % MOD) % MOD\n\n    return str(expected_length)"}
{"task_id": "ce8350be138ce2061349d7f9224a5aaf", "completion": "def find_min_questions(input_str):\n    segments = input_str.split(\"\\n\")[1:]\n    segments = [list(map(int, segment.split())) for segment in segments]\n    \n    points = set()\n    for start, end in segments:\n        for i in range(start, end + 1):\n            points.add(i)\n    \n    min_questions = float('inf')\n    for point in points:\n        questions = 0\n        for start, end in segments:\n            if start <= point <= end:\n                questions += 1\n        \n        min_questions = min(min_questions, questions)\n    \n    return min_questions"}
{"task_id": "f8af5dfcf841a7f105ac4c144eb51319", "completion": "def minimal_layers_needed(input_str):\n    N = int(input_str)\n    layers = [0]\n    \n    for i in range(1, N):\n        cur_layer = i*(i+1)//2\n        if cur_layer >= layers[-1]:\n            layers.append(cur_layer)\n    \n    return str(len(layers))"}
{"task_id": "4b9f470e5889da29affae6376f6c9f6a", "completion": "def count_valid_integers(input_str):\n    x, a, b, p = map(int, input_str.split())\n\n    def calculate_modular_power(base, exponent, modulus):\n        result = 1\n        base %= modulus\n\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            exponent //= 2\n            base = (base * base) % modulus\n\n        return result\n\n    count = sum(1 for n in range(1, x + 1) if (n * calculate_modular_power(a, n, p)) % p == b % p)\n    return str(count)"}
{"task_id": "838f2e75fdff0f13f002c0dfff0b2e8d", "completion": "def count_xorangles(n_str):\n    n = int(n_str)\n    count = 0\n\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = a ^ b\n            if c >= b and c <= n and a + b > c:\n                count += 1\n\n    return str(count)"}
{"task_id": "5e74750f44142624e6da41d4b35beb9a", "completion": "def determine_winner(n: str) -> str:\n    return \"Ehab\" if int(n) % 2 == 1 else \"Mahmoud\""}
{"task_id": "236177ff30dafe68295b5d33dc501828", "completion": "def min_cuts_to_divide_pizza(n_str):\n    n = int(n_str)\n    min_cuts = n\n    return str(min_cuts)"}
{"task_id": "d37dde5841116352c9b37538631d0b15", "completion": "def count_good_pairs(input_str):\n    x, y, l, r = map(int, input_str.split())\n\n    if y % x != 0:\n        return '0'\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(l, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y and a != b and a <= b:\n                count += 1\n\n    return str(count)"}
{"task_id": "a40e78a7144ac2fae1890ac7598990bf", "completion": "def count_unique_max_matchings(input_string):\n    MOD = 998244353\n    \n    lines = input_string.strip().split('\\n')\n    n = int(lines[0])\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n\n    graph = {i: [] for i in range(1, n+1)}\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent):\n        nonlocal count, leaf_count\n        children = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                children += 1\n                dfs(neighbor, node)\n        if children == 1:\n            leaf_count += 1\n\n    count = 0\n    leaf_count = 0\n    dfs(1, -1)\n\n    result = pow(2, leaf_count-1, MOD) if leaf_count > 1 else 1\n    return str(result)"}
{"task_id": "0034806908c9794086736a2d07fc654c", "completion": "def count_cyclical_strings(s):\n    n = len(s)\n    s += s\n    substrings = set()\n    \n    for i in range(n):\n        substrings.add(s[i:i+n])\n    \n    return len(substrings)\n\ntest_cases = [{'input': '2\\n0', 'output': '3'}, {'input': '4\\n1010', 'output': '2'}, {'input': '20\\n10101010101010', 'output': '962'}]\n\nfor test_case in test_cases:\n    input_data = test_case['input'].strip().split('\\n')\n    s = input_data[1]\n    output = count_cyclical_strings(s)\n    assert output == int(test_case['output']), f\"Test case {test_case} failed.\""}
{"task_id": "3dc56bc08606a39dd9ca40a43c452f09", "completion": "def min_minutes_increase_stick_length(input_str):\n    a, b, c = sorted(map(int, input_str.split()))\n\n    if a + b > c:\n        return '0'\n    return str(c - (a + b) + 1)"}
{"task_id": "609195ef4a970c62a8210dafe118580e", "completion": "def calculate_probability_top_score(input_string):\n    MOD = 998244353\n\n    p, s, r = map(int, input_string.split())\n\n    def nCr(n, r):\n        if r > n:\n            return 0\n        num = den = 1\n        for i in range(r):\n            num = (num * (n - i)) % MOD\n            den = (den * (i + 1)) % MOD\n        den_inv = pow(den, MOD - 2, MOD)\n        return (num * den_inv) % MOD\n\n    t = nCr(s - r + p - 1, p - 1)\n    w = nCr(s - r - 1 + p - 1, p - 1)\n\n    prob = (w * pow(t, MOD - 2, MOD)) % MOD\n\n    return prob\n\n# Test cases\nprint(calculate_probability_top_score('2 6 3'))  # Output: 124780545\nprint(calculate_probability_top_score('5 20 11'))  # Output: 1\nprint(calculate_probability_top_score('10 30 10'))  # Output: 85932500"}
{"task_id": "8909ac99ed4ab2ee4d681ec864c7831e", "completion": "def count_distinct_cyclic_shifts(input_word):\n    distinct_words = set()\n    \n    for i in range(len(input_word)):\n        shifted_word = input_word[-i:] + input_word[:-i]\n        distinct_words.add(shifted_word)\n    \n    return str(len(distinct_words))"}
{"task_id": "ceb3807aaffef60bcdbcc9a17a1391be", "completion": "def kefa_balloon_distribution(input_str):\n    n, k = map(int, input_str.split(\"\\n\")[0].split())\n    colors = input_str.split(\"\\n\")[1].strip()\n\n    color_counts = {}\n    for color in colors:\n        color_counts[color] = color_counts.get(color, 0) + 1\n\n    for count in color_counts.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\""}
{"task_id": "24fd5cd218f65d4ffb7c5b97b725293e", "completion": "def sum_of_beauty(n_str):\n    MOD = 998244353\n    n = int(n_str)\n\n    def power(x, y):\n        res = 1\n        while y > 0:\n            if y & 1:\n                res = (res * x) % MOD\n            x = (x * x) % MOD\n            y >>= 1\n        return res\n\n    def inverse(x):\n        return power(x, MOD - 2)\n\n    def nCr(n, r):\n        res = 1\n        for i in range(r):\n            res = (res * (n - i) * inverse(i + 1)) % MOD\n        return res\n\n    result = 0\n    for k in range(n + 1):\n        result = (result + nCr(2 * n - (n - k), k) * nCr(n, k)) % MOD\n\n    return str(result)"}
{"task_id": "2b8c2deb5d7e49e8e3ededabfd4427db", "completion": "def check_odd_subsegments(input_str):\n\n    lines = input_str.splitlines()\n    n = int(lines[0])  \n    seq = list(map(int, lines[1].split()))  \n\n    if n % 2 != 0 and seq[0] % 2 != 0 and seq[-1] % 2 != 0:\n        return 'Yes'\n\n    return 'No'\n\n"}
{"task_id": "82a4a60eac90765fb62f2a77d2305c01", "completion": "def max_fruits_count(input_str):\n    a, b, c = map(int, input_str.strip().split('\\n'))\n    \n    x = min(a, b//2, c//4)\n    \n    return str(x * 7) if x > 0 else '0'"}
{"task_id": "f52af273954798a4ae38a1378bfbf77a", "completion": "def find_rectangular_display_size(n):\n    n = int(n)\n    best_a = 1\n    best_b = n\n    min_diff = n - 1\n\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            a = i\n            b = n // i\n            if b >= a and b - a <= min_diff:\n                min_diff = b - a\n                best_a = a\n                best_b = b\n\n    return f\"{best_a} {best_b}\""}
{"task_id": "78d013b01497053b8e321fe7b6ce3760", "completion": "def minimum_total_cost(input_str):\n    n, c1, c2, people = map(int, input_str.split())\n\n    children = sum([int(char) for char in str(people)]) - sum([int(char) for char in str(people)][:2])\n\n    min_adults = 1\n    max_adults = n - 1 if sum([int(char) for char in str(people)]) < n else n - children\n\n    dp = [0] + [float('inf')] * n\n\n    for i in range(1, n + 1):\n        for j in range(min_adults, min(i, max_adults) + 1):\n            cost = c1 + c2 * (j - 1)**2\n            dp[i] = min(dp[i], dp[i - j] + cost)\n\n    return str(dp[n])\n\ntest_cases = [{'input': '3 4 1\\n011', 'output': '8'}, {'input': '4 7 2\\n1101', 'output': '18'}]\n\nfor test_case in test_cases:\n    input_data = test_case['input']\n    expected_output = test_case['output']\n    assert minimum_total_cost(input_data) == expected_output\n\nassert minimum_total_cost('5 3 1\\n11111') == '10'\nassert minimum_total_cost('6 2 3\\n111000') == '8'"}
{"task_id": "7853e03d520cd71571a6079cdfc4c4b0", "completion": "def find_initial_position(input_str):\n    n, x = map(int, input_str.strip().split('\\n'))\n    \n    if n % 2 == 1:\n        return str((x + (n+1)//2) % 3)\n    else:\n        return str((x - n//2 + 3) % 3)"}
{"task_id": "d82278932881e3aa997086c909f29051", "completion": "def is_quasi_palindromic_number(x):\n    x_str = str(x).lstrip('0')\n    \n    if x_str == x_str[::-1]:\n        return 'YES'\n    \n    for i in range(1, len(x_str)+1):\n        updated_str = '0' * i + x_str\n        if updated_str == updated_str[::-1]:\n            return 'YES'\n    \n    return 'NO'"}
{"task_id": "ab8a2070ea758d118b3c09ee165d9517", "completion": "def flew_more_times(data):\n    sf_count = 0\n    seattle_count = 0\n    for i in range(len(data)-1):\n        if data[i:i+2] == 'SF':\n            sf_count += 1\n        elif data[i:i+2] == 'FS':\n            seattle_count += 1\n    return 'YES' if sf_count > seattle_count else 'NO'"}
{"task_id": "3a0c1b6d710fd8f0b6daf420255d76ee", "completion": "def smallest_pretty_integer(input_str):\n    list_1, list_2, _ = input_str.strip().splitlines()\n\n    pretty_num = None\n    for digit1 in list(map(int, list_1.split())):\n        for digit2 in list(map(int, list_2.split())):\n            formed_num = int(str(digit1) + str(digit2))\n            if any(str(d) in str(formed_num) for d in list(map(int, list_1.split()))) and any(str(d) in str(formed_num) for d in list(map(int, list_2.split()))):\n                if pretty_num is None or formed_num < pretty_num:\n                    pretty_num = formed_num\n\n    return str(pretty_num) if pretty_num is not None else \"0\""}
{"task_id": "ab8a2070ea758d118b3c09ee165d9517", "completion": "def flew_more_times(data):\n    sf_count = 0\n    seattle_count = 0\n    for i in range(len(data)-1):\n        if data[i:i+2] == 'SF':\n            sf_count += 1\n        elif data[i:i+2] == 'FS':\n            seattle_count += 1\n    return 'YES' if sf_count > seattle_count else 'NO'"}
{"task_id": "3a0c1b6d710fd8f0b6daf420255d76ee", "completion": "def smallest_pretty_integer(input_str):\n    list_1, list_2, _ = input_str.strip().splitlines()\n\n    pretty_num = None\n    for digit1 in list(map(int, list_1.split())):\n        for digit2 in list(map(int, list_2.split())):\n            formed_num = int(str(digit1) + str(digit2))\n            if any(str(d) in str(formed_num) for d in list(map(int, list_1.split()))) and any(str(d) in str(formed_num) for d in list(map(int, list_2.split()))):\n                if pretty_num is None or formed_num < pretty_num:\n                    pretty_num = formed_num\n\n    return str(pretty_num) if pretty_num is not None else \"0\""}
{"task_id": "68ca8a8730db27ac2230f9fe9b120f5f", "completion": "def max_golden_age(input_str):\n    x, y, l, r = map(int, input_str.split())\n\n    def is_unlucky(year):\n        return any((year - a * x) % y == 0 for a in range((year // x) + 1))\n    \n    max_gap = 0\n    gap = 0\n\n    for year in range(l, r+1):\n        if is_unlucky(year):\n            max_gap = max(max_gap, gap)\n            gap = 0\n        else:\n            gap += 1\n\n    return str(max(max_gap, gap))"}
{"task_id": "1c80040104e06c9f24abfcfe654a851f", "completion": "def teleportation_challenge(input_str):\n    x1, y1, x2, y2, x, y = map(int, input_str.split())\n\n    diff_x = abs(x2 - x1)\n    diff_y = abs(y2 - y1)\n    \n    return \"YES\" if (diff_x % abs(x) == 0) and (diff_y % abs(y) == 0) else \"NO\""}
{"task_id": "9300f1c07dd36e0cf7e6cb7911df4cf2", "completion": "def max_bananas(input_str):\n    x, y = map(int, input_str.split())\n    k = x + y\n    n = min(x, y)\n    result = 0\n    \n    for i in range(n + 1):\n        bananas = (k - i) * (i + 1)\n        result = max(result, bananas)\n    \n    return str(result)"}
{"task_id": "7bf30ceb24b66d91382e97767f9feeb6", "completion": "import math\n\n\ndef gcd_of_factorials(input_str):\n    A, B = map(int, input_str.split())\n    factorial_A = math.factorial(A)\n    factorial_B = math.factorial(B)\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n\n    return gcd(factorial_A, factorial_B)\n"}
{"task_id": "0644605611a2cd10ab3a9f12f18d7ae4", "completion": "def find_fault_rate(input_str):\n    MOD = 10**9 + 7\n\n    def fast_max(n, k, a):\n        ans = 0\n        offset = 0\n        for i in range(n):\n            if ans < a[i]:\n                ans = a[i]\n                offset = 0\n            else:\n                offset += 1\n                if offset == k:\n                    return ans\n        return ans\n\n    n, k = map(int, input_str.split())\n    result = 0\n\n    def calculate_permutations(nums):\n        if len(nums) == 0:\n            return 1\n        perms = 0\n        for i in range(len(nums)):\n            perms += calculate_permutations(nums[:i] + nums[i+1:])\n        return perms\n\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial = (factorial * i) % MOD\n\n    for i in range(1, n + 1):\n        perms = calculate_permutations([x for x in range(1, i)] + [x for x in range(i+1, n+1)])\n        perms = (perms * pow(factorial // i, n - i, MOD)) % MOD\n        perms = (perms * i) % MOD\n        result = (result + perms) % MOD\n\n    not_n_permutations = (factorial - result) % MOD\n    return str(not_n_permutations)"}
{"task_id": "b9fa2bb8001bd064ede531a5281cfd8a", "completion": "def max_correct_commands(commands):\n    return min(commands.count('U'), commands.count('D')) * 2 + min(commands.count('L'), commands.count('R')) * 2\n\n# Test cases\ntest_cases = [{'input': '4\\nLDUR', 'output': '4'}, {'input': '5\\nRRRUU', 'output': '0'}, {'input': '6\\nLLRRRR', 'output': '4'}]\n\nfor test_case in test_cases:\n    input_data = test_case['input'].split('\\n')[1].strip()\n    expected_output = test_case['output']\n    assert max_correct_commands(input_data) == int(expected_output)"}
{"task_id": "d3a8a3e69a55936ee33aedd66e5b7f4a", "completion": "def find_max_sum(input_str):\n    input_list = input_str.split('\\n')\n    n, m = map(int, input_list[0].split())\n    numbers = list(map(int, input_list[1].split()))\n\n    max_sum = 0\n\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum = max(current_sum + numbers[j] - m, 0)\n            max_sum = max(max_sum, current_sum)\n\n    return str(max_sum)"}
{"task_id": "698da80c7d24252b57cca4e4f0ca7031", "completion": "def min_steps_to_move_circle(input_str):\n    r, x, y, x_new, y_new = map(int, input_str.split())\n    \n    dx = x_new - x\n    dy = y_new - y\n    dist = (dx ** 2 + dy ** 2) ** 0.5\n    \n    if dist == 0:\n        return \"0\"\n    \n    if dist <= 2 * r:\n        return \"1\"\n    \n    return \"3\""}
{"task_id": "60dbfc7a65702ae8bd4a587db1e06398", "completion": "def find_max_number(input_string):\n    n, a = map(int, input_string.strip().split('\\n'))\n\n    for num in range(10**n - 1, 10**(n - 1) - 1, -1):\n        if '0' not in str(num) and '1' not in str(num):\n            factorial_sum = sum([1 if digit == '2' else math.factorial(int(digit)) for digit in str(num)])\n            if factorial_sum == a:\n                return str(num)\n\n    return \"\""}
{"task_id": "e03c6d3bb8cf9119530668765691a346", "completion": "from itertools import permutations\n\ndef get_kth_permutation(input_str):\n    n, k = map(int, input_str.split())\n    \n    perm_list = []\n    for perm in permutations(range(1, n+1)):\n        cyclic_perm = [perm[i-1] for i in perm]\n        if cyclic_perm == list(perm):\n            perm_list.append(list(perm))\n\n    perm_list.sort()\n    kth_permutation = perm_list[k-1]\n    \n    return ' '.join(map(str, kth_permutation))"}
{"task_id": "185ff90a8b0ae0e2b75605f772589410", "completion": "def count_triangle_ways(input_str):\n    a, b, c, l = map(int, input_str.split())\n    count = 0\n    \n    for x in range(l + 1):\n        for y in range(l + 1):\n            for z in range(l + 1):\n                if x + y + z <= l and (a+x) < b+y+c and (b+y) < a+x+c and (c+z) < a+x+b:\n                    count += 1\n\n    return str(count)"}
{"task_id": "775766790e91e539c1cfaa5030e5b955", "completion": "def count_days(input_str):\n    red_socks, blue_socks = map(int, input_str.split())\n    max_different_days = min(red_socks, blue_socks)\n    remaining_socks = abs(red_socks - blue_socks)\n    same_socks_days = remaining_socks // 2\n    return f\"{max_different_days} {same_socks_days}\""}
{"task_id": "bf8a133154745e64a547de6f31ddc884", "completion": "def min_bitcoins_to_win_battle(input_str):\n    def simulate_battle(hp_yang, atk_yang, def_yang, hp_monster, atk_monster, def_monster):\n        while hp_monster > 0 and hp_yang > 0:\n            hp_monster -= max(0, atk_yang - def_monster)\n            hp_yang -= max(0, atk_monster - def_yang)\n        return hp_monster <= 0 and hp_yang > 0\n\n    h, a, d, *attributes = map(int, input_str.split())\n    min_bitcoins = float('inf')\n    \n    for i in range(attributes[0] + 1):\n        for j in range(attributes[1] + 1):\n            for k in range(attributes[2] + 1):\n                if simulate_battle(attributes[3] + i, attributes[4] + j, attributes[5] + k, attributes[6], attributes[7], attributes[8]):\n                    cost = i * h + j * a + k * d\n                    min_bitcoins = min(min_bitcoins, cost)\n\n    return str(min_bitcoins)"}
{"task_id": "52e07d176aa1d370788f94ee2e61df93", "completion": "def optimalChessWinner(input_string):\n    n = int(input_string)\n    if n % 2 == 0:\n        return \"white\\n1 2\"\n    return \"black\""}
{"task_id": "1f68bd6f8b40e45a5bd360b03a264ef4", "completion": "def count_solutions(input_str):\n    A = int(input_str)\n    count = 0\n    for x in range(1, A + 1):\n        if x * 2 == A:\n            count += 1\n    return str(count)"}
{"task_id": "d6c876a84c7b92141710be5d76536eab", "completion": "def can_choose_balls(input_str):\n    sizes = list(map(int, input_str.split('\\n')[1].split()))\n    sizes.sort()\n\n    for i in range(len(sizes)-2):\n        for j in range(i+1, len(sizes)-1):\n            for k in range(j+1, len(sizes)):\n                if sizes[j] > sizes[i] + 2 or sizes[k] > sizes[j] + 2:\n                    break\n                if sizes[i] != sizes[j] and sizes[i] != sizes[k] and sizes[j] != sizes[k]:\n                    return 'YES'\n\n    return 'NO'"}
{"task_id": "1c4cf1c3cb464a483511a8a61f8685a7", "completion": "def calculate_total_buses(input_str):\n    a, ta, b, tb, start_time = [int(x) for x in input_str.split()]\n    start_hours, start_minutes = map(int, start_time.split(':'))\n    \n    start_minutes_total = start_hours * 60 + start_minutes\n    \n    buses_meeting = 0\n    for time in range(300, 1440):  #From 05:00 AM to 11:59 PM\n        if (time - start_minutes_total) % a == 0 and (time - start_minutes_total) >= ta:\n            buses_meeting += 1\n        if (time - start_minutes_total) % b == 0 and (time - start_minutes_total) >= tb:\n            buses_meeting += 1\n    \n    return str(buses_meeting)"}
{"task_id": "7bffa6e8d2d21bbb3b7f4aec109b3319", "completion": "def min_total_distance(input_str):\n    x1, x2, x3 = map(int, input_str.split())\n    distances = [abs(x1 - x2), abs(x2 - x3), abs(x3 - x1)]\n    return str(sum(sorted(distances)[:2]))"}
{"task_id": "069d0cb9b7c798a81007fb5b63fa0f45", "completion": "def time_to_get_lunch(seat):\n    row, seat_letter = int(seat[:-1]), seat[-1]\n    seat_index = ord(seat_letter) - ord('a') + 1\n\n    row_offset = 2 * (row - 1)\n    total_offset = row_offset + (1 if seat_index > 3 else 0)\n\n    time_to_reach_row = (row - 1) * 2\n    \n    time_to_serve_all_rows_before = (row - 1) * 6\n\n    return str(time_to_serve_all_rows_before + time_to_reach_row + total_offset)"}
{"task_id": "581f61b1f50313bf4c75833cefd4d022", "completion": "def count_years_with_one_zero_in_binary(interval):\n    start_year, end_year = map(int, interval.split())\n\n    count = sum(1 for year in range(start_year, end_year + 1) if bin(year).count('0') == 1)\n\n    return str(count)"}
{"task_id": "757cd804aba01dc4bc108cb0722f68dc", "completion": "def final_slime_row(n_str):\n    n = int(n_str)  \n    slimes = [1]  \n\n    for i in range(1, n):  \n        slimes.append(1)  \n        idx = len(slimes) - 1  \n\n        while idx > 0 and slimes[idx] == slimes[idx - 1]:\n            slimes[idx - 1] += 1  \n            slimes.pop()  \n            idx -= 1\n\n    return ' '.join(map(str, slimes))  "}
{"task_id": "3c4b2d1c9440515bc3002eddd2b89f6f", "completion": "def max_string_length(input_string):\n    letters = list(map(int, input_string.strip().split()))[1:]\n    letters.sort(reverse=True)\n\n    result = 0\n    occurrences = set()\n\n    for letter_count in letters:\n        if letter_count in occurrences:\n            while letter_count > 0 and letter_count in occurrences:\n                letter_count -= 1\n            if letter_count > 0:\n                occurrences.add(letter_count)\n                result += letter_count\n        else:\n            occurrences.add(letter_count)\n            result += letter_count\n\n    return str(result)"}
{"task_id": "3d3432b4f7c6a3b901161fa24b415b14", "completion": "def max_games_winner_can_play(n):\n    n = int(n)\n    if n == 2:\n        return '1'\n    elif n <= 4:\n        return '2'\n    else:\n        k = 1\n        while 2**k - 1 < n:\n            k += 1\n        return str(k - 1)"}
{"task_id": "7bd5521531950e2de9a7b0904353184d", "completion": "def count_returning_substrings(input_str):\n    n, commands = input_str.strip().split('\\n')\n    n = int(n)\n\n    position = {0: 1}\n    x, y = 0, 0\n    returning_substrings = 0\n\n    for command in commands:\n        if command == 'U':\n            y += 1\n        elif command == 'R':\n            x += 1\n        elif command == 'D':\n            y -= 1\n        elif command == 'L':\n            x -= 1\n\n        current_position = x + y * 1j\n\n        if current_position in position:\n            returning_substrings += position[current_position]\n            position[current_position] += 1\n        else:\n            position[current_position] = 1\n\n    return str(returning_substrings)"}
{"task_id": "18410980789b14c128dd6adfa501aea5", "completion": "def count_possible_pairs(input_str):\n    s, x = map(int, input_str.split())\n    \n    count = sum(1 for a in range(s + 1) if a ^ (s - a) == x)\n    \n    return str(count)"}
{"task_id": "4fb83b890e472f86045981e1743ddaac", "completion": "def best_grade(input_str):\n    lines = input_str.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    building_times = list(map(int, lines[1].split()))\n    adjacency_list = [list(map(int, line.split()))[1:] for line in lines[2:]]\n\n    def dfs(node, parent, best_grade):\n        times = [building_times[node - 1]]\n        for neighbor in adjacency_list[node - 1]:\n            if neighbor != parent:\n                times.extend(dfs(neighbor, node, best_grade))\n        times.sort()\n        return times\n\n    result = float('inf')\n    for root in range(1, n + 1):\n        current_grade = min(dfs(root, 0, float('inf')))\n        result = min(result, current_grade)\n\n    return str(result)"}
{"task_id": "f1b43baa14d4c262ba616d892525dfde", "completion": "def max_lucky_offices(n):\n    n = int(n)\n    if n < 1:\n        return \"Invalid input. Please enter a positive integer.\"\n    if n == 1:\n        return \"2\"\n\n    total_count = [2, 4]\n    for i in range(2, n):\n        total_count.append(total_count[-1] * 2)\n\n    max_offices = sum(total_count)\n    return str(max_offices)\n"}
{"task_id": "509db9cb6156b692557ba874a09f150e", "completion": "def min_rotations(rotation_angle):\r\n    rotation = int(rotation_angle) % 360\r\n    if rotation < 0:\r\n        rotation += 360\r\n    return str((abs(rotation) + 45) // 90)  # Updated calculation for minimum number of 90-degree clockwise turns\r\n\r\n# Test the function with the provided test cases\r\ntest_cases = [{'input': '60', 'output': '1'}, {'input': '-60', 'output': '3'}]\r\n\r\nfor test_case in test_cases:\r\n    input_angle = test_case['input']\r\n    expected_output = test_case['output']\r\n    output = min_rotations(input_angle)\r\n    \r\n    print(f\"Input: {input_angle}, Expected Output: {expected_output}, Output: {output}\")\r\n\r\n# Function call to test with custom inputs\r\nprint(min_rotations('120'))  # Expected output: 1\r\nprint(min_rotations('-120'))  # Expected output: 2"}
{"task_id": "cfe19131644e5925e32084a581e23286", "completion": "def count_variant_sequences(input_str):\n    n, k = map(int, input_str.split())\n    MOD = 777777777\n    \n    dp = [[0]*(n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - j + 1) + dp[i][j - 1] * (j - i)) % MOD\n\n    return str(dp[k][n])"}
{"task_id": "656ed7b1b80de84d65a253e5d14d62a9", "completion": "def count_lucky_assignments(m_str):\n    m = int(m_str)\n    MOD = 1000000007\n\n    answer = 0\n    for num_lucky_in_elephant in range(1, m + 1):\n        num_lucky_in_other = m - num_lucky_in_elephant\n        for x in range(2, 3):  \n            for y in range(0, 2):\n                ways_elephant = (pow(2, x + num_lucky_in_elephant - 2, MOD) - pow(2, num_lucky_in_elephant - x - 1, MOD)) % MOD\n                ways_other = (pow(2, y + num_lucky_in_other - 2, MOD) - pow(2, num_lucky_in_other - y - 1, MOD)) % MOD\n                answer = (answer + ways_elephant * ways_other) % MOD\n\n    return answer\n\n# Test cases\ntest_cases = [{'input': '7', 'output': '0'}, {'input': '8', 'output': '1440'}]\n\nfor test in test_cases:\n    input_val = test['input']\n    expected_output = int(test['output'])\n    assert count_lucky_assignments(input_val) == expected_output"}
{"task_id": "c03b6379e9d186874ac3d97c6968fbd0", "completion": "def count_winning_strategies(input_str):\n    p, n = map(int, input_str.split())\n    \n    if p == 2:\n        return 0\n    \n    MOD = 1000000007\n    result = pow(2, p - 2, MOD)\n    total_ways = (result * n) % MOD\n\n    return total_ways\n\ntest_cases = [{'input': '2 2', 'output': '0'}, {'input': '4 4', 'output': '520'}, {'input': '100 1000', 'output': '269568947'}]\n\nfor test_case in test_cases:\n    input_data = test_case['input']\n    expected_output = test_case['output']\n\n    assert count_winning_strategies(input_data) == int(expected_output)"}
{"task_id": "83bcfe32db302fbae18e8a95d89cf411", "completion": "def find_min_splitters(input_str):\n    n, k = map(int, input_str.split())\n    \n    if n < k:\n        return \"-1\"\n    \n    num_splitters = 0\n    connected_pipes = 1\n    \n    while connected_pipes < n:\n        for x in range(k, 1, -1):\n            if connected_pipes + x - 1 <= n:\n                connected_pipes += x - 1\n                num_splitters += 1\n                break\n\n    return str(num_splitters) if connected_pipes == n else \"-1\""}
{"task_id": "d3c10d1b1a17ad018359e2dab80d2b82", "completion": "def count_possible_variants(hint):\n    valid_combinations = 1\n    seen_digits = set()\n    \n    for char in hint:\n        if char == '?':\n            valid_combinations *= 10\n        elif char.isdigit():\n            seen_digits.add(char)\n        else:\n            if char not in seen_digits:\n                seen_digits.add(char)\n                valid_combinations *= 10 - len(seen_digits)\n    \n    return str(valid_combinations)"}
{"task_id": "1f0e8bbd5bf4fcdea927fbb505a8949b", "completion": "def min_shoe_changes(input_str):\n    lines = input_str.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    \n    shoe_coords = {}\n    for i in range(1, n + 1):\n        shoes = list(map(int, lines[i].split()))\n        for j in range(m):\n            shoe_coords[shoes[j]] = (i, j + 1)\n    \n    changes = 0\n    for shoe_num in range(1, n*m, 2):\n        x1, y1 = shoe_coords[shoe_num]\n        x2, y2 = shoe_coords[shoe_num+1]\n        \n        if abs(x1 - x2) + abs(y1 - y2) != 1:\n            changes += 1\n            \n    return changes"}
{"task_id": "9b543e07e805fe1dd8fa869d5d7c8b99", "completion": "def max_ones_after_one_move(input_str):\n    data = input_str.strip().split('\\n')\n    n = int(data[0])\n    values = list(map(int, data[1].split()))\n\n    max_ones = 0\n    for i in range(n):\n        for j in range(i, n):\n            ones_count = sum([1 - value if i <= idx <= j else value for idx, value in enumerate(values)])\n            max_ones = max(max_ones, ones_count)\n\n    return str(max_ones)"}
{"task_id": "f3c96123334534056f26b96f90886807", "completion": "def check_point_set(points_str):\n    points = []\n    for point in points_str.strip().split('\\n'):\n        if point.strip():  \n            try:\n                x, y = map(int, point.split())\n                points.append((x, y))\n            except ValueError:\n                return 'ugly'  \n\n    x_values = sorted(set(x for x, _ in points))\n    y_values = sorted(set(y for _, y in points))\n\n    if len(x_values) != 3 or len(y_values) != 3:\n        return 'ugly'\n\n    intersection_points = [(x, y) for x in x_values for y in y_values if (x, y) != (x_values[1], y_values[1])]\n\n    if set(points) == set(intersection_points):\n        return 'respectable'\n    else:\n        return 'ugly'"}
{"task_id": "c7aa8a95d5f8832015853cffa1374c48", "completion": "def calculate_common_bricks(input_str):\n    x, y, a, b = map(int, input_str.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    def count_bricks_painted(lcm_val, start, end):\n        return (end - start) // lcm_val + 1\n\n    lcm_val = lcm(x, y)\n    start_bricks = max(a, lcm_val)\n    end_bricks = min(b, (b // lcm_val) * lcm_val)\n\n    return str(count_bricks_painted(lcm_val, start_bricks, end_bricks))\n\nprint(calculate_common_bricks('2 3 6 18'))"}
{"task_id": "b3b986fddc3770fed64b878fa42ab1bc", "completion": "def build_molecule(valence_numbers):\n    atom_valences = list(map(int, valence_numbers.split()))\n    total_valence = sum(atom_valences)\n    \n    if total_valence % 2 != 0:\n        return \"Impossible\"\n    \n    bonds = [(valence + 1) // 2 for valence in atom_valences]\n    \n    max_bonds = max(bonds)\n    \n    if max_bonds * 2 > total_valence:\n        return \"Impossible\"\n    \n    return \" \".join(map(str, bonds))"}
{"task_id": "7dbf58806db185f0fe70c00b60973f4b", "completion": "def min_moves_to_destination(input_str):\n    r1, c1, r2, c2 = map(int, input_str.split())\n\n    rook_moves = 2 if r1 != r2 and c1 != c2 else 1\n    \n    bishop_moves = 1 if abs(r1 - r2) == abs(c1 - c2) else 0\n    \n    king_moves = max(abs(r1 - r2), abs(c1 - c2), 1)\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\""}
{"task_id": "5fdaf8ee7763cb5815f49c0c38398f16", "completion": "def can_press_in_timing(input_str):\n    lines = input_str.strip().split('\\n')\n    k = int(lines[0])\n    panels = lines[1:]\n    count = [0] * 10\n\n    for row in panels:\n        for panel in row:\n            if panel != '.':\n                count[int(panel)] += 1\n\n\n    for c in count:\n        if c > 2 * k:\n            return \"NO\"\n\n    return \"YES\"\n"}
{"task_id": "ee9fa8be2ae05a4e831a4f608c0cc785", "completion": "def bear_forest_walk(input_str):\n    n, t, sx, sy, dx, dy = map(int, input_str.split())\n    x, y = sx, sy\n\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n\n    return f\"{x} {y}\""}
{"task_id": "8b26ca1ca2b28166c3d25dceb1f3d49f", "completion": "def min_insertions_to_functional_protein(dna):\n    segments = [1]\n    for i in range(1, len(dna)):\n        if dna[i] == dna[i-1]:\n            segments[-1] += 1\n        else:\n            segments.append(1)\n    \n    total_insertions = sum(seg // 2 for seg in segments if seg % 2 == 0)\n    \n    return str(total_insertions)"}
{"task_id": "a2616b1681f30ce4b2a5fdc81cf52b50", "completion": "def find_initial_permutation(operations):\n    ops = operations.strip().split('\\n')\n    n, m = map(int, ops[0].split())\n    cups = list(range(1, n + 1))\n\n    for i in range(m-1, -1, -1):\n        xi, yi = map(int, ops[i + 1].split())\n        idx = cups.index(xi)\n        val = cups.pop(idx)\n        cups.insert(0, val)\n\n    return ' '.join(map(str, cups)) if len(cups) == n else '-1'"}
{"task_id": "111673158df2e37ac6c019bb99225ccb", "completion": ""}
{"task_id": "d73d9610e3800817a3109314b1e6f88c", "completion": "def max_destroyed_balls(input_str):\n    n, k, x = map(int, input_str.split(\"\\n\")[0].split())\n    balls = list(map(int, input_str.split(\"\\n\")[1].split()))\n    max_destroyed = 0\n\n    for i in range(n + 1):  \n        new_balls = balls[:i] + [x] + balls[i:]\n        total_destroyed = 0\n\n        while True:\n            found = False\n            j = 0\n            while j < len(new_balls) - 2:  \n                if new_balls[j] == new_balls[j + 1] == new_balls[j + 2]:\n                    color = new_balls[j]\n                    k = j\n                    while k < len(new_balls) and new_balls[k] == color:\n                        k += 1\n                    total_destroyed += (k - j)\n                    new_balls = new_balls[:j] + new_balls[k:]\n                    found = True\n                else:\n                    j += 1\n            if not found:  \n                break\n\n        max_destroyed = max(max_destroyed, total_destroyed)  \n\n    return max_destroyed"}
{"task_id": "faa343ad6028c5a069857a38fa19bb24", "completion": "def minimum_cost(input_str):\n    n, m, a, b = map(int, input_str.split())\n    \n    cost_individual = n * a\n    cost_special_tickets = (n // m) * b + min((n % m) * a, b)\n    \n    return str(min(cost_individual, cost_special_tickets))"}
{"task_id": "e56f6c343167745821f0b18dcf0d0cde", "completion": "def maximize_number_with_swaps(input_str):\n    a, k = input_str.split()\n    a = list(a)\n    \n    for i in range(len(a)):\n        max_idx = i\n        \n        for j in range(i+1, min(i+int(k)+1, len(a))):\n            if a[j] > a[max_idx]:\n                max_idx = j\n        \n        while max_idx > i:\n            a[max_idx], a[max_idx-1] = a[max_idx-1], a[max_idx]\n            max_idx -= 1\n            k = int(k) - 1\n            \n            if k == 0:\n                break\n        \n        if k == 0:\n            break\n    \n    return ''.join(a)\n\n# Test cases\ntest_cases = [{'input': '1990 1', 'output': '9190'},\n              {'input': '300 0', 'output': '300'},\n              {'input': '1034 2', 'output': '3104'},\n              {'input': '9090000078001234 6', 'output': '9907000008001234'}]\n\nfor test_case in test_cases:\n    input_str, expected_output = test_case['input'], test_case['output']\n    output = maximize_number_with_swaps(input_str)\n    \n    assert output == expected_output, f\"Expected: {expected_output}, Output: {output}\""}
{"task_id": "67410b7d36b9d2e6a97ca5c7cff317c1", "completion": "def max_toasts(input_str):\n    n, k, l, c, d, p, nl, np = map(int, input_str.split())\n    \n    max_toasts_drink = k * l // (n * nl)\n    max_toasts_lime = c * d // n\n    max_toasts_salt = p // (n * np)\n    \n    return str(min(max_toasts_drink, max_toasts_lime, max_toasts_salt))\n\n# Test cases\ntest_cases = [{'input': '3 4 5 10 8 100 3 1', 'output': '2'},\n              {'input': '5 100 10 1 19 90 4 3', 'output': '3'},\n              {'input': '10 1000 1000 25 23 1 50 1', 'output': '0'}]\n\nfor test_case in test_cases:\n    input_str = test_case['input']\n    expected_output = test_case['output']\n    assert max_toasts(input_str) == expected_output\n\nprint(\"All test cases passed!\")"}
{"task_id": "4e166b8b44427b1227e0f811161d3a6f", "completion": "def maximize_earnings(input_str):\n    total_dough, num_stuffings, num_buns, d0, *info = map(int, input_str.split())\n    stuffings = [(info[i], info[i+1], info[i+2], info[i+3]) for i in range(0, num_stuffings*4, 4)]\n    c0 = info[-2]\n    \n    max_tugriks = 0\n    \n    for ai, bi, ci, di in stuffings:\n        max_buns = min(ai // bi, total_dough // ci)\n        earnings = max_buns * di\n        max_tugriks = max(max_tugriks, earnings)\n    \n    remaining_plain_buns = total_dough // c0\n    max_tugriks = max(max_tugriks, remaining_plain_buns * d0)\n\n    return str(max_tugriks)"}
{"task_id": "097674b4dd696b30e102938f71dd39b9", "completion": "def max_spider_free_cells(input_str):\n    n, m = map(int, input_str.split())\n    \n    if n == 1 or m == 1:\n        return 0\n    else:\n        return n * m - 2 * (n + m) + 4"}
{"task_id": "cb2aa02772f95fefd1856960b6ceac4c", "completion": "from itertools import permutations\n\ndef count_lucky_numbers(input_str):\n    n, k = map(int, input_str.split())\n\n    def is_lucky_number(num):\n        return all(digit in ['4', '7'] for digit in str(num))\n\n    count = 0\n    for perm in permutations(range(1, n + 1)):\n        for i, num in enumerate(perm, 1):\n            if is_lucky_number(num) and is_lucky_number(i):\n                count += 1\n\n    return str(count)\n\ntest_cases = [{'input': '7 4', 'output': '1'}, {'input': '4 7', 'output': '1'}]\nfor test_case in test_cases:\n    input_data = test_case['input']\n    expected_output = test_case['output']\n    output = count_lucky_numbers(input_data)\n    print(f\"Input: {input_data}, Expected Output: {expected_output}, Output: {output}\")"}
{"task_id": "b715f0fdc83ec539eb3ae2b0371ee130", "completion": "def count_valid_strings(input_string):\n    k, w = map(int, input_string.split())\n\n    MOD = 10**9 + 7\n\n    dp = [0] * (w + 1)\n    dp[1] = k\n    dp[2] = (k * (k - 1)) % MOD\n\n    for i in range(3, w + 1):\n        dp[i] = ((k - 1) * dp[i - 1] + (k - 2) * dp[i - 2]) % MOD\n\n    return str(dp[w])"}
{"task_id": "87d869a0fd4a510c5e7e310886b86a57", "completion": "def find_interesting_states(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    values = list(map(int, input_lines[1].split()))\n    transitions = [list(map(int, line.split())) for line in input_lines[2:]]\n\n    interesting_states = [0] * n\n\n    starting_points = {i for i, value in enumerate(values) if value == 1}\n    endpoints = {i for i, value in enumerate(values) if value == 2}\n\n    def dfs(node, visited):\n        visited.add(node)\n        if node in endpoints:\n            return True\n        for neighbor in [t[1] for t in transitions if t[0] == node]:\n            if neighbor not in visited and dfs(neighbor, visited):\n                return True\n        return False\n\n    for point in starting_points:\n        visited = set()\n        if dfs(point, visited):\n            for v in visited:\n                interesting_states[v] = 1\n\n    return '\\n'.join(map(str, interesting_states))\n\n# Test the function with the provided test cases\ntest_cases = [{'input': '4 3\\n1 0 0 2\\n1 2\\n2 3\\n3 4', 'output': '1\\n1\\n1\\n1'},\n              {'input': '3 1\\n1 0 2\\n1 3', 'output': '1\\n0\\n1'},\n              {'input': '3 1\\n2 0 1\\n1 3', 'output': '0\\n0\\n0'}]\n\nfor test_case in test_cases:\n    input_data = test_case['input']\n    expected_output = test_case['output']\n    assert find_interesting_states(input_data) == expected_output"}
{"task_id": "7419c4268a9815282fadca6581f28ec1", "completion": "def maximize_profit(input_str):\n    lines = input_str.strip().split('\\n')\n    n, m, k = map(int, lines[0].split())\n    \n    planets = []\n    for i in range(1, n * (m + 1), m + 1):\n        planet_data = []\n        for j in range(i + 1, i + m + 1):\n            planet_data.append(list(map(int, lines[j].split())))\n        planets.append(planet_data)\n\n    max_profit = 0\n\n    for i in range(n):\n        for j in range(n):\n            for type_buy in range(m):\n                buy_cost = planets[i][type_buy][0]\n                buy_max = planets[i][type_buy][2]\n                \n                for type_sell in range(m):\n                    sell_cost = planets[j][type_sell][1]\n\n                    if i != j and buy_max > 0:\n                        items_bought = min(k, buy_max)\n                        profit = items_bought * (sell_cost - buy_cost)\n                        max_profit = max(max_profit, profit)\n\n    return str(max_profit)"}
{"task_id": "8ab25ed4955d978fe20f6872cb94b0da", "completion": "def calculate_total_tiles(input_string):\n    a, b, c = map(int, input_string.split())\n    total_tiles = a * b + b * c + a * c - a - b - c + 1\n    return str(total_tiles)"}
{"task_id": "c706cfcd4c37fbc1b1631aeeb2c02b6a", "completion": "def maximize_trailing_nines(input_str):\n    p, d = map(int, input_str.split())\n    \n    num_nines = len(str(p)) - len(str(p).rstrip('9'))\n    max_nines = min(num_nines + d, len(str(p)) - 1)\n    \n    max_price = p\n    for i in range(max_nines):\n        max_price = (max_price // 10) * 10 + 9\n    \n    return str(max_price)"}
{"task_id": "984788e4b4925c15c9c6f31e42f2f8fa", "completion": "def count_triangle_groups(input_str):\n    w, h = map(int, input_str.split())\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    result = 0\n\n    for x1 in range(w + 1):\n        for y1 in range(h + 1):\n            for x2 in range(w + 1):\n                for y2 in range(h + 1):\n                    area = abs(x1*y2 - x2*y1) / 2\n                    if area.is_integer() and area > 0 and gcd(abs(x1 - x2), abs(y1 - y2)) == 1:\n                        result += 1\n\n    return result"}
{"task_id": "0f7f10557602c8c2f2eb80762709ffc4", "completion": "def count_lucky_numbers(n_str):\n    n = int(n_str)\n    count = 0\n    \n    for x in range(10):\n        for y in range(10):\n            if x == y:\n                continue\n            num = int(str(x) + str(y))\n            while num <= n:\n                count += 1\n                if x == 0:\n                    num = num * 10 + y\n                else:\n                    num = num * 10 + x\n            \n    return str(count)"}
{"task_id": "230a3c4d7090401e5fa3c6b9d994cdf2", "completion": "def divide_watermelon(w):\n    w = int(w)\n    for i in range(2, w, 2):\n        if (w - i) % 2 == 0:\n            return 'YES'\n    return 'NO'"}
{"task_id": "6d67559744583229455c5eafe68f7952", "completion": "def count_polylines(input_str):\n    n, t = map(int, input_str.split())\n\n    def is_valid(y_vals):\n        return all(y_vals[j - 1] < y_vals[j] > y_vals[j + 1] if j % 2 == 1 else y_vals[j - 1] > y_vals[j] < y_vals[j + 1] for j in range(1, len(y_vals) - 1))\n\n    unique_polylines = set()\n\n    for i in range(1, 5):\n        if t == 1:\n            if 1 <= n <= 4:\n                unique_polylines.add((i,))\n        else:\n            for j in range(1, 5):\n                for k in range(1, 5):\n                    for l in range(1, 5):\n                        y_vals = [0, i, j, k, l, 0]\n                        if is_valid(y_vals):\n                            unique_polylines.add(tuple(y_vals))\n\n    return str(len(unique_polylines))"}
{"task_id": "e4a4affb439365c843c9f9828d81b42c", "completion": "def min_time_to_reach_B(input_str):\n    v, d, g, r, B = map(float, input_str.split())\n    \n    cycle = g + r\n    time_to_reach_traffic_lights = d / v\n    \n    num_cycles_to_reach_traffic_lights = time_to_reach_traffic_lights // cycle\n    remaining_time_to_reach_traffic_lights = time_to_reach_traffic_lights % cycle\n    \n    if remaining_time_to_reach_traffic_lights <= g:\n        total_time_to_traffic_lights = time_to_reach_traffic_lights\n    else:\n        total_time_to_traffic_lights = cycle - remaining_time_to_reach_traffic_lights + time_to_reach_traffic_lights\n    \n    total_time = total_time_to_traffic_lights + (B - d) / v\n    \n    return '{:.8f}'.format(total_time)"}
{"task_id": "37feadce373f728ba2a560b198ca4bc9", "completion": "def count_beautiful_numbers(input_str):\n    def is_beautiful_number(num):\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n\n    input_vals = input_str.split('\\n')[1].split()\n    lower_range = int(input_vals[0])\n    upper_range = int(input_vals[1])\n    \n    beautiful_count = 0\n    for number in range(lower_range, upper_range + 1):\n        if is_beautiful_number(number):\n            beautiful_count += 1\n\n    return str(beautiful_count)\n\n# Test cases\ntest_cases = [{'input': '1\\n1 9', 'output': '9'}, {'input': '1\\n12 15', 'output': '2'}]\n\nfor test_case in test_cases:\n    input_str = test_case['input']\n    expected_output = test_case['output']\n    \n    output = count_beautiful_numbers(input_str)\n    print(output == expected_output)"}
{"task_id": "c5d19dc8f2478ee8d9cba8cc2e4cd838", "completion": "def say_hello(s):\n    hello = \"hello\"\n    i = 0\n    for letter in s:\n        if letter == hello[i]:\n            i += 1\n            if i == 5:\n                return \"YES\"\n    return \"NO\"\n\n"}
{"task_id": "a11c9679d8e2dca51be17d466202df6e", "completion": "def transform_email_address(s):\n    email = s.replace(\"dot\", \".\").replace(\"at\", \"@\")\n    \n    if email.startswith('@') or email.endswith('@') or email.startswith('.') or email.endswith('.'):\n        return \"Invalid email format\"\n\n    if email.count('@') != 1:\n        return \"Invalid email format\"\n\n    result_without_dots = email.replace(\".\", \"\").replace(\"@\", \"\").replace(\".\", \"\")\n    result_with_dots = email.replace(\"@\", \"@\").replace(\".\", \".\")\n    \n    return min(result_without_dots, result_with_dots)"}
{"task_id": "1a335a9638523ca0315282a67e18eec7", "completion": "def count_empty_cells(n_str):\n    n = int(n_str)\n    empty_cells = 0\n    for i in range(2, n+1, 2):\n        empty_cells += (2*n - i + 1) ** 2 - i ** 2\n    return str(empty_cells)"}
{"task_id": "2c4b2a162563242cb2f43f6209b59d5e", "completion": "def find_max_weight(input_str):\n    l, r = map(int, input_str.split())\n\n    def calculate_reflection(n):\n        return int(str(n)[::-1].translate(str.maketrans('0123456789', '9876543210')))\n\n    max_weight = 0\n\n    for n in range(l, r + 1):\n        reflection = calculate_reflection(n)\n        weight = n * reflection\n        max_weight = max(max_weight, weight)\n\n    return str(max_weight)"}
