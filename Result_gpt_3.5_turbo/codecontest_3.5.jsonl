{"task_id": 0, "completion": "def custom_sort_books(input_string: str) -> str:\n    n, m, *book_titles = input_string.split()\n    n = int(n)\n    m = int(m)\n    \n    def custom_compare(a):\n        odd_chars = ''.join(sorted(a[::2]))\n        even_chars = ''.join(sorted(a[1::2], reverse=True))\n        return odd_chars + even_chars\n\n    sorted_indices = sorted(range(1, n + 1), key=lambda x: custom_compare(book_titles[x-1]))\n\n    return ' '.join(map(str, sorted_indices))"}
{"task_id": 1, "completion": "def min_radius(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, k = map(int, input_lines[0].split())\n    habitats = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    def count_habitats(radius):\n        return sum(1 for x, y in habitats if math.sqrt(x**2 + y**2) <= radius)\n\n    def binary_search():\n        low, high = 0, 2 * 10**5\n        while low + 1e-9 < high:\n            mid = (low + high) / 2\n            if count_habitats(mid) < k:\n                low = mid\n            else:\n                high = mid\n        return low\n\n    radius = binary_search()\n    return '{:.9f}'.format(radius)"}
{"task_id": 2, "completion": "def count_valid_segments(input_str: str) -> str:\n    M = 10**9 + 7\n    n, m, k, *a = map(int, input_str.split())\n    \n    if k == 1:\n        result = (m * (m + 1) // 2 * n) % M\n        return str(result) + '\\n'\n    \n    a *= m\n    \n    prefix_sum = [0]\n    curr_sum = 0\n    for num in a:\n        curr_sum = (curr_sum + num) % k\n        prefix_sum.append(curr_sum)\n    \n    freq_remainder = [0] * k\n    for num in prefix_sum:\n        freq_remainder[num] += 1\n    \n    result = 0\n    for freq in freq_remainder:\n        result = (result + freq * (freq - 1) // 2) % M\n\n    return str(result) + '\\n'"}
{"task_id": 3, "completion": "def count_divisible_by_25(s):\n    s = s.lstrip('0')\n    count = 0\n    \n    if s.endswith(\"00\") or s.endswith(\"25\") or s.endswith(\"50\") or s.endswith(\"75\"):\n        count += 1\n    \n    for i in range(10):\n        for j in range(10):\n            updated_s = s.replace('_', str(i)).replace('X', str(j))\n            if updated_s.count('X') <= 1 and updated_s.count('_') <= 1 and updated_s.lstrip('0') != '':\n                if int(updated_s) % 25 == 0:\n                    count += 1\n\n    return count\n"}
{"task_id": 4, "completion": "def total_happiness(input_str):\n    MOD = 10**9 + 7\n    input_lines = input_str.strip().split('\\n')\n    n, k = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n    edges = [list(map(int, line.split())) for line in input_lines[2:]]\n\n    adj_list = [[] for _ in range(n)]\n    for u, v, t in edges:\n        adj_list[u-1].append((v-1, t))\n        adj_list[v-1].append((u-1, t))\n\n    def dfs(node, parent, colors, happiness, dp):\n        dp[node][0] = happiness[node]\n        for nei, color in adj_list[node]:\n            if nei == parent:\n                continue\n            dfs(nei, node, colors, happiness, dp)\n            for i in range(1, k+2):\n                dp[node][i] = (dp[node][i] + dp[nei][i-1]) % MOD\n                if i < k+1:\n                    dp[node][i] = (dp[node][i] + dp[nei][i]) % MOD\n            dp[node][1] = (dp[node][1] + happiness[node]) % MOD\n            if colors[node] == colors[nei]:\n                for i in range(1, k+1):\n                    dp[node][i+1] = (dp[node][i+1] + dp[nei][i]) % MOD\n\n    total_happiness = 0\n    for i in range(n):\n        dp = [[0] * (k + 2) for _ in range(n)]\n        dfs(i, -1, [t for (_, t) in edges], a, dp)\n        for j in range(n):\n            total_happiness = (total_happiness + sum(dp[j])) % MOD\n\n    return str(total_happiness)"}
{"task_id": 5, "completion": "def calculate_expected_value_of_f(input_string: str) -> int:\n    MOD = 10**9 + 7\n    \n    def expected_operations_count(b):\n        n = len(b)\n        freq = {}\n        for num in b:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        \n        total_operations = 0\n        for num in freq:\n            total_operations += n * (n - 1) // 2 - freq[num] * (freq[num] - 1) // 2\n        \n        return total_operations\n    \n    lines = input_string.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    \n    c = a.count(-1)\n    possibilities = pow(k, c, MOD)\n    \n    total_expected = 0\n    \n    for i in range(n):\n        if a[i] == -1:\n            for j in range(k):\n                b = a.copy()\n                b[i] = j\n                total_expected += expected_operations_count(b)\n    \n    return (total_expected * possibilities) % MOD\n\n# Example usage:\n# input_string = \"3 3\\n-1 -1 -1\\n\"\n# output = calculate_expected_value_of_f(input_string)\n# print(output)"}
{"task_id": 6, "completion": "def calculate_prettiness_value(input_str):\n    MOD = 10**9 + 7\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    lines = input_str.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n\n    result = 0\n\n    for i in range(n):\n        for j in range(n):\n            result = (result + (gcd(a[i], a[j]) * gcd(i + 1, j + 1)) % MOD) % MOD\n\n    return str(result)"}
{"task_id": 7, "completion": "def calculate_changes(s: str) -> str:\n    n, m = map(int, s.split()[:2])\n    a = s.split()[2]\n    b = s.split()[3]\n\n    def get_changes(a, b):\n        return sum(1 for i in range(len(b)) if a[i] != b[i])\n\n    results = []\n    for k in range(n - m + 2):\n        total_changes = 0\n        for i in range(k):\n            total_changes += get_changes(a[i:i+m], b)\n\n        for i in range(k, n - m + 1):\n            total_changes += get_changes(a[i:i+m], b)\n            if total_changes < i * m:\n                results.append(total_changes)\n                break\n        else:\n            results.append(-1)\n\n    return ' '.join(map(str, results))"}
{"task_id": 8, "completion": "import heapq\n\ndef secret_treasure(input_data):\n    def dijkstra(graph, start):\n        distances = {node: float('inf') for node in graph}\n        distances[start] = 0\n        priority_queue = [(0, start)]\n\n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_node]:\n                continue\n\n            for neighbor, weight in graph[current_node]:\n                distance = max(abs(illusion_rates[current_node - 1] + illusion_rates[neighbor - 1]),\n                               abs(illusion_rates[current_node - 1] - illusion_rates[neighbor - 1]))\n                if distance + current_distance < distances[neighbor]:\n                    distances[neighbor] = distance + current_distance\n                    heapq.heappush(priority_queue, (distance + current_distance, neighbor))\n\n        return distances\n\n    input_lines = input_data.strip().split(\"\\n\")\n    n, q = map(int, input_lines[0].split())\n    illusion_rates = list(map(int, input_lines[1].split()))\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for i in range(2, 2 + n - 1):\n        s, t = map(int, input_lines[i].split())\n        graph[s].append((t, 0))\n        graph[t].append((s, 0))\n\n    results = []\n    for i in range(2 + n - 1, 2 + n - 1 + q):\n        query = list(map(int, input_lines[i].split()))\n        if query[0] == 1:\n            u, c = query[1], query[2]\n            illusion_rates[u - 1] = c\n        else:\n            u, v = query[1], query[2]\n            distances = dijkstra(graph, u)\n            results.append(str(distances[v]))\n\n    return \"\\n\".join(results)\n\n"}
{"task_id": 9, "completion": "def dropping_balls(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m, k = map(int, input_lines[0].split())\n    grid = [list(map(int, line.split())) for line in input_lines[1:n + 1]]\n    columns = list(map(int, input_lines[-1].split()))\n\n    directions = [(0, 1), (1, 0), (0, -1)]  # right, down, left\n    results = []\n\n    for col in columns:\n        x, y = 0, col - 1  # Starting position\n        while True:\n            if x == n:  # If the ball reaches the bottom\n                results.append(y + 1)\n                break\n            direction = grid[x][y]  # Current direction from grid\n            grid[x][y] = 2  # Mark the cell to avoid infinite loops\n            dx, dy = directions[direction - 1]  # Get the direction\n            x, y = x + dx, y + dy  # Move to the next cell\n\n    return ' '.join(map(str, results))"}
{"task_id": 10, "completion": ""}
{"task_id": 11, "completion": "def maximize_f(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n\n    indices_to_remove = set()\n    for i in range(n):\n        if a[i] != i + 1:\n            indices_to_remove.add(a[i])\n\n    return n - len(indices_to_remove)"}
{"task_id": 12, "completion": "def housing_complex_value(data):\n    # Split the input string into parts\n    parts = data.splitlines()\n\n    # Extract n, m from the first line\n    n, m = map(int, parts[0].split())\n\n    # Extract the grid from the remaining lines\n    grid = parts[1:]\n\n    distances = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if grid[i][j] == '1':\n                for x in range(n + 1):\n                    for y in range(m + 1):\n                        distances[x][y] = min(distances[x][y], (x - i) ** 2 + (y - j) ** 2)\n\n    return str(sum(sum(row) for row in distances)) + \"\\n\""}
{"task_id": 13, "completion": "def can_be_erased(input_str):\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])\n\n    return '\\n'.join(\n        \"YES\" if s.count('B') == s.count('A') + s.count('C') else \"NO\"\n        for s in lines[1:t + 1]\n    ) + \"\\n\""}
{"task_id": 14, "completion": "def find_shift_position(i, vals, sorted_vals):\n    \"\"\"Find the position `j` where vals[j] matches the sorted value at index `i`.\"\"\"\n    for j in range(i + 1, len(vals)):\n        if vals[j] == sorted_vals[i]:\n            return j\n    return -1\n\ndef apply_shift(i, j, vals):\n    \"\"\"Apply the cyclic shift between indices i and j on the array.\"\"\"\n    d = j - i\n    return vals[:i] + vals[i + d:j + 1] + vals[i:i + d] + vals[j + 1:], (i + 1, j + 1, d)\n\ndef process_test_case(n, vals):\n    \"\"\"Process a single test case and return the required shifts.\"\"\"\n    sorted_vals = sorted(vals)\n    shifts = []\n\n    for i in range(n):\n        if vals[i] != sorted_vals[i]:\n            j = find_shift_position(i, vals, sorted_vals)\n            if j != -1:\n                vals, shift = apply_shift(i, j, vals)\n                shifts.append(shift)\n\n    return shifts\n\ndef sort_array(input_str):\n    data = input_str.strip().split(\"\\n\")\n    t = int(data[0])\n    results = []\n\n    for ti in range(t):\n        n = int(data[2 * ti + 1])\n        vals = list(map(int, data[2 * ti + 2].split()))\n        shifts = process_test_case(n, vals)\n\n        results.append(f\"{len(shifts)}\\n\" + \"\\n\".join(f\"{x[0]} {x[1]} {x[2]}\" for x in shifts))\n\n    return \"\\n\".join(results) + \"\\n\""}
{"task_id": 15, "completion": "def can_be_obtained(t: int, test_cases: list) -> list:\n    def check_tick(field, i, j, d):\n        if i - d < 0 or i + d >= n or j - d < 0 or j + d >= m:\n            return False\n        for h in range(d + 1):\n            if field[i-h][j-h] != '*' or field[i-h][j+h] != '*':\n                return False\n        return True\n\n    results = []\n    for case in test_cases:\n        n, m, k = case[0]\n        field = case[1]\n        valid = True\n\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == '*':\n                    found_tick = False\n                    for d in range(k, max(n, m)+1):\n                        if check_tick(field, i, j, d):\n                            found_tick = True\n                            break\n                    if not found_tick:\n                        valid = False\n                        break\n\n            if not valid:\n                break\n\n        results.append(\"YES\" if valid else \"NO\")\n\n    return results\n\ntest_cases = [\n    [(2, 3, 1), ['*.*', '...']],\n    [(4, 9, 2), ['*.*.*...*', '.*.*...*.', '..*.*.*..', '.....*...']],\n    [(4, 4, 1), ['*.*.', '****', '.**.', '....']],\n    [(5, 5, 1), ['.....', '*...*', '.*.*.', '..*.*', '...*.']],\n    [(5, 5, 2), ['.....', '*...*', '.*.*.', '..*.*', '...*.']],\n    [(4, 7, 1), ['*.....*', '.....*.', '..*.*..', '...*...']],\n    [(3, 3, 1), ['***', '***', '***']],\n    [(3, 5, 1), ['*...*', '.***.', '.**..']]\n]\n\nresults = can_be_obtained(8, test_cases)\nprint(results)"}
{"task_id": 16, "completion": "def maximum_meeting_talks(test_cases: str) -> str:\n    data = test_cases.strip().split('\\n')\n    t = int(data[0])\n    idx = 1\n    result = []\n\n    for _ in range(t):\n        n = int(data[idx])\n        sociabilities = list(map(int, data[idx + 1].split()))\n        \n        talks = []\n        for x in range(n):\n            for y in range(x + 1, n):\n                if sociabilities[x] > 0 and sociabilities[y] > 0:\n                    talks.append((x + 1, y + 1))\n                    sociabilities[x] -= 1\n                    sociabilities[y] -= 1\n        \n        result.append(str(len(talks)))\n        for pair in talks:\n            result.append(f\"{pair[0]} {pair[1]}\")\n        \n        idx += 2\n\n    return '\\n'.join(result)"}
{"task_id": 17, "completion": "def minimal_inversions(input_str):\n    def count_inversions(arr):\n        n = len(arr)\n        inversions = 0\n        s_beginning = deque()\n        s_ending = deque()\n        \n        for i in range(n):\n            if i % 2 == 0:\n                if s_beginning and arr[i] < s_beginning[0]:\n                    inversions += 1\n                    s_beginning.appendleft(arr[i])\n                else:\n                    s_beginning.append(arr[i])\n            else:\n                if s_ending and arr[i] < s_ending[0]:\n                    inversions += 1\n                    s_ending.appendleft(arr[i])\n                else:\n                    s_ending.append(arr[i])\n        \n        return inversions\n\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])\n    results = []\n\n    for i in range(1, 2 * t + 1, 2):\n        n = int(lines[i])\n        arr = list(map(int, lines[i + 1].split()))\n\n        inversions_forward = count_inversions(arr)\n        arr_reversed = arr[::-1]\n        inversions_backward = count_inversions(arr_reversed)\n\n        results.append(str(min(inversions_forward, inversions_backward)))\n\n    return '\\n'.join(results)"}
{"task_id": 18, "completion": "def process_test_cases(input_str):\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])\n    index = 1\n    result = []\n\n    for _ in range(t):\n        n, d = map(int, lines[index].split())\n        a = list(map(int, lines[index + 1].split()))\n\n        steps = 0\n        visited = set()\n        visited.add(tuple(a))\n\n        while True:\n            if all(val == 0 for val in a):\n                result.append(steps)\n                break\n\n            new_arr = [(a[(i + n - d) % n] & a[i]) for i in range(n)]\n            steps += 1\n\n            if tuple(new_arr) in visited:\n                result.append(-1)\n                break\n\n            visited.add(tuple(new_arr))\n            a = new_arr\n\n        index += 2\n\n    return \"\\n\".join(map(str, result))\n\n# Example input string\ninput_str = \"\"\"5\\n2 1\\n0 1\\n3 2\\n0 1 0\\n5 2\\n1 1 0 1 0\\n4 2\\n0 1 0 1\\n1 1\\n0\"\"\"\noutput_str = process_test_cases(input_str)\nprint(output_str)"}
{"task_id": 19, "completion": "def minimal_coverage_length(input_string: str) -> str:\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    data = lines[1:]\n    \n    results = []\n\n    for i in range(0, len(data), 2):\n        n = int(data[i])\n        lengths = list(map(int, data[i + 1].split()))\n\n        current_end = 0\n        min_coverage = 0\n        max_coverage = 0\n\n        for length in lengths:\n            pos1 = current_end - length\n            pos2 = current_end + length\n\n            if pos1 <= min_coverage or pos2 >= max_coverage:\n                min_coverage = min(pos1, pos2)\n                max_coverage = max(pos1, pos2)\n                current_end = min_coverage if pos1 <= min_coverage else max_coverage\n\n        results.append(max_coverage - min_coverage)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 20, "completion": "def min_operations_to_portal(grid_data):\n    lines = grid_data.splitlines()\n    t = int(lines[0])\n    results = []\n\n    index = 1\n    for _ in range(t):\n        n, m = map(int, lines[index].split())\n        grid = [list(lines[index + i + 1]) for i in range(n)]\n        index += n + 1\n\n        min_operations = float('inf')\n\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n\n                        top_bottom = [(i, k) for k in range(j + 1, j + b - 1)] + [(i + a - 1, k) for k in range(j + 1, j + b - 1)]\n                        left_right = [(k, j) for k in range(i + 1, i + a - 1)] + [(k, j + b - 1) for k in range(i + 1, i + a - 1)]\n                        interior = [(k, l) for k in range(i + 1, i + a - 1) for l in range(j + 1, j + b - 1)]\n\n                        for r, c in top_bottom + left_right:\n                            if grid[r][c] == '0':\n                                operations += 1\n                        for r, c in interior:\n                            if grid[r][c] == '1':\n                                operations += 1\n\n                        min_operations = min(min_operations, operations)\n\n        results.append(str(min_operations))\n\n    return \"\\n\".join(results) + \"\\n\""}
{"task_id": 21, "completion": "def count_permutations(input_string):\n    n, m, k, p = map(int, input_string.split())\n    \n    dp = [[[0 for _ in range(k+1)] for _ in range(m+1)] for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        dp[i][1][1] = 1\n        \n    for i in range(2, n+1):\n        for j in range(2, min(m+1, i+1)):\n            for x in range(1, k+1):\n                dp[i][j][x] = sum(dp[l][j-1][x-1] for l in range(1, i)) % p\n    \n    total = sum(dp[i][m][k] for i in range(1, n+1)) % p\n    return str(total)"}
{"task_id": 22, "completion": "def calculate_trains_in_maintenance(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    trains_info = {}\n    maintenance_count = 0\n    result = []\n\n    for i in range(1, n + 1):\n        x, y = map(int, input_lines[i].split())\n        trains_info[i] = {'x': x, 'y': y, 'current_day': 0}\n\n    for i in range(n + 1, n + m + 1):\n        op, k = map(int, input_lines[i].split())\n\n        if op == 1:\n            train = trains_info[k]\n            if train['current_day'] <= train['x']:\n                maintenance_count += 1\n            result.append(maintenance_count)\n            trains_info[k]['current_day'] += 1\n            if trains_info[k]['current_day'] > trains_info[k]['x'] + trains_info[k]['y']:\n                trains_info[k]['current_day'] = 0\n                maintenance_count -= 1\n        else:\n            result.append(maintenance_count)\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 23, "completion": "def maximize_value(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    a = list(map(int, input_lines[1].split()))\n\n    def f(i, j):\n        return min(a[i:j+1])\n\n    max_value = 0\n\n    for i in range(n - m + 1):\n        subseq = a[i:i + m]\n        cur_value = m * sum(subseq) - sum(f(min(subseq[i], subseq[j]), max(subseq[i], subseq[j])) for i in range(m) for j in range(i, m))\n        max_value = max(max_value, cur_value)\n\n    return str(max_value)"}
{"task_id": 24, "completion": "from collections import defaultdict\n\nimport heapq\n\ndef minimal_cost_railway(input_str):\n    lines = input_str.strip().split('\\n')\n    n, m, q = map(int, lines[0].split())\n    ws = list(map(int, lines[1].split()))\n\n    railways = [tuple(map(int, line.split())) for line in lines[2:2+m]]\n    incidents = [tuple(map(int, line.split())) for line in lines[2+m:]]\n\n    adj_list = defaultdict(list)\n    for u, v, d in railways:\n        adj_list[u].append((v, d))\n        adj_list[v].append((u, d))\n\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n\n    def dijkstra():\n        nonlocal pq\n        nonlocal dist\n        while pq:\n            cost, u = heapq.heappop(pq)\n            if cost > dist[u]:\n                continue\n            for v, d in adj_list[u]:\n                if dist[u] + d < dist[v]:\n                    dist[v] = dist[u] + d\n                    heapq.heappush(pq, (dist[v], v))\n\n    dijkstra()\n\n    total_cost = sum(ws[1:])\n\n    results = [total_cost]\n    for k, x in incidents:\n        total_cost += x\n        min_cost = total_cost\n\n        for v, d in adj_list[k]:\n            if dist[v] == dist[k] + d:\n                min_cost = min(min_cost, total_cost - ws[v - 1])\n\n        results.append(min_cost)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 25, "completion": "def count_valid_plans(input_str):\n    n, m = map(int, input_str.split())\n    MOD = 998244353\n    dp = [[0] * m for _ in range(n + 1)]\n    \n    dp[1][0] = 1\n    dp[1][1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, m):\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD\n\n    total_plans = 0\n    for j in range(m):\n        total_plans = (total_plans + dp[n][j]) % MOD\n\n    return total_plans"}
{"task_id": 26, "completion": "def count_permutations(t: str) -> str:\n    mod = 1000000007\n\n    def count_valid_permutations(n):\n        dp = [1] * (2*n+1)\n        for i in range(2, 2*n+1):\n            dp[i] = (dp[i-1] * i) % mod\n\n        def power(a, b):\n            result = 1\n            while b > 0:\n                if b % 2 == 1:\n                    result = (result * a) % mod\n                a = (a * a) % mod\n                b //= 2\n            return result\n\n        def inverse(a):\n            return power(a, mod-2) % mod\n\n        numerator = dp[2*n]\n        denominator = (dp[n] * dp[n]) % mod\n        denominator_inv = inverse(denominator)\n        return (numerator * denominator_inv) % mod\n\n    input_lines = t.strip().split('\\n')\n    t = int(input_lines[0])\n    results = []\n    for i in range(1, t+1):\n        n = int(input_lines[i])\n        result = count_valid_permutations(n)\n        results.append(str(result))\n\n    return '\\n'.join(results)"}
{"task_id": 27, "completion": "def can_create_graph(test_input: str) -> str:\n    output = []\n    lines = test_input.strip().split('\\n')\n    t = int(lines[0])\n\n    for i in range(1, 2*t+1, 3):\n        n, m, k = map(int, lines[i].split())\n        \n        if (n == 1 and m == 0) or m < n - 1 or m > n * (n - 1) / 2:\n            output.append(\"NO\")\n        else:\n            max_diameter = 0\n            if n > 1:\n                max_diameter = 2 if m == n - 1 else 1\n\n            if max_diameter < k - 1:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n                \n    return '\\n'.join(output)"}
{"task_id": 28, "completion": "def find_minimal_difference(input_string):\n    output = []\n    input_data = input_string.strip().split('\\n')[1:]\n    \n    for line in input_data:\n        a, b, c = map(int, line.split())\n        total_duration = a + 2 * b + 3 * c\n        target_duration = total_duration // 2\n        \n        possible_diffs = {\n            abs(total_duration - 2 * target_duration),\n            abs(total_duration - (a + target_duration)),\n            abs(total_duration - (a + 2 * b + target_duration) - (a + 2 * b))\n        }\n        \n        output.append(min(possible_diffs))\n    \n    return '\\n'.join(map(str, output))"}
{"task_id": 29, "completion": "def nearly_full_subsequence_count(input_string):\n    def count_nearly_full_subseq(arr, s):\n        dp = [1] + [0] * (s + 1)\n        for num in arr:\n            for i in range(s, num - 1, -1):\n                dp[i] += dp[i - num]\n        return dp[s]\n\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    results = []\n\n    index = 1\n    for _ in range(t):\n        n = int(lines[index])\n        arr = list(map(int, lines[index + 1].split()))\n        s = sum(arr)\n        nearly_full_count = count_nearly_full_subseq(arr, s - 1)\n        results.append(str(nearly_full_count))\n\n        index += 2\n\n    return '\\n'.join(results)"}
{"task_id": 30, "completion": "def find_min_erased_symbols(s: str) -> int:\n    counts = {}\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n\n    odd_count_chars = sum(1 for count in counts.values() if count % 2 != 0)\n\n    if len(s) % 2 == 0 and odd_count_chars > 0:\n        return -1\n    elif len(s) % 2 != 0 and odd_count_chars > 1:\n        return -1\n\n    return (len(s) - 1) if len(s) % 2 != 0 else len(s)\n\ndef solve_test_cases(test_cases: str) -> str:\n    test_cases = test_cases.strip().split('\\n')\n    result = []\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        s = test_cases[i + 1]\n        result.append(str(find_min_erased_symbols(s)))\n    return '\\n'.join(result)"}
{"task_id": 31, "completion": "def find_array_b(input_string):\n    def process_test_case(arr):\n        sum_a = sum(arr)\n        b = [-sum_a] + [-arr[0]]\n        prefix = -arr[0]\n        for i in range(1, len(arr)-1):\n            b.append(-prefix)\n            prefix -= arr[i]\n        return b\n\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n\n    output = []\n    i = 0\n    for _ in range(t):\n        n = int(input_lines[i])\n        arr = list(map(int, input_lines[i+1].split()))\n        b = process_test_case(arr)\n        output.append(b)\n        i += 2\n\n    return '\\n'.join([' '.join(map(str, b)) for b in output])"}
{"task_id": 32, "completion": "def find_max_k(test_cases_str):\n    test_cases = test_cases_str.strip().split('\\n')\n    t = int(test_cases[0])\n    \n    results = []\n    current_index = 1\n    for _ in range(t):\n        n = int(test_cases[current_index])\n        elements = list(map(int, test_cases[current_index + 1].split()))\n\n        max_k = 1\n        prefix_sum = elements[0]\n        current_sum = elements[0]\n\n        for i in range(1, n):\n            if elements[i] > elements[i - 1]:\n                current_sum += elements[i]\n            else:\n                current_sum = elements[i]\n            \n            prefix_sum += elements[i]\n\n            if current_sum <= prefix_sum:\n                max_k = i + 1\n        \n        results.append(max_k)\n        current_index += 2\n    \n    return '\\n'.join(map(str, results))"}
{"task_id": 33, "completion": "def find_possible_xor_values(input_string):\n    data = list(map(int, input_string.split('\\n')[1].split()))\n    xor_set = set()\n    for num in data:\n        new_values = set()\n        new_values.add(num)\n        for val in xor_set:\n            new_values.add(val ^ num)\n        xor_set.update(new_values)\n\n    result = sorted(list(xor_set))\n\n    return str(len(result)) + '\\n' + ' '.join(map(str, result))"}
{"task_id": 34, "completion": "def find_unique_xor_values(input_str):\n    n, *arr = map(int, input_str.split())\n    \n    max_val = max(arr) if arr else 0\n    found = [False] * (max_val + 1)\n    \n    for num in arr:\n        found[num] = True\n        for i in range(num + 1):\n            if found[i]:\n                found[num ^ i] = True\n    \n    result = [i for i in range(max_val + 1) if found[i]]\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\""}
{"task_id": 35, "completion": "def count_simple_segments(input_str):\n    n = int(input_str.splitlines()[0])\n    a = list(map(int, input_str.splitlines()[1].split()))\n    b = list(input_str.splitlines()[2])\n\n    count = 0\n\n    for l in range(n):\n        x = 1\n        for r in range(l, n):\n            for i in range(l, r + 1):\n                if b[i] == '*':\n                    x *= a[i]\n                else:\n                    x /= a[i]\n                if x % 1 != 0:  # Check if x is an integer\n                    break\n            else:\n                count += 1\n\n    return str(count)"}
{"task_id": 36, "completion": "def find_largest_composite_subset(input_string: str) -> str:\n    def is_composite(num: int) -> bool:\n        if num < 4:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return True\n        return False\n\n    test_cases = input_string.split('\\n')\n    t = int(test_cases[0])\n\n    results = []\n    i = 1\n    while i < len(test_cases) - 1:\n        n = int(test_cases[i])\n        elements = list(map(int, test_cases[i + 1].split()))\n\n        max_subset = []\n        max_subset_size = 0\n\n        for j in range(1, 1 << n):\n            subset = [elements[k] for k in range(n) if (j & (1 << k))]\n            if is_composite(sum(subset)) and len(subset) > max_subset_size:\n                max_subset_size = len(subset)\n                max_subset = [elements.index(e) + 1 for e in subset]\n\n        results.append(max_subset_size)\n        results.append(\" \".join(map(str, max_subset)))\n\n        i += 2\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 37, "completion": "def heavenly_trees(test_cases):\n    def construct_tree(n, restrictions):\n        adj_list = [[] for _ in range(n)]\n        \n        for a, b, c in restrictions:\n            adj_list[a-1].append(b)\n            adj_list[b-1].append(a)\n            \n            adj_list[c-1].append(b)\n            adj_list[b-1].append(c)\n        \n        return adj_list\n    \n    def dfs(node, parent, adj_list, visited, result):\n        visited[node] = True\n        \n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                result.append((node+1, neighbor+1))\n                dfs(neighbor, node, adj_list, visited, result)\n    \n    results = []\n    \n    for n, m, restrictions in test_cases:\n        adj_list = construct_tree(n, restrictions)\n        \n        visited = [False] * n\n        result = []\n        dfs(0, -1, adj_list, visited, result)\n        \n        results.append(result)\n    \n    return results\n\ntest_cases = [\n    (7, 4, [(1, 2, 3), (3, 4, 5), (5, 6, 7), (6, 5, 4)]),\n    (5, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)])\n]\nresult = heavenly_trees(test_cases)\nfor res in result:\n    for edge in res:\n        print(edge[0], edge[1])"}
{"task_id": 38, "completion": "def determinable_subgrid(input_str):\n    input_list = input_str.strip().split('\\n')\n    n, m = map(int, input_list[0].split())\n    grid = [list(row) for row in input_list[1:n+1]]\n    queries = [list(map(int, x.split())) for x in input_list[n+2:]]\n    \n    result = []\n    for query in queries:\n        x1, x2 = query\n        subgrid = [row[x1-1:x2] for row in grid]\n        exitable = [[cell == '.' and any(i == 0 or j == 0 or exitable[i-1][j] == 'E' or exitable[i][j-1] == 'E' for i in range(len(subgrid)) for j in range(len(subgrid[i])))] for row in subgrid]\n        determinable = all(all(cell for cell in row) for row in exitable)\n        result.append(\"YES\" if determinable else \"NO\")\n    \n    return '\\n'.join(result)"}
{"task_id": 39, "completion": "def determine_permutation(input_str):\n    input_lines = input_str.strip().split(\"\\n\")\n    n = int(input_lines[0])\n    \n    def make_query(a):\n        print(\"? \" + \" \".join(map(str, a)))\n        sys.stdout.flush()\n        s = int(input())\n        return s\n\n    p = [0] * n\n    idx = 1\n    \n    for i in range(n):\n        a = [idx] * n\n        a[i] = idx + 1\n        s = make_query(a)\n        \n        if s == 0:\n            continue\n        \n        p[i] = s - a[i]\n    \n    return \"! \" + \" \".join(map(str, p))"}
{"task_id": 40, "completion": "from collections import deque\n\ndef process_queries(n, m, edges, q, queries):\n    adj_list = [[] for _ in range(n+1)]\n    for x, y in edges:\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n\n    paths = []\n    for a, b in queries:\n        visited = [False] * (n+1)\n        path = [-1] * (n+1)\n        visited[a] = True\n        q = deque([a])\n        while q:\n            curr = q.popleft()\n            if curr == b:\n                break\n            for neighbor in adj_list[curr]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    q.append(neighbor)\n                    path[neighbor] = curr\n        \n        if path[b] == -1:\n            paths.append([])\n        else:\n            curr = b\n            curr_path = [b]\n            while curr != a:\n                curr = path[curr]\n                curr_path.append(curr)\n            paths.append(curr_path[::-1])\n\n    odd_edges = set()\n    for p in paths:\n        for i in range(1, len(p)):\n            edge = (min(p[i-1], p[i]), max(p[i-1], p[i]))\n            odd_edges.add(edge)\n\n    if all((u, v) in odd_edges or (v, u) in odd_edges for u, v in edges):\n        print(\"YES\")\n        for p in paths:\n            print(len(p))\n            print(*p)\n    else:\n        min_additional_queries = len(set(edges) - odd_edges)\n        print(\"NO\")\n        print(min_additional_queries)\n\n"}
{"task_id": 41, "completion": "def edge_coloring(input_str: str) -> str:\n    n, k = map(int, input_str.split())\n\n    # Determine the minimum number of colors needed\n    c = k\n\n    # Generate valid edge coloring\n    colors = []\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            colors.append(str((i+j) % c + 1))\n\n    return f\"{c}\\n{' '.join(colors)}\""}
{"task_id": 42, "completion": "def time_travels(input_string):\n    MOD = 10**9 + 7\n\n    input_lines = input_string.strip().split('\\n')\n    n = int(input_lines[0])\n    tasks = [tuple(map(int, line.split())) for line in input_lines[1:n+1]]\n    t = int(input_lines[n+1])\n    set_s = set(map(int, input_lines[n+2].split()))\n\n    completion_times = [0] * (n + 1)\n    num_time_travels = 0\n    tasks_completed = set()\n\n    def check_set_s_completed():\n        return all(task in tasks_completed for task in set_s)\n    \n    for a, b in tasks:\n        if a in set_s:\n            tasks_completed.add(a)\n\n        if check_set_s_completed():\n            num_time_travels += 1\n        \n        if a < b and completion_times[a] == 0:\n            completion_times[a] = b\n        elif a < b:\n            num_time_travels += b - completion_times[a]\n            completion_times[a] = b\n            for i in range(a+1, n+1):\n                if completion_times[i] > a:\n                    completion_times[i] = 0\n\n    return str(num_time_travels % MOD)"}
{"task_id": 43, "completion": "def maximize_enjoyment(input_data):\n    def bfs(city, capacity):\n        max_enjoyment = 0\n        min_toll = float('inf')\n\n        queue = deque([(city, capacity, 0, 0)])  \n        visited = set()\n\n        while queue:\n            current_city, remaining_capacity, current_max_enjoyment, current_min_toll = queue.popleft()\n\n            max_enjoyment = max(max_enjoyment, current_max_enjoyment)\n            min_toll = min(min_toll, current_min_toll)\n\n            visited.add(current_city)\n\n            for neighbor, edge in graph[current_city].items():\n                if neighbor not in visited:\n                    next_capacity = min(remaining_capacity, edge['capacity'])\n                    next_max_enjoyment = max(current_max_enjoyment, enjoyment_values[neighbor])\n                    next_min_toll = max(current_min_toll, edge['toll'])\n\n                    queue.append((neighbor, next_capacity, next_max_enjoyment, next_min_toll))\n\n        return max_enjoyment, min_toll\n\n    n, q = map(int, input_data.split('\\n')[0].split())\n    enjoyment_values = list(map(int, input_data.split('\\n')[1].split()))\n\n    graph = {i: {} for i in range(1, n+1)}\n\n    for i in range(2, n+1):\n        a, b, c, t = map(int, input_data.split('\\n')[i].split())\n        graph[a][b] = {'capacity': c, 'toll': t}\n        graph[b][a] = {'capacity': c, 'toll': t}\n\n    results = []\n    for j in range(n+1, n+q+1):\n        v, x = map(int, input_data.split('\\n')[j].split())\n        max_enjoyment, min_toll = bfs(x, v)\n        results.append((max_enjoyment, min_toll))\n\n    return [' '.join(map(str, res)) for res in results]"}
{"task_id": 44, "completion": "def find_mastapeece(n, grid):\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    def is_valid(i, j):\n        return 0 <= i < n and 0 <= j < n\n    \n    def count_adjacent_cells_with_color(i, j, color):\n        count = 0\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if is_valid(x, y) and grid[x][y] == color:\n                count += 1\n        return count\n    \n    def fill_mastapeece(i, j, color):\n        filled_grid = [row[:] for row in grid]\n        filled_grid[i][j] = color\n        for dx, dy in directions:\n            x, y = i + dx, j + dy\n            if is_valid(x, y) and filled_grid[x][y] == '.':\n                filled_grid[x][y] = 'S' if color == 'G' else 'G'\n        return filled_grid\n    \n    unique_solutions = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '.':\n                if count_adjacent_cells_with_color(i, j, 'S') > 1 or count_adjacent_cells_with_color(i, j, 'G') > 1:\n                    return \"MULTIPLE\",\n                elif count_adjacent_cells_with_color(i, j, 'S') == 1 and count_adjacent_cells_with_color(i, j, 'G') == 1:\n                    unique_solutions.append(fill_mastapeece(i, j, 'S'))\n                    unique_solutions.append(fill_mastapeece(i, j, 'G'))\n    \n    if len(unique_solutions) == 0:\n        return \"NONE\",\n    elif len(unique_solutions) == 2:\n        return \"UNIQUE\", ['\\n'.join(row) for row in unique_solutions[0]]\n    else:\n        return \"MULTIPLE\","}
{"task_id": 45, "completion": "def determine_flower_height(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    index = 1\n    output = []\n\n    for _ in range(t):\n        n = int(input_lines[index])\n        sequence = list(map(int, input_lines[index + 1].split()))\n\n        height = 1\n        for i in range(n):\n            if sequence[i] == 1:\n                if i > 0 and sequence[i - 1] == 1:\n                    height += 5\n                else:\n                    height += 1\n            else:\n                if i > 0 and sequence[i - 1] == 0:\n                    height = -1\n                    break\n\n        output.append(height)  \n        index += 2  \n\n    return '\\n'.join(map(str, output))\n"}
{"task_id": 46, "completion": "def find_stable_eversions(input_string: str) -> str:\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    index = 1\n    output = []\n\n    def eversion(arr, pivot):\n        if len(arr) <= 1:\n            return 0\n        left = [x for x in arr if x <= pivot]\n        right = [x for x in arr if x > pivot]\n        if arr == left + right:\n            return 0\n        return 1 + eversion(left, left[-1]) + eversion(right, right[-1])\n\n    for _ in range(t):\n        n = int(lines[index])\n        array = list(map(int, lines[index + 1].split()))\n\n        # Start eversion count from the last element as the pivot\n        k = eversion(array, array[-1])\n\n        output.append(str(k))\n        index += 2\n\n    return '\\n'.join(output) + \"\\n\""}
{"task_id": 47, "completion": "def calculate_minimum_distance(input_string):\n    def process_test_case(n, k, depots):\n        depots.sort()\n        min_distance = float('inf')\n        \n        for i in range(n - k + 1):\n            distance = depots[i + k - 1] - depots[i]\n            current_distance = depots[i + k - 1] - depots[i] + min(abs(depots[i]), abs(depots[i + k - 1]))\n            min_distance = min(min_distance, current_distance)\n\n        return min_distance\n\n    input_lines = input_string.strip().split('\\n')\n    num_test_cases = int(input_lines[0])\n    current_line = 1\n    results = []\n\n    for _ in range(num_test_cases):\n        n, k = map(int, input_lines[current_line].split())\n        depots = list(map(int, input_lines[current_line + 1].split()))\n        result = process_test_case(n, k, depots)\n        results.append(result)\n        current_line += 2\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 48, "completion": "def can_sort_array(test_cases):\n    result = []\n\n    for n, arr in test_cases:\n        sorted_cycles = 0\n        i = 0\n        \n        while i < n:\n            if arr[i] != i + 1:\n                cycle_start = arr[i] - 1\n                cycle_mid = arr[cycle_start] - 1\n                cycle_end = arr[cycle_mid] - 1\n\n                if cycle_end == i:\n                    sorted_cycles += 1\n                    i += 1\n                else:\n                    i += 2\n            else:\n                i += 1\n        \n        if sorted_cycles == n:\n            result.append(\"YES\")\n        else:\n            result.append(\"NO\")\n\n    return result\n\n# Test cases\ntest_cases = [(1, [1]), (2, [2, 2]), (2, [2, 1]), (3, [1, 2, 3]), (3, [2, 1, 3]), (3, [3, 1, 2]), (4, [2, 1, 4, 3])]\noutput = can_sort_array(test_cases)\noutput = [o + \"\\n\" for o in output]\nreturn output"}
{"task_id": 49, "completion": "def answer_questions(test_cases):\n\n    output = []\n\n    for test_case in test_cases:\n        n, q = test_case[0]\n        vertices = test_case[1]\n        parent_nodes = test_case[2]\n        questions = test_case[3]\n\n        tree = {}\n        for i in range(1, n + 1):\n            tree[i] = {'value': vertices[i - 1], 'children': []}\n\n        for i in range(2, n + 1):\n            parent = parent_nodes[i - 2]\n            tree[parent]['children'].append(i)\n\n        def find_path_values(v):\n            path_values = []\n            while v in tree:\n                path_values.append(tree[v]['value'])\n                v = parent_nodes[v - 2]\n            return path_values\n\n        def process_question(v, l, k):\n            path_values = find_path_values(v)\n            value_counts = {}\n            for val in path_values:\n                value_counts[val] = value_counts.get(val, 0) + 1\n\n            filtered_values = [val for val, count in value_counts.items() if count >= l]\n            sorted_filtered_values = sorted(filtered_values, key=lambda x: (value_counts[x], x))\n\n            result = sorted_filtered_values[min(k-1, len(sorted_filtered_values))] if sorted_filtered_values else -1\n            return result\n\n        question_answers = [process_question(*question) for question in questions]\n        output.append(\" \".join(map(str, question_answers)))\n\n    return \"\\n\".join(output)"}
{"task_id": 50, "completion": "def count_valid_arrays(input_string):\n    MOD = 998244353\n\n    input_lines = input_string.strip().split('\\n')\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n\n    result = 1\n    for i in range(n):\n        result = (result * max(0, a[i] - i)) % MOD\n\n    return str(result)"}
{"task_id": 51, "completion": "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    l = (n - 1) // 2\n    r = l + 1\n    print(f\"{l} {r}\")"}
{"task_id": 52, "completion": "def find_kth_special_number(input_str):\n    lines = input_str.splitlines()\n    t = int(lines[0])\n    test_cases = [tuple(map(int, line.split())) for line in lines[1:t + 1]]\n\n    mod = 10 ** 9 + 7\n\n    def mod_exp(base, exp, mod):\n\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return result\n\n    results = []\n    for n, k in test_cases:\n        special = 0\n        power = 0\n        while k > 0:\n            if k % 2:\n                special = (special + mod_exp(n, power, mod)) % mod\n            k //= 2\n            power += 1\n        results.append(special)\n\n    return '\\n'.join(map(str, results)) + '\\n'"}
{"task_id": 53, "completion": "def min_operations_to_make_equal(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    results = []\n\n    for i in range(1, len(input_lines), 2):\n        n, c = input_lines[i].split()\n        n = int(n)\n        s_ = input_lines[i+1].strip()\n\n        x_values = []\n        k = s_.count(c)\n        if k == 0:\n            results.append((0, []))\n            continue\n\n        for x in range(1, n+1):\n            if (n-k) % x == 0:\n                x_values.append(x)\n                k -= 1\n                if k == 0:\n                    break\n            \n        results.append((len(x_values), x_values))\n\n    output_results = []\n    for ops, x_vals in results:\n        output_results.append(str(ops))\n        output_results.append(\" \".join(map(str, x_vals)))\n\n    return '\\n'.join(output_results)"}
{"task_id": 54, "completion": "def find_max_imposters(input_string):\n    def process_comments(n, m, comments):\n        graph = {}\n        for i in range(1, n + 1):\n            graph[i] = {'imposter': set(), 'crewmate': set()}\n\n        for comment in comments:\n            i, j, role = comment\n            graph[int(i)]['imposter' if role == 'imposter' else 'crewmate'].add(int(j))\n\n        def dfs(player, role, visited):\n            visited[player] = role\n            for neighbor in graph[player]['crewmate' if role == 'imposter' else 'imposter']:\n                if neighbor in visited:\n                    if visited[neighbor] != role:\n                        return False\n                elif not dfs(neighbor, 'crewmate' if role == 'imposter' else 'imposter', visited):\n                    return False\n            return True\n\n        max_imposters = 0\n        for player in range(1, n + 1):\n            if player not in graph or (player in graph and any(len(graph[player][role]) for role in graph[player])):\n                continue\n\n            visited = {}\n            if dfs(player, 'imposter', visited):\n                max_imposters += 1\n\n        return max_imposters if max_imposters else -1\n\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    line_index = 1\n    output = []\n\n    for _ in range(t):\n        n, m = map(int, input_lines[line_index].split())\n        comments = []\n        for i in range(line_index + 1, line_index + 1 + m):\n            comments.append(input_lines[i].split())\n        line_index += m + 1\n\n        output.append(process_comments(n, m, comments))\n\n    return '\\n'.join(map(str, output))"}
{"task_id": 55, "completion": "def count_good_colorings(k: int) -> int:\n    MOD = 10**9 + 7\n\n    result = 6  # Root node can be colored in 6 ways\n\n    for i in range(1, k):\n        result = (result * pow(6, 2**i, MOD)) % MOD\n\n    return result"}
{"task_id": 56, "completion": "MOD = 10**9 + 7\n\ndef compute_good_colorings(input_str: str) -> int:\n    def is_valid_coloring(colors, k):\n        for i in range(1, len(colors)):\n            parent_color = colors[i // 2]\n            current_color = colors[i]\n            if parent_color == current_color or (parent_color % 2 == current_color % 2):\n                return False\n        return True\n\n    lines = input_str.strip().split('\\n')\n    k = int(lines[0])\n    n = int(lines[1])\n    colors = {}\n    for line in lines[2:]:\n        v, color = line.split()\n        colors[int(v)] = color\n\n    total_nodes = 2 ** k - 1\n    \n    def backtrack(node_id, current_colors):\n        if node_id <= total_nodes:\n            if node_id in colors:\n                current_colors[node_id] = colors[node_id]\n                if not is_valid_coloring(current_colors, k):\n                    return 0\n                return (backtrack(node_id * 2, current_colors) * backtrack(node_id * 2 + 1, current_colors)) % MOD\n            else:\n                count = 0\n                for color in range(1, 7):\n                    current_colors[node_id] = color\n                    if is_valid_coloring(current_colors, k):\n                        count += (backtrack(node_id * 2, current_colors) * backtrack(node_id * 2 + 1, current_colors)) % MOD\n                        count %= MOD\n                return count\n        return 1\n\n    result = backtrack(1, {})\n    return result"}
{"task_id": 57, "completion": "def isFarmIdeal(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    for i in range(1, 1 + 2*t, 2):\n        s, n, k = map(int, input_lines[i].split())\n        \n        total_pens = s // n\n        total_animals = total_pens * n\n\n        if total_animals != s:\n            output.append(\"NO\")\n        else:\n            segment_animals = s - total_animals + n\n            if 1 <= k <= segment_animals:\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n\n    return '\\n'.join(output)"}
{"task_id": 58, "completion": "def complete_level(test_cases_str):\n    test_cases = test_cases_str.strip().splitlines()\n    t = int(test_cases[0])\n    results = []\n    idx = 1\n\n    for _ in range(t):\n        n = int(test_cases[idx])\n        first_row = test_cases[idx + 1]\n        second_row = test_cases[idx + 2]\n        idx += 3\n\n        canComplete = all(first_row[i] != '1' or second_row[i] != '1' for i in range(1, n))\n\n        results.append(\"YES\" if canComplete else \"NO\")\n\n    return '\\n'.join(results) + \"\\n\""}
{"task_id": 59, "completion": "def check_division_possibility(input_string):\n    output = []\n    \n    def can_divide_students(n, preferences):\n        for i in range(n):\n            days_student_can_attend = [j for j in range(5) if preferences[i][j] == 1]\n            for day1 in range(5):\n                if day1 not in days_student_can_attend:\n                    continue\n                for day2 in range(5):\n                    if day2 not in days_student_can_attend:\n                        continue\n                    if day1 != day2:\n                        return True\n        return False\n    \n    input_lines = input_string.strip().split('\\n')\n    testcases = int(input_lines[0])\n    current_line = 1\n    \n    for _ in range(testcases):\n        n = int(input_lines[current_line])\n        preferences = []\n        for i in range(current_line + 1, current_line + n + 1):\n            preferences.append(list(map(int, input_lines[i].split())))\n        \n        current_line += n + 1\n        \n        if n % 2 != 0:\n            output.append(\"NO\")\n        else:\n            if can_divide_students(n, preferences):\n                output.append(\"YES\")\n            else:\n                output.append(\"NO\")\n    \n    return output"}
{"task_id": 60, "completion": "def calculate_pairs_to_delete(input_str):\n    input_lines = input_str.strip().split('\\n')\n    results = []\n\n    for i in range(1, len(input_lines), 2):\n        n = int(input_lines[i])\n        a = list(map(int, input_lines[i+1].split()))\n\n        k = sum(a) / n\n        count = 0\n\n        for idx in range(n):\n            for j in range(idx + 1, n):\n                new_sum = sum(a) - a[idx] - a[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == k:\n                    count += 1\n\n        results.append(count)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 61, "completion": "def select_training_problems(input_data):\n    def count_ways(n, problems):\n        topics_count = [0] * (n + 1)\n        difficulties_count = [0] * (n + 1)\n\n        for topic, difficulty in problems:\n            topics_count[topic] += 1\n            difficulties_count[difficulty] += 1\n\n        ways = 0\n        for topic, difficulty in problems:\n            valid_topic = topics_count[topic] > 1\n            valid_difficulty = difficulties_count[difficulty] > 1\n            if valid_topic or valid_difficulty:\n                ways += (n - 1) * 2\n\n        return ways // 2\n\n    testcases = input_data.strip().split('\\n')\n    results = []\n\n    for i in range(1, len(testcases), 2):\n        n = int(testcases[i])\n        problems = [tuple(map(int, x.split())) for x in testcases[i + 1:i + 1 + n]]\n        ways = count_ways(n, problems)\n        results.append(ways)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 62, "completion": "def count_staircases(n, m, q, queries):\n    result = []\n    staircases = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    def is_staircase(x1, y1, x2, y2):\n        return (abs(x1 - x2) == 1 and y1 == y2) or (abs(y1 - y2) == 1 and x1 == x2)\n    \n    def count_stairs():\n        stair_count = 0\n        for x in range(1, n + 1):\n            for y in range(1, m + 1):\n                if staircases[x][y]:\n                    stair_count += (staircases[x - 1][y]) + (staircases[x + 1][y]) + (staircases[x][y - 1]) + (staircases[x][y + 1])\n        return stair_count // 2\n    \n    result.append(count_stairs())\n    \n    for x, y in queries:\n        staircases[x][y] = 1 - staircases[x][y]\n        result.append(count_stairs())\n    \n    return '\\n'.join(map(str, result))"}
{"task_id": 63, "completion": "def max_RBS_prefixes(sequences):\n    opening_closing_count = []\n    \n    for seq in sequences:\n        opening_count = seq.count('(')\n        closing_count = len(seq) - opening_count\n        opening_closing_count.append((opening_count, closing_count, seq))\n    \n    opening_closing_count.sort(key=lambda x: (-x[0], x[1]))\n    \n    concatenated_seq = \"\".join(seq for _, _, seq in opening_closing_count)\n    \n    total_opening = 0\n    total_closing = 0\n    max_prefixes = 0\n    \n    for char in concatenated_seq:\n        if char == '(':\n            total_opening += 1\n        else:\n            total_closing += 1\n        max_prefixes = max(max_prefixes, min(total_opening, total_closing))\n    \n    return max_prefixes"}
{"task_id": 64, "completion": "def find_adjacent_elements(input_str):\n    s, x = input_str.strip().split(\"\\n\")\n    x = int(x)\n\n    n = len(s)\n\n    for i in range(n - 1):\n        for j in range(1, min(n - i, 200001)):\n            num1 = int(s[i:i+j])\n            num2 = int(s[i+j:i+j*2])\n\n            if num1 + num2 == x and '0' not in str(num1) and '0' not in str(num2):\n                return f\"{i+1} {i+j}\\n{i+j+1} {i+j*2}\""}
{"task_id": 65, "completion": ""}
{"task_id": 66, "completion": "def last_remaining_card(input_data):\n    results = []\n    \n    for test_case in input_data:\n        n, (start_A, start_B), (direction_A, direction_B) = test_case\n        \n        index_A, index_B = start_A, start_B\n        \n        for i in range(n - 1):\n            if index_A == index_B:\n                removed_card = index_A\n                index_A = (index_A + (1 if direction_A == \"right\" else -1)) % n\n                index_B = (index_B + (1 if direction_B == \"right\" else -1)) % n\n            else:\n                removed_card = None\n                index_A = (index_A + (1 if direction_A == \"right\" else -1)) % n\n                index_B = (index_B + (1 if direction_B == \"right\" else -1)) % n\n            \n        for i in range(n):\n            if i != removed_card:\n                results.append(i)\n    \n    return results"}
{"task_id": 67, "completion": "def minimum_maps_to_study(input_string: str) -> str:\n    N, P = map(float, input_string.strip().split())\n    \n    k = 1\n    while (1 - ((N-1)/N)**k) < P:\n        k += 1\n        \n    return str(k)"}
{"task_id": 68, "completion": "import math\n\ndef find_last_popped_bubble(input_str):\n    input_lines = input_str.strip().split('\\n')\n    num_bubbles = int(input_lines[0])\n    bubbles = [[int(x) for x in line.split()] for line in input_lines[1:num_bubbles + 1]]\n    num_finalists = int(input_lines[num_bubbles + 1])\n    finalists_data = [[int(x) for x in line.split()] for line in input_lines[num_bubbles + 2:]]\n\n    def get_angle(x1, y1, x2, y2):\n        return math.atan2(y2 - y1, x2 - x1)\n\n    center_points = [(x, y) for x, y in bubbles]\n\n    def find_bubble_to_pop(dx, dy, k):\n        bubble_distances = [(i, get_angle(dx, dy, x, y), (x-dx)**2 + (y-dy)**2) for i, (x, y) in enumerate(center_points)]\n        bubble_distances.sort(key=lambda x: (x[1], -x[2]))\n        return bubble_distances[k-1][0]\n\n    results = []\n    for dx, dy, k in finalists_data:\n        last_popped_idx = find_bubble_to_pop(dx, dy, k)\n        results.append(last_popped_idx + 1)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 69, "completion": "def process_queries(input_string: str) -> str:\n    MOD = 10**9 + 7\n\n    def fibonacci(n, memo={}):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)\n        return memo[n] % MOD\n\n    def solve_queries(N, Q, A1, A2, queries):\n        result = []\n        for query in queries:\n            if len(query) == 3:\n                l, r = query[0], query[1]\n                result.append(sum(fibonacci(A1[i] + A2[i]) for i in range(l - 1, r)) % MOD)\n            else:\n                k, l, r, x = query[0], query[1], query[2], query[3]\n                if k == 1:\n                    for i in range(l - 1, r):\n                        A1[i] = min(A1[i], x)\n                elif k == 2:\n                    for i in range(l - 1, r):\n                        A1[i] = max(A1[i], x)\n                elif k == 3:\n                    for i in range(l - 1, r):\n                        A1[i] += x\n                        A2[i] += x\n        return result\n\n    input_lines = input_string.strip().split('\\n')\n    N, Q = map(int, input_lines[0].split())\n    A1 = list(map(int, input_lines[1].split()))\n    A2 = list(map(int, input_lines[2].split()))\n    queries = [list(map(int, line.split())) for line in input_lines[3:]]\n\n    results = solve_queries(N, Q, A1, A2, queries)\n    return '\\n'.join(map(str, results))"}
{"task_id": 70, "completion": "def can_connect_cities(N, Q, cities, queries):\n    result = []\n    \n    def calculate_distance(start, end):\n        if start <= end:\n            return (cities[end] - cities[start]) % (10**9 + 7)\n        else:\n            return (cities[end] + cities[-1] - cities[start] + cities[0]) % (10**9 + 7)\n    \n    for L, R, D in queries:\n        dist = calculate_distance(L-1, R-1)\n        if dist == D:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return result"}
{"task_id": 71, "completion": "import math\ndef shortest_path(input_string: str) -> str:\n    input_data = input_string.strip().split('\\n')\n    N, K = map(int, input_data[0].split())\n    points = [list(map(int, x.split())) for x in input_data[1:]]\n    \n    angles = []\n    for i, point in enumerate(points):\n        if i != K-1:\n            x_diff = point[0] - points[K-1][0]\n            y_diff = point[1] - points[K-1][1]\n            angle = math.atan2(y_diff, x_diff)\n            angles.append((i + 1, angle))\n\n    angles.sort(key=lambda x: x[1])\n\n    total_length = 0\n    for idx in range(len(angles) - 1):\n        total_length += math.sqrt((points[angles[idx+1][0]-1][0] - points[angles[idx][0]-1][0])**2 + \n                                  (points[angles[idx+1][0]-1][1] - points[angles[idx][0]-1][1])**2)\n    \n    total_length += math.sqrt((points[angles[0][0]-1][0] - points[angles[-1][0]-1][0])**2 + \n                              (points[angles[0][0]-1][1] - points[angles[-1][0]-1][1])**2)\n    \n    return '{:.10f}'.format(total_length)"}
{"task_id": 72, "completion": ""}
{"task_id": 73, "completion": "def count_desert_pairs(input_str):\n    input_lines = input_str.strip().split('\\n')\n    N, M = map(int, input_lines[0].split())\n    edges = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    def is_cactus(graph):\n        pass\n\n    def count_deserts(L, R):\n        subgraph_edges = edges[L-1:R]\n        subgraph = {}\n        for u, v in subgraph_edges:\n            subgraph.setdefault(u, []).append(v)\n            subgraph.setdefault(v, []).append(u)\n\n        components = []\n        visited = set()\n\n        def dfs(node, component):\n            visited.add(node)\n            component.add(node)\n            for neighbor in subgraph.get(node, []):\n                if neighbor not in visited:\n                    dfs(neighbor, component)\n\n        for node in range(1, N + 1):\n            if node not in visited:\n                component = set()\n                dfs(node, component)\n                components.append(component)\n\n        return all(is_cactus(component) for component in components)\n\n    total_pairs = 0\n    for i in range(1, M + 1):\n        for j in range(i, M + 1):\n            if count_deserts(i, j):\n                total_pairs += 1\n\n    return str(total_pairs)"}
{"task_id": 74, "completion": "def find_original_array_from_beautifier_output(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    N = int(input_lines[0])\n    B = list(map(int, input_lines[1].split()))\n\n    total_sum = sum(B)\n\n    if total_sum % N != 0:\n        return \"NO\"\n\n    target_sum = total_sum // N\n    A = [0] * N\n\n    for i in range(N):\n        diff = B[i] - target_sum * (N-1)\n        if diff % N != 0 or (B[i] - diff) < 0:\n            return \"NO\"\n        A[i] = diff // N\n\n    return \"YES\\n\" + ' '.join(map(str, A)).\n"}
{"task_id": 75, "completion": "def game_winner(N_and_A):\n    N, *A = map(int, N_and_A.split())\n    \n    dp = [[0] * N for _ in range(N)]\n    \n    for i in range(N):\n        dp[i][i] = A[i]\n    \n    for length in range(2, N+1):\n        for i in range(N-length+1):\n            j = i + length - 1\n            dp[i][j] = max(A[i] - dp[i+1][j], A[j] - dp[i][j-1])\n    \n    return \"Alice\" if dp[0][N-1] > 0 else \"Bob\""}
{"task_id": 76, "completion": "from collections import defaultdict\nfrom itertools import combinations\n\ndef organize_successful_party(input_str):\n    input_lines = input_str.strip().split('\\n')\n    N, M = map(int, input_lines[0].split())\n\n    # Build the graph using defaultdict\n    graph = defaultdict(set)\n    for line in input_lines[1:]:\n        u, v = map(int, line.split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Function to check if a set of people forms a clique\n    def is_clique(people):\n        return all((a in graph[b] or b in graph[a]) for a in people for b in people if a != b)\n\n    # Function to check if a set of people forms an independent set\n    def is_independent_set(people):\n        return not any((a in graph[b] or b in graph[a]) for a in people for b in people if a != b)\n\n    # Check combinations of 5 people to find either a clique or an independent set\n    for people in combinations(range(1, N + 1), 5):\n        if is_clique(people) or is_independent_set(people):\n            return ' '.join(map(str, sorted(people))) + \"\\n\"\n\n    return '-1\\n'"}
{"task_id": 77, "completion": "def find_room_sizes(input_data):\n    n, m = map(int, input_data.strip().split('\\n')[0].split())\n    grid = [list(map(int, line.split())) for line in input_data.strip().split('\\n')[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def dfs(x, y):\n        if not is_valid(x, y) or grid[x][y] == -1:\n            return 0\n        \n        cell_value = grid[x][y]\n        grid[x][y] = -1\n        size = 1\n        \n        if cell_value & 1 == 0:\n            size += dfs(x - 1, y)\n        if cell_value & 2 == 0:\n            size += dfs(x, y + 1)\n        if cell_value & 4 == 0:\n            size += dfs(x + 1, y)\n        if cell_value & 8 == 0:\n            size += dfs(x, y - 1)\n        \n        return size\n\n    room_sizes = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != -1:\n                room_sizes.append(dfs(i, j))\n\n    room_sizes.sort(reverse=True)\n\n    return ' '.join(map(str, room_sizes))"}
{"task_id": 78, "completion": "from itertools import combinations\n\ndef find_possible_k(test_cases_input):\n    def bitwise_and(x, y):\n        return x & y\n\n    def eliminate_elements(a, indices, x):\n        for i in indices:\n            a[i] -= x\n\n    def check_if_all_zero(a):\n        return all(element == 0 for element in a)\n\n    results = []\n\n    for test_case in test_cases_input:\n        n, a = test_case\n        possible_values_of_k = set()\n\n        for k in range(1, n + 1):\n            for indices in combinations(range(n), k):\n                x = a[indices[0]]\n                for i in range(1, k):\n                    x = bitwise_and(x, a[indices[i]])\n\n                eliminate_elements(a, indices, x)\n\n                if check_if_all_zero(a):\n                    possible_values_of_k.add(k)\n\n                for i in indices:\n                    a[i] += x\n\n        results.append(sorted(list(possible_values_of_k)))\n\n    return results\n\n# Test the function with sample input\ntest_cases_input = [\n    (4, [4, 4, 4, 4]),\n    (4, [13, 7, 25, 19]),\n    (6, [3, 5, 3, 1, 7, 1]),\n    (1, [1]),\n    (5, [0, 0, 0, 0, 0])\n]\n\nresult = find_possible_k(test_cases_input)\nfor res in result:\n    print(*res)"}
{"task_id": 79, "completion": "def solve(n, a, b):\n    n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nINF = float('inf')\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, a[i - 1]) + 1):\n            if j - b[i - 1] >= 0:\n                dp[i] = min(dp[i], dp[i - j] + 1)\n\n    if dp[n] == INF:\n        return -1\n\n    result = []\n    cur_depth = n\n    while cur_depth > 0:\n        result.append(cur_depth)\n        for j in range(1, min(cur_depth, a[cur_depth - 1]) + 1):\n            if cur_depth - j >= 0 and dp[cur_depth - j] == dp[cur_depth] - 1 and j - b[cur_depth - 1] >= 0:\n                cur_depth -= j\n                break\n\n    result.append(0)\n\n    print(len(result) - 1)\n    print(*result[::-1])\n\n"}
{"task_id": 80, "completion": "def minimum_inversions(test_input):\n    results = []\n    \n    for test_case in test_input:\n        n, m = test_case[0]\n        a = test_case[1]\n        b = test_case[2]\n\n        initial_inversions = sum(a[i] > a[j] for i in range(n - 1) for j in range(i + 1, n))\n\n        sorted_b = sorted(b, reverse=True)\n        total_inversions = 0\n        for bi in sorted_b:\n            pos = 0\n            while pos < n and a[pos] < bi:\n                pos += 1\n            total_inversions += n - pos\n\n        results.append(total_inversions + initial_inversions)\n\n    return [str(res) for res in results]"}
{"task_id": 81, "completion": "import heapq\n\ndef max_alpinists_to_climb(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, d = map(int, input_lines[0].split())\n    alpinists = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    alpinists.sort(reverse=True)\n\n    max_count = 0\n    current_difficulty = d\n    pq = []\n\n    for skill, neatness in alpinists:\n        if skill < current_difficulty:\n            break\n        if neatness >= current_difficulty:\n            max_count += 1\n            heapq.heappush(pq, -neatness)\n        else:\n            heapq.heappush(pq, -current_difficulty)\n\n        while pq and -pq[0] > current_difficulty:\n            current_difficulty = -heapq.heappop(pq)\n\n    return max_count"}
{"task_id": 82, "completion": "def calculate_minimum_money(input_string):\n    input_lines = input_string.strip().split('\\n')\n    n, q, k = map(int, input_lines[0].split())\n    ticket_costs = list(map(int, input_lines[1].split()))\n\n    cumulative_costs = [0]\n    for i in range(n):\n        cumulative_costs.append(cumulative_costs[-1] + ticket_costs[i])\n\n    result = []\n    for i in range(2, len(input_lines)):\n        l, r = map(int, input_lines[i].split())\n        total_cost = cumulative_costs[r] - cumulative_costs[l - 1]\n        min_cost = min(ticket_costs[l - 1] + total_cost - ticket_costs[l - 1], total_cost)\n        result.append(min_cost)\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 83, "completion": "def calculate_lexicographical_sum(n_str):\n    MOD = 998244353\n    MOD_FINAL = 10**9 + 7\n\n    n = int(n_str)\n\n    sum_result = 0\n    factor = 1\n\n    while n > 0:\n        d = n % 10\n        sum_result = (sum_result + (d * (d - 1) // 2) * factor) % MOD\n        factor = (factor * 10 + 1) % MOD\n        n //= 10\n\n    return sum_result % MOD_FINAL\n\n# Test cases\nprint(calculate_lexicographical_sum('12'))  # Output: 994733045\nprint(calculate_lexicographical_sum('21'))  # Output: 978932159\nprint(calculate_lexicographical_sum('3'))   # Output: 0\nprint(calculate_lexicographical_sum('1000000000000'))  # Output: 289817887"}
{"task_id": 84, "completion": "import math\n\ndef gcd(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef c(l, r):\n    count = 0\n    for i in range(l, r + 1):\n        for j in range(i, r + 1):\n            if gcd(i, j) >= l:\n                count += 1\n    return count\n\ndef f(n, k):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, n + 1):\n        dp[1][i] = c(1, i)\n    for i in range(2, k + 1):\n        for j in range(i, n + 1):\n            dp[i][j] = float('inf')\n            for x in range(i - 1, j):\n                dp[i][j] = min(dp[i][j], dp[i - 1][x] + c(x + 1, j))\n    return dp[k][n]\n\ndef solve(input_string):\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    result = []\n    for i in range(1, t + 1):\n        n, k = map(int, lines[i].split())\n        result.append(str(f(n, k)))\n    return '\\n'.join(result)"}
{"task_id": 85, "completion": "def count_perfect_sequences(input_string: str) -> str:\n    n, M = map(int, input_string.strip().split())\n    dp = [[0] * (n + 2) for _ in range(n + 1)]\n    dp[1][1] = 1\n    for i in range(2, n + 2):\n        for j in range(1, n + 2):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * j) % M\n    return str(sum(dp[n + 1]) % M)"}
{"task_id": 86, "completion": "import sys\n\nMOD = 998244353\n\ndef solve_single_test_case(n, k, x):\n    dp = [0] * min(1 << 20, 1 << k)\n    dp[x] = 1\n    prev_dp = [0] * min(1 << 20, 1 << k)\n\n    for _ in range(n):\n        for i in range(min(1 << 20, 1 << k)):\n            prev_dp[i] = dp[i]\n\n        for i in range(min(1 << 20, 1 << k)):\n            if dp[i] > 0:\n                for j in range(k):\n                    if (((i >> j) & 1) == 1):\n                        dp[i ^ (1 << j)] = (dp[i ^ (1 << j)] + prev_dp[i]) % MOD\n                dp[i] = (dp[i] + prev_dp[i]) % MOD\n\n    return sum(dp) % MOD\n\n"}
{"task_id": 87, "completion": "def minimum_operations_to_satisfy_condition(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n    \n    result = []\n\n    for _ in range(t):\n        n = int(input_lines[0])\n        sequence = list(map(int, input_lines[1].split()))\n        \n        operations = 0\n        \n        for i in range(n):\n            if sequence[i] > i + 1:\n                operations += sequence[i] - (i + 1)\n\n        result.append(operations)\n        input_lines = input_lines[2:]\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 88, "completion": "def can_split_into_subarrays(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    for i in range(1, 2 * t + 1, 2):\n        n = int(input_lines[i])\n        a = list(map(int, input_lines[i + 1].split()))\n\n        def find_lis_length(arr):\n            n = len(arr)\n            lis = [1] * n\n\n            for i in range(1, n):\n                for j in range(i):\n                    if arr[i] > arr[j]:\n                        lis[i] = max(lis[i], lis[j] + 1)\n\n            return lis\n\n        def is_possible_to_split_subarrays(arr):\n            n = len(arr)\n            lis_length = find_lis_length(arr)\n\n            if max(lis_length) == n:\n                return \"NO\"\n\n            xor_value = 0\n            for length in lis_length:\n                xor_value ^= length\n\n            return \"YES\" if xor_value == 0 else \"NO\"\n\n        output.append(is_possible_to_split_subarrays(a))\n\n    return '\\n'.join(output)"}
{"task_id": 89, "completion": "def erase_sequence(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    results = []\n\n    for i in range(1, 2*t + 1, 2):\n        n = int(input_lines[i])\n        sequence = list(map(int, input_lines[i + 1].split()))\n\n        possible = True\n        for j in range(n):\n            if sequence[j] % (j + 1) == 0:\n                possible = False\n                break\n\n        results.append(\"YES\" if possible else \"NO\")\n\n    return results"}
{"task_id": 90, "completion": "def find_integer_n(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n\n    results = []\n    for i in range(1, 2*t+1, 2):\n        x, y = map(int, input_lines[i].split())\n\n        if y == 0:\n            results.append(str(x))\n        else:\n            results.append(str(y))\n\n    return '\\n'.join(results)"}
{"task_id": 91, "completion": "def sum_of_extreme_values(input_str):\n    MOD = 998244353\n\n    def extreme_value(arr):\n        res = 0\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                res += arr[i - 1] - arr[i]\n        return res\n\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(input_lines[index])\n        arr = list(map(int, input_lines[index + 1].split()))\n\n        result = 0\n        for i in range(n):\n            for j in range(i, n):\n                sub_array = arr[i:j + 1]\n                res = 0\n                for k in range(1, len(sub_array)):\n                    if sub_array[k] < sub_array[k - 1]:\n                        res += sub_array[k - 1] - sub_array[k]\n                result += res\n\n        results.append(str(result % MOD))\n        index += 2\n\n    return '\\n'.join(results)"}
{"task_id": 92, "completion": "def balance_string(s):\n    ab_count = s.count(\"ab\")\n    ba_count = s.count(\"ba\")\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == 'ab' and ab_count > ba_count:\n            s = s[:i+1] + 'b' + s[i+2:]\n            ab_count -= 1\n        elif s[i:i+2] == 'ba' and ba_count > ab_count:\n            s = s[:i+1] + 'a' + s[i+2:]\n            ba_count -= 1\n    \n    return s"}
{"task_id": 93, "completion": "def min_hours_to_copy_update_files(input_string: str) -> str:\n    output = []\n    test_cases = input_string.strip().split('\\n')[1:]\n\n    for test_case in test_cases:\n        n, k = map(int, test_case.split())\n        min_hours = (n + k - 2) // (k - 1)\n        \n        output.append(str(min_hours))\n\n    return '\\n'.join(output)"}
{"task_id": 94, "completion": "def min_unrepresented_burles(t):\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        denominations = [10**ai for ai in a]\n        \n        s = 1\n        while True:\n            num_banknotes = 0\n            for i in reversed(range(len(denominations))):\n                num_banknotes += s // denominations[i]\n                s %= denominations[i]\n            if num_banknotes > k:\n                results.append(s)\n                break\n            s += 1\n    \n    return list(map(str, results))"}
{"task_id": 95, "completion": "def find_perfect_coloring_and_cut(input_str):\n    answers = []\n\n    inputs = input_str.strip().split('\\n')\n    t = int(inputs[0])\n\n    index = 1\n    for _ in range(t):\n        n, m = map(int, inputs[index].split())\n        matrix = [list(map(int, row.split())) for row in inputs[index + 1 : index + 1 + n]]\n\n        color_string = \"\"\n\n        for i in range(n):\n            if sorted(matrix[i]) == matrix[i]:\n                color_string += \"R\"\n            elif sorted(matrix[i], reverse=True) == matrix[i]:\n                color_string += \"B\"\n            else:\n                answers.append(\"NO\")\n                break\n\n        if \"R\" not in color_string or \"B\" not in color_string:\n            answers.append(\"NO\")\n            break\n\n        for k in range(1, m):\n            left_max = max(matrix[i][j] for i in range(n) for j in range(k))\n            right_min = min(matrix[i][j] for i in range(n) for j in range(k, m))\n\n            if all(\n                matrix[i][j] <= left_max for i in range(n) for j in range(k)\n            ) and all(matrix[i][j] >= right_min for i in range(n) for j in range(k, m)):\n                answers.append(f\"YES\\n{color_string} {k}\")\n                break\n        else:\n            answers.append(\"NO\")\n\n        index += n + 1\n\n    return answers"}
{"task_id": 96, "completion": "def calculate_number_of_ways(input_str):\n    n, x = map(int, input_str.split())\n    mod = 998244353\n    \n    dp = [[0] * (x + 1) for _ in range(n + 1)]\n    \n    for j in range(1, x + 1):\n        dp[2][j] = j * (j - 1) % mod\n    \n    for i in range(3, n + 1):\n        for j in range(1, x + 1):\n            dp[i][j] = (dp[i][j-1] * j + dp[i-1][j-1]) % mod\n\n    return str(dp[n][x])\n\n# Ensure the new solution meet the requirements above and successfully completes the task."}
{"task_id": 97, "completion": "from collections import defaultdict\n\ndef maximize_value(n, edges, q, queries):\n    adj_list = defaultdict(list)\n    for x, y in edges:\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n    \n    result = []\n    \n    for v, k in queries:\n        children = 0\n        for child in adj_list[v]:\n            children += 1\n        result.append(max(0, children - k))\n    \n    return result\n\n"}
{"task_id": 98, "completion": "def minimal_time_to_type(s):\n    lines = s.strip().split('\\n')\n    t = int(lines[0])\n    results = []\n\n    for i in range(1, len(lines), 2):\n        keyboard = lines[i]\n        word = lines[i + 1]\n        positions = {char: index for index, char in enumerate(keyboard)}\n        total_time = 0\n        prev_index = positions[word[0]]\n\n        for letter in word[1:]:\n            index = positions[letter]\n            total_time += abs(index - prev_index)\n            prev_index = index\n\n        results.append(str(total_time))\n\n    return '\\n'.join(results)"}
{"task_id": 99, "completion": "def grasshopper_position(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n\n    def calculate_grasshopper_position(x_0: int, n: int) -> int:\n        for i in range(1, n + 1):\n            if x_0 % 2 == 0:\n                x_0 -= i\n            else:\n                x_0 += i\n        return x_0\n\n    results = []\n    for line in input_lines[1:]:\n        x_0, n = map(int, line.split())\n        result = calculate_grasshopper_position(x_0, n)\n        results.append(result)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 100, "completion": "def maximize_minimal_element(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(input_lines[index])\n        nums = list(map(int, input_lines[index + 1].split()))\n\n        if n == 1:\n            results.append(str(nums[0]))\n        else:\n            max_min = float('-inf')\n            min_elem = nums[0]\n            for i in range(1, len(nums)):\n                max_min = max(max_min, nums[i] - min_elem)\n                min_elem = min(min_elem, nums[i])\n\n            results.append(str(max_min))\n\n        index += 2\n\n    return '\\n'.join(results)"}
{"task_id": 101, "completion": "def transform_array_to_permutation(data):\n    data = data.strip().split(\"\\n\")\n    results = []\n    \n    for i in range(1, len(data), 3):\n        n = int(data[i])\n        a = list(map(int, data[i + 1].split()))\n        colors = data[i + 2]\n\n        blue_count = colors.count(\"B\")\n        red_count = n - blue_count\n        \n        if blue_count != red_count:\n            results.append(\"NO\")\n            continue\n\n        total_sum = sum(a)\n        expected_sum = n * (n + 1) // 2\n        \n        if total_sum != expected_sum:\n            results.append(\"NO\")\n            continue\n\n        min_val = min(a)\n        max_val = max(a)\n        \n        if min_val < 1 or max_val > n or (max_val - min_val) >= n:\n            results.append(\"NO\")\n            continue\n\n        results.append(\"YES\")\n\n    return results"}
{"task_id": 102, "completion": "def optimal_starting_cell(s):\n    lines = s.splitlines()\n    t = int(lines[0])\n    results = []\n    line_idx = 1\n    for _ in range(t):\n        n, m = map(int, lines[line_idx].split())\n        s_input = lines[line_idx + 1]\n        best_cell = (1, 1)\n        max_commands = 0\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                x, y = i, j\n                commands = 0\n                for command in s_input:\n                    if command == 'L':\n                        y -= 1\n                    elif command == 'R':\n                        y += 1\n                    elif command == 'U':\n                        x -= 1\n                    elif command == 'D':\n                        x += 1\n\n                    if x < 1 or x > n or y < 1 or y > m:\n                        break\n                    commands += 1\n\n                if commands > max_commands:\n                    max_commands = commands\n                    best_cell = (i, j)\n\n        results.append(f\"{best_cell[0]} {best_cell[1]}\")\n        line_idx += 2\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 103, "completion": "def max_robot_moves(input_string):\n    directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    data = input_string.splitlines()\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n\n    for _ in range(t):\n        idx += 1  # Skip the blank line\n        n, m = map(int, data[idx].split())\n        idx += 1\n        board = data[idx:idx + n]\n        idx += n\n\n        max_steps = 0\n        start_cell = (1, 1)\n\n        def calculate_steps(i, j):\n            r, c = i + 1, j + 1\n            steps = 0\n            visited = set()\n            while 1 <= r <= n and 1 <= c <= m and (r, c) not in visited:\n                visited.add((r, c))\n                dr, dc = directions[board[r - 1][c - 1]]\n                r, c = r + dr, c + dc\n                steps += 1\n            return steps\n\n        for i in range(n):\n            for j in range(m):\n                steps = calculate_steps(i, j)\n                if steps > max_steps:\n                    max_steps = steps\n                    start_cell = (i + 1, j + 1)\n\n        results.append(f\"{start_cell[0]} {start_cell[1]} {max_steps}\")\n\n    return \"\\n\".join(results)\n\n\ndef check(candidate):\n    inputs = [\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nUDUR\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nRUDU\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nRUDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRDRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDUDR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nUDRU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULRL\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDUD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nURLL\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nLLUR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nDURU\\nULLR\\n\\n4 4\\nULDD\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDRU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nUUDR\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDRUU\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nDRUU\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nDRRR\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDUR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRDR\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDULD\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDRU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nURLL\\n\\n4 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nUURD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n2 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nLLUR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDRUU\\nURUD\\nRLLU\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nDRLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUDU\\nDRUU\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nDRRR\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n2 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nLLUR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n2 4\\nDDLU\\nDDUR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDUDR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nUDDL\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDUR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n1 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDDLR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nLLUR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nUURD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nDRLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nUDLD\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n2 4\\nDDLU\\nDDUR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nDRLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRDUU\\nDURU\\nULLR\\n\\n2 4\\nDDLU\\nDDUR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nLU\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDRU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n2 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nUDRU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nDRUU\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nRLLU\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDDL\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nLRR\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRLR\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n2 4\\nULDD\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nLLUR\\n\\n1 4\\nDDLU\\nDRDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n2 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDRU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nDRRR\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nLU\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nURLL\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nDU\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDDL\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n3 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDDRU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nDLDU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nUDRU\\nULRL\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nUURD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nLD\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n2 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nUDDR\\nUUUU\\nDDLR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nDRUU\\nURUD\\nRLLU\\n\\n4 4\\nDDLU\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nLU\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nDRLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRDR\\nRUUD\\nURDU\\nULRL\\n\\n4 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nUR\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n1 4\\nDDLU\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nURDD\\nUUUU\\nRDLD\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUDU\\nDURU\\nULLR\\n\\n4 4\\nDDLU\\nDRDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nUR\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nDL\\nUL\\nRU\\n\\n4 4\\nRRRD\\nDUUR\\nURUD\\nULLR\\n\\n4 4\\nULDD\\nRDDU\\nUUUU\\nDLDR\\n',\n        '7\\n\\n1 1\\nR\\n\\n1 3\\nRRL\\n\\n2 2\\nDL\\nRU\\n\\n2 2\\nUD\\nRU\\n\\n3 2\\nLD\\nUL\\nUR\\n\\n4 4\\nRRRD\\nRUUD\\nURUD\\nULLR\\n\\n2 4\\nDDLU\\nRUDD\\nUUUU\\nRDLD\\n']\n    outputs = [['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 6\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 2 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n2 1 7\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 2\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 6\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 7\\n3 1 5'], ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 9\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n3 2 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 5\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 6\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 9\\n1 1 4'], ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 5\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 1 9\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 10\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n2 2 4\\n4 3 10\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n2 2 4\\n4 3 10\\n1 1 3'],\n               ['1 1 1\\n1 2 2\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 12\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 9\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n2 1 6\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n3 2 6\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n2 1 7\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 6\\n3 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 5\\n4 3 9\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 6\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n1 2 3\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 2 8\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 4\\n4 3 12\\n3 3 6'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n2 2 4\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n3 1 9\\n1 3 4'], ['1 1 1\\n1 1 2\\n1 2 3\\n1 2 2\\n3 1 5\\n3 2 6\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 1 12\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 9\\n1 2 5'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 1 9\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n2 1 6\\n3 2 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 6\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 2\\n3 1 5\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 10\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 2 2\\n1 2 3\\n3 2 6\\n1 1 4'], ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n3 1 5\\n4 3 9\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 9\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n2 1 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 2\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n3 2 5\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 9\\n3 3 6'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 5\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n1 2 3\\n4 3 12\\n3 2 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n1 2 2\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n2 1 3\\n3 1 6\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n1 2 2\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 6\\n3 1 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n2 1 7\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n1 1 6\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 2 2\\n1 1 4\\n2 1 3\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 5\\n2 1 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 2\\n1 2 3\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n1 2 4\\n3 2 5\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 9\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n1 2 2\\n3 1 4\\n3 1 9\\n1 1 4'], ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n2 2 4\\n2 1 7\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 2 2\\n1 2 3\\n1 1 6\\n1 3 5'], ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n2 2 4\\n2 1 7\\n2 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 2 2\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n1 2 3\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 5\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 2\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n3 2 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n2 2 4\\n4 3 10\\n1 1 3'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n1 2 3\\n2 1 6\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n1 2 3\\n4 3 12\\n3 4 6'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 12\\n3 3 6'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n3 1 5\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n1 1 4\\n3 1 4\\n2 1 7\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n1 2 4\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n2 2 4\\n4 3 10\\n1 2 2'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 1 9\\n1 1 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n1 2 2\\n1 2 3\\n3 1 9\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n1 2 2\\n1 2 3\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 6\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 6\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n3 2 13\\n1 3 2'],\n               ['1 1 1\\n1 1 2\\n1 1 4\\n2 1 3\\n3 1 6\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 2 2\\n1 2 3\\n2 1 3\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 2 2\\n1 2 3\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 6\\n3 2 6\\n1 3 4'], ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n2 2 4\\n2 1 7\\n2 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 9\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 4\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n3 1 5\\n4 3 9\\n1 3 5'], ['1 1 1\\n1 2 2\\n1 2 3\\n2 1 3\\n3 1 4\\n2 1 7\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n1 2 3\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n2 2 4\\n1 1 5\\n2 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 4\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n1 2 2\\n1 2 3\\n3 2 13\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 6\\n4 3 9\\n1 1 4'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n1 2 3\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 4\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 2\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n2 2 4\\n4 3 10\\n1 3 4'],\n               ['1 1 1\\n1 1 2\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 9\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n2 1 7\\n1 1 4'], ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n1 2 3\\n3 1 7\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 4\\n3 2 6\\n3 1 5'],\n               ['1 1 1\\n1 2 2\\n1 1 4\\n1 1 4\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 2\\n1 2 2\\n2 1 3\\n3 1 5\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 2\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n3 1 9\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n4 3 12\\n2 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 1 9\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 2\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n3 1 5\\n3 2 6\\n1 3 4'], ['1 1 1\\n1 1 3\\n2 1 3\\n1 1 4\\n3 1 4\\n4 3 9\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n2 2 4\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n1 2 3\\n4 1 8\\n3 1 4'], ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 1 4\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 11\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n1 2 2\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 2\\n2 1 3\\n3 1 5\\n4 3 12\\n1 3 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n3 2 6\\n3 1 5'], ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 9\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 10\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n2 1 3\\n2 1 3\\n1 2 3\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 1 9\\n1 3 4'], ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n3 2 6\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n3 1 4\\n4 3 12\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 3 12\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n4 2 8\\n1 1 4'],\n               ['1 1 1\\n1 1 3\\n1 2 3\\n1 2 2\\n3 1 5\\n4 3 12\\n1 3 2'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n3 2 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n4 3 12\\n1 3 5'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 3\\n2 1 6\\n1 3 5'], ['1 1 1\\n1 1 3\\n1 2 3\\n2 1 3\\n3 1 5\\n3 2 6\\n3 1 4'],\n               ['1 1 1\\n1 1 3\\n1 1 4\\n2 1 3\\n1 2 4\\n4 3 12\\n1 1 4']]\n    for i, test_input in enumerate(inputs):\n        expected_output = outputs[i]\n        found = False\n        for value in expected_output:\n            result = str(candidate(test_input))\n            if result == value:\n                found = True\n                break\n        assert found, f'Test case {i + 1} failed.  Expected {value}, got {result}'\n\n\ncheck(max_robot_moves)"}
{"task_id": 104, "completion": "def minimize_balance(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    idx = 1\n    outputs = []\n\n    for _ in range(t):\n        n, m = map(int, input_lines[idx].split())\n        idx += 2\n        total_fish = 0\n        total_meat = 0\n        dishes = []\n\n        for _ in range(n):\n            a, b = map(int, input_lines[idx].split())\n            idx += 1\n            total_fish += a\n            total_meat += b\n            dishes.append((a, b))\n\n        balance = abs(total_fish - total_meat)\n        outputs.append(str(balance))\n\n        for a, b in dishes:\n            x = min(a, m)\n            y = m - x\n            outputs.append(f\"{x} {y}\")\n\n    return '\\n'.join(outputs)"}
{"task_id": 105, "completion": "def minimize_variety(input_data: str) -> str:\n    lines = input_data.strip().split('\\n')\n    t = int(lines[0])\n    index = 1\n    result = []\n\n    for _ in range(t):\n        n = int(lines[index])\n        index += 1\n        \n        dishes = []\n        for _ in range(n):\n            a, b, m = map(int, lines[index].split())\n            dishes.append((a, b, m))\n            index += 1\n        \n        count = {}\n        output = []\n        for a, b, m in dishes:\n            count[(a, b)] = count.get((a, b), 0) + 1\n        \n        min_variety = n - max(count.values())\n        output.append(str(min_variety))\n\n        for a, b, m in dishes:\n            if a <= m:\n                x = a\n                y = m - a\n            else:\n                x = m\n                y = 0\n            output.append(f\"{x} {y}\")\n\n        result.extend(output)\n    \n    return '\\n'.join(result)"}
{"task_id": 106, "completion": "def generate_sequences(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    idx = 1\n    for _ in range(t):\n        n = int(input_lines[idx])\n        arr = [2]\n        for i in range(1, n):\n            arr.append(arr[-1] + 1)\n        print(*arr)\n        idx += 1"}
{"task_id": 107, "completion": "def find_permutation(input_str: str) -> str:\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    for i in range(1, 2*t+1, 2):\n        n, a, b = map(int, input_lines[i].split())\n        if a + b <= n - 1 and a * 2 + b == n - 2:\n            permutation = [1] * n\n            for j in range(b):\n                permutation[j * 2 + 1] = n - j\n            for j in range(a):\n                permutation[b * 2 + j * 2 + 1] = n - b - 1 - j\n            output.append(' '.join(map(str, permutation)))\n        else:\n            output.append(\"-1\")\n\n    return '\\n'.join(output)"}
{"task_id": 108, "completion": "def can_win_tournament(input_str):\n    input_lines = input_str.strip().split(\"\\n\")\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n\n    output = []\n\n    for _ in range(t):\n        n = int(input_lines.pop(0))\n        a = list(map(int, input_lines.pop(0).split()))\n        b = list(map(int, input_lines.pop(0).split()))\n\n        a_max_strength = max(a)\n        b_max_strength = max(b)\n\n        result = \"\"\n\n        for i in range(n):\n            result += \"1\" if a[i] == a_max_strength or b[i] == b_max_strength else \"0\"\n        \n        output.append(result)\n\n    return \"\\n\".join(output)"}
{"task_id": 109, "completion": "def count_valid_colorings(input_string: str) -> int:\n    modulo = 998244353\n    \n    lines = input_string.strip().split('\\n')\n    n = int(lines[0])\n    \n    count = 1\n    black_cells = 0\n    white_cells = 0\n    \n    for i in range(1, n+1):\n        left_cell, right_cell = lines[i]\n        \n        if left_cell != '?' and right_cell != '?':\n            if left_cell == right_cell:\n                return 0\n            else:\n                black_cells += 1 if left_cell == 'B' else 0\n                white_cells += 1 if left_cell == 'W' else 0\n        elif left_cell == '?' and right_cell == '?':\n            count = (count * 2) % modulo\n            black_cells += 1\n            white_cells += 1\n        else:\n            if left_cell == '?':\n                black_cells += 1 if right_cell == 'B' else 0\n                white_cells += 1 if right_cell == 'W' else 0\n            else:\n                black_cells += 1 if left_cell == 'B' else 0\n                white_cells += 1 if left_cell == 'W' else 0\n    \n    remaining_cells = n - black_cells - white_cells\n    count = (count * pow(2, remaining_cells, modulo)) % modulo\n    \n    return count"}
{"task_id": 110, "completion": "def largest_cells_to_leave(input_str):\n    input_data = input_str.strip().split('\\n')\n    n = int(input_data[0])\n    cells = [list(map(int, line.split())) for line in input_data[1:]]\n\n    color_counts = [0, 0, 0]\n    for cell in cells:\n        color_counts[cell[2] - 1] += 1\n\n    count = min(color_counts)\n    return count * 3\n\n# Test the new solution with the provided sample test cases\nprint(largest_cells_to_leave('9\\n2 3 1\\n4 1 2\\n2 1 3\\n3 4 1\\n5 3 2\\n4 4 3\\n2 4 1\\n5 2 2\\n3 5 3\\n'))  # Output: 6\nprint(largest_cells_to_leave('3\\n1 1 1\\n2 2 2\\n3 3 3\\n'))  # Output: 3"}
{"task_id": 111, "completion": "def count_valid_arrays(input_str: str) -> str:\n    MOD = 998244353\n\n    def MEX(arr):\n        mex = 0\n        while mex in arr:\n            mex += 1\n        return mex\n\n    n, k, *b = map(int, input_str.split())\n\n    dp = [[0] * (2 * k + 1) for _ in range(n + 1)]\n    dp[0][k] = 1\n\n    for i in range(1, n + 1):\n        for j in range(2 * k + 1):\n            dp[i][j] = sum(dp[i-1][j1] for j1 in range(max(0, j - k), min(2 * k + 1, j + k + 1))) % MOD\n\n    result = sum(dp[n]) % MOD\n    return str(result)"}
{"task_id": 112, "completion": "def find_occurrences(input_str):\n    def process_input(input_str):\n        input_lines = input_str.strip().split(\"\\n\")\n        n, m, q = map(int, input_lines[0].split())\n        edges = [tuple(map(int, line.split())) for line in input_lines[1:n+1]]\n        strings = input_lines[n+1:n+m+1]\n        queries = [tuple(map(int, line.split())) for line in input_lines[n+m+1:]]\n        return n, m, q, edges, strings, queries\n    \n    n, m, q, edges, strings, queries = process_input(input_str)\n    \n    tree = defaultdict(list)\n    for u, v, c in edges:\n        tree[u].append((v, c))\n        tree[v].append((u, c))\n    \n    def find_path(tree, u, v):\n        visited = set()\n        parent = {}\n        \n        queue = deque([u])\n        visited.add(u)\n        \n        while queue:\n            node = queue.popleft()\n            for child, _ in tree[node]:\n                if child not in visited:\n                    visited.add(child)\n                    parent[child] = node\n                    queue.append(child)\n                    if child == v:\n                        break\n        \n        path = []\n        while v != u:\n            path.append(tree[v][[i for i, (node, _) in enumerate(tree[v]) if node == parent[v]][0]][1])\n            v = parent[v]\n        \n        return ''.join(path[::-1])\n    \n    result = []\n    for u, v, l, r in queries:\n        path_str = find_path(tree, u, v)\n        count = sum(string[l-1:r].count(path_str) for string in strings)\n        result.append(count)\n    \n    return '\\n'.join(map(str, result))"}
{"task_id": 113, "completion": "def compare_numbers(testcases: str) -> str:\n    testcases_list = testcases.strip().split('\\n')\n    results = []\n    \n    for i in range(1, len(testcases_list), 2):\n        x1, p1 = map(int, testcases_list[i].split())\n        x2, p2 = map(int, testcases_list[i + 1].split())\n        \n        num1 = x1 * 10**p1\n        num2 = x2 * 10**p2\n        \n        if num1 < num2:\n            results.append('<')\n        elif num1 > num2:\n            results.append('>')\n        else:\n            results.append('=')\n    \n    return '\\n'.join(results)"}
{"task_id": 114, "completion": "def find_valid_pairs(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n\n    output = []\n\n    for _ in range(t):\n        n = int(input_lines[0])\n        a = list(map(int, input_lines[1].split()))\n        input_lines = input_lines[2:]\n\n        pairs = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                x, y = a[i], a[j]\n                if (x % y) not in a and (y % x) not in a and x != y:\n                    pairs.add((x, y))\n\n        pairs = list(pairs)[:n // 2]\n\n        output.extend([' '.join(map(str, pair)) for pair in pairs])\n\n    return '\\n'.join(output)"}
{"task_id": 115, "completion": "def minimum_poison_duration(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n, h = map(int, input_lines[index].split())\n        attacks = list(map(int, input_lines[index + 1].split()))\n\n        min_k = float('inf')\n        attacks.sort()\n\n        for i in range(n):\n            k = max(attacks[i] - i, 1)\n            min_k = min(min_k, k)\n\n        results.append(str(min_k))\n        index += 2\n\n    return '\\n'.join(results)"}
{"task_id": 116, "completion": "def count_mex_subsequences(input_string):\n    MOD = 998244353\n\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n\n    def calculate_mex_correct_subsequences(n, array):\n        res = 0\n        curr_mex = 0\n        last = [-1] * (n + 1)\n        dp = [0] * (n + 2)\n\n        for i in range(n):\n            ai = array[i]\n            res = (res + dp[curr_mex]) % MOD\n\n            while curr_mex < n and last[curr_mex] > i:\n                curr_mex += 1\n\n            if curr_mex == ai:\n                curr_mex += 1\n\n            dp_new = [0] * (n + 2)\n            for x in range(curr_mex + 1):\n                dp_new[x] = (dp[x] + (dp[x - 1] if x > 0 else 0)) % MOD\n\n            dp = dp_new\n            last[ai] = i\n\n        res = (res + dp[curr_mex]) % MOD\n        return res\n\n    results = []\n    for i in range(1, 2 * t + 1, 2):\n        n = int(input_lines[i])\n        array = list(map(int, input_lines[i + 1].split()))\n\n        result = calculate_mex_correct_subsequences(n, array)\n        results.append(result)\n\n    return '\\n'.join(map(str, results))"}
{"task_id": 117, "completion": "def force_robot_to_lab(grid_input):\n    def can_force_to_lab(grid, x, y):\n        for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dx, dy = direction\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != '#':\n                if grid[nx][ny] == 'L':\n                    return True\n                nx, ny = nx + dx, ny + dy\n        return False\n\n    testcases = grid_input.splitlines()\n    t = int(testcases[0])\n    results = []\n\n    index = 1\n    for _ in range(t):\n        n, m = map(int, testcases[index].split())\n        grid = [list(row) for row in testcases[index + 1: index + n + 1]]\n\n        lab_x, lab_y = next(((i, j) for i in range(n) for j in range(m) if grid[i][j] == 'L'), None)\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '.' and can_force_to_lab(grid, i, j):\n                    grid[i][j] = '+'\n\n        results.append('\\n'.join([''.join(row) for row in grid]))\n\n        index += n + 1\n\n    return '\\n'.join(results)"}
{"task_id": 118, "completion": "def countBeautifulColorings(input_str):\n    MOD = 998244353\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    edges = [[] for _ in range(n + 1)]\n\n    for i in range(1, n):\n        x, y = map(int, input_lines[i].split())\n        edges[x].append(y)\n        edges[y].append(x)\n        \n    def dfs(node, parent, color):\n        if color == 0:\n            return 0\n        total_ways = 1\n        for child in edges[node]:\n            if child == parent:\n                continue\n            if color - 1 == 0:\n                total_ways *= dfs(child, node, n)\n            else:\n                total_ways *= dfs(child, node, color - 1)\n            total_ways %= MOD\n        return total_ways\n\n    ans = dfs(1, 0, n)\n    return ans\n\n# Test cases\nprint(countBeautifulColorings('5\\n1 2\\n2 3\\n3 4\\n4 5\\n'))  # Output: 53\nprint(countBeautifulColorings('20\\n20 19\\n20 4\\n12 4\\n5 8\\n1 2\\n20 7\\n3 10\\n7 18\\n11 8\\n9 10\\n17 10\\n1 15\\n11 16\\n14 11\\n18 10\\n10 1\\n14 2\\n13 17\\n20 6\\n'))  # Output: 955085064\nprint(countBeautifulColorings('5\\n1 2\\n3 2\\n4 2\\n2 5\\n'))  # Output: 42"}
{"task_id": 119, "completion": "def min_possible_ugliness(input_data):\n    data = input_data.splitlines()\n    t = int(data[0])\n    index = 1\n    for _ in range(t):\n        n = int(data[index])\n        heights = list(map(int, data[index + 1].split()))\n        heights.sort()\n        min_ugliness = heights[-1] - heights[0]\n        print(min_ugliness)\n        index += 2"}
{"task_id": 120, "completion": "def min_elements_to_delete(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    for i in range(1, 2*t+1, 2):\n        l, r = map(int, input_lines[i].split())\n        if l & r:\n            output.append('0')\n        else:\n            pos = 0\n            while l != r:\n                l >>= 1\n                r >>= 1\n                pos += 1\n            output.append(str(2 ** pos))\n\n    return '\\n'.join(output)"}
{"task_id": 121, "completion": "def transform_candles(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    index = 1\n    results = []\n\n    for _ in range(t):\n        n = int(input_lines[index])\n        a = input_lines[index + 1]\n        b = input_lines[index + 2]\n        index += 3\n\n        if a == b:\n            results.append(\"0\")\n            continue\n\n        ones_a = a.count('1')\n        ones_b = b.count('1')\n\n        if ones_a != ones_b and ones_a % 2 != 0:\n            results.append(\"-1\")\n            continue\n\n        operations = 0\n        for i in range(n):\n            if a[i] != b[i]:\n                operations += 1\n                if i + 1 < n:\n                    a = b[:i+1] + a[i+1:]\n\n        results.append(str(operations))\n\n    return '\\n'.join(results)"}
{"task_id": 122, "completion": "def santa_christmas_tree(input_data: str) -> list:\n    def solve_test_case(n, m, edges, assignments):\n        graph = {}\n        for x, y, v in edges:\n            if x not in graph:\n                graph[x] = []\n            if y not in graph:\n                graph[y] = []\n            graph[x].append((y, v))\n            graph[y].append((x, v))\n\n        path_xor = [[None] * (n + 1) for _ in range(n + 1)]\n\n        def dfs(node, parent, xor_val):\n            for neighbor, edge_val in graph[node]:\n                if neighbor != parent:\n                    new_xor_val = xor_val ^ edge_val\n                    path_xor[node][neighbor] = new_xor_val\n                    path_xor[neighbor][node] = new_xor_val\n                    dfs(neighbor, node, new_xor_val)\n\n        def check_consistency(assignments):\n            for a, b, p in assignments:\n                if path_xor[a][b] is None:\n                    continue\n                xor_val = path_xor[a][b]\n                if bin(xor_val).count('1') % 2 != p:\n                    return False\n            return True\n\n        for a, b, _ in assignments:\n            path_xor[a][b] = 0\n            dfs(a, -1, 0)\n\n        if check_consistency(assignments):\n            output = [\"YES\"]\n            result_edges = set()\n            for x in range(1, n + 1):\n                for y, v in graph[x]:\n                    if (x, y) not in result_edges and path_xor[x][y] is not None:\n                        output.append(f\"{x} {y} {path_xor[x][y]}\")\n                        result_edges.add((x, y))\n                        result_edges.add((y, x))\n            return output\n        else:\n            return [\"NO\"]\n\n    cases = input_data.strip().split('\\n')\n\n    num_tests = int(cases[0])\n    case_index = 1\n\n    results = []\n    for _ in range(num_tests):\n        n, m = map(int, cases[case_index].split())\n        case_index += 1\n\n        edges = [list(map(int, cases[case_index + i].split())) for i in range(n - 1)]\n        case_index += n - 1\n\n        assignments = [list(map(int, cases[case_index + i].split())) for i in range(m)]\n        case_index += m\n\n        results.extend(solve_test_case(n, m, edges, assignments))\n\n    return results"}
{"task_id": 123, "completion": "def vandalizing_tree_game(input_str):\n    lines = input_str.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    \n    adj_list = {}\n    for i in range(1, n):\n        u, v = map(int, lines[i].split())\n        if u not in adj_list:\n            adj_list[u] = []\n        if v not in adj_list:\n            adj_list[v] = []\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    result = 0\n    white_nodes = [0] * (n + 1)\n    \n    def dfs(node, parent):\n        nonlocal result\n        nonlocal white_nodes\n        is_red = 1\n        for child in adj_list.get(node, []):\n            if child != parent:\n                is_red &= dfs(child, node)\n        white_nodes[node] = is_red\n        result += is_red\n        return is_red\n    \n    dfs(1, -1)\n    \n    red_nodes = min(k, result)\n\n    def dfs_score(node, parent, red):\n        score = 0\n        for child in adj_list.get(node, []):\n            if child != parent:\n                if red_nodes > red:\n                    score += dfs_score(child, node, red + white_nodes[child])\n                else:\n                    score += white_nodes[child]\n        return score + (red_nodes - red)\n    \n    final_score = n * (result - dfs_score(1, -1, white_nodes[1]))\n\n    return final_score"}
{"task_id": 124, "completion": "def transform_lego_strip(input_str):\n    mod = 1000000007\n\n    def calculate_operations(n, s, t):\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(0, n + 1):\n                dp[i][j] = (2 * dp[i - 1][j]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod\n\n        ans = 0\n        unknown_count_s, unknown_count_t, match_count = 0, 0, 0\n\n        for i in range(n):\n            if s[i] == '?' and t[i] == '?':\n                unknown_count_s += 1\n            elif s[i] == '?' and t[i] != '?':\n                unknown_count_s += 1\n            elif s[i] != '?' and t[i] == '?':\n                unknown_count_t += 1\n            elif s[i] == t[i]:\n                match_count += 1\n\n        for i in range(match_count, n + 1, 2):\n            if i - match_count <= min(unknown_count_s, unknown_count_t):\n                ans = (ans + dp[n][i]) % mod\n\n        return ans\n\n    test_cases = input_str.strip().split('\\n')[1:]\n    result = []\n    for i in range(0, len(test_cases), 3):\n        n = int(test_cases[i])\n        s = test_cases[i + 1]\n        t = test_cases[i + 2]\n        result.append(calculate_operations(n, s, t))\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 125, "completion": "def replace_zeros_with_integers(input_str: str) -> str:\n    lines = input_str.strip().split(\"\\n\")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n\n    res = []\n    num_map = {}\n    count = 1\n\n    for num in arr:\n        if num == 0:\n            while count in num_map:\n                count += 1\n            num_map[count] = True\n            res.append(count)\n        else:\n            res.append(num)\n\n    return ' '.join(map(str, res))"}
{"task_id": 126, "completion": "def adjust_scores(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    scores = list(map(int, input_lines[1].split()))\n\n    requirements = [list(map(int, line.split())) for line in input_lines[2:]]\n\n    for _ in range(max(n, m)):\n        for u, v in requirements:\n            if scores[u - 1] > scores[v - 1]:\n                scores[u - 1] = scores[v - 1]\n\n    return \" \".join(map(str, scores))"}
{"task_id": 127, "completion": "def smallest_non_subsequence(input_string):\n    inputs = input_string.strip().split('\\n')\n    t = int(inputs[0])\n    index = 1\n    result = []\n\n    for _ in range(t):\n        S = inputs[index]\n        T = inputs[index + 1]\n        index += 2\n        \n        char_count = {char: 0 for char in 'abc'}\n        for char in S:\n            if char in 'abc':\n                char_count[char] += 1\n\n        result_str = ''\n        for char in S:\n            if char not in T or char_count[T[0]] > 0:\n                char_count[char] -= 1\n                result_str += char\n        \n        result.append(result_str)\n\n    return '\\n'.join(result)"}
{"task_id": 128, "completion": ""}
{"task_id": 129, "completion": "def min_operations_needed(input_string):\n    def min_operations(n, a):\n        results = []\n        for a_list in a:\n            num_set = set(range(1, n + 1))\n            unique_count = 0\n            for num in a_list:\n                if num in num_set:\n                    num_set.remove(num)\n                else:\n                    unique_count += 1\n            if not num_set:\n                results.append(unique_count)\n            else:\n                results.append(-1)\n        return results\n\n    inputs = input_string.strip().split('\\n')\n    t = int(inputs[0])\n    i = 1\n    test_cases = []\n    for _ in range(t):\n        n = int(inputs[i])\n        a = list(map(int, inputs[i + 1].split()))\n        test_cases.append((n, a))\n        i += 2\n\n    results = min_operations(t, test_cases)\n    \n    return \"\\n\".join(map(str, results))  # Convert results to string for output."}
{"task_id": 130, "completion": "import sys\nimport io\n\ndef find_impostors(input_string: str):\n    def query(a, b, c):\n        print(f\"? {a} {b} {c}\")\n        sys.stdout.flush()\n        return int(input_string.readline().strip())\n    \n    def find_impostor_indices(n):\n        impostors = set()\n        \n        def query_players(a, b, c):\n            return query(a, b, c) == 0\n\n        query(1, 2, 3)\n        \n        for i in range(4, n+1):\n            if query_players(2, 3, i):\n                impostors.add(i)\n            else:\n                query(1, 2, i)\n                impostors.add(1) if query_players(1, 2, i) else impostors.add(2)\n        \n        print(f\"! {len(impostors)} {' '.join(map(str, impostors))}\")\n        sys.stdout.flush()\n\n    test_cases = int(input_string.readline().strip())\n\n    for _ in range(test_cases):\n        n = int(input_string.readline().strip())\n        find_impostor_indices(n)\n\ninput_data = '''2\n6\n0\n1\n9\n1\n'''\nfind_impostors(io.StringIO(input_data))"}
{"task_id": 131, "completion": "def optimum_chocolate_exchange(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    chocolate_types = list(map(int, input_lines[1].split()))\n\n    max_exchanges = 0\n    optimal_x = 1\n    optimal_y = 2\n\n    for x in range(n):\n        for y in range(x + 1, n):\n            exchanges = chocolate_types[x] ^ chocolate_types[y]\n            k = exchanges.bit_length()\n            if (1 << k) == exchanges:\n                if k > max_exchanges:\n                    max_exchanges = k\n                    optimal_x = x + 1\n                    optimal_y = y + 1\n\n    return f\"{optimal_y} {optimal_x} {max_exchanges}\""}
{"task_id": 132, "completion": "def restore_array(input_string: str) -> str:\n    lines = input_string.strip().split(\"\\n\")\n    t = int(lines[0])\n\n    results = []\n    for i in range(1, 2*t+1, 2):\n        b = list(map(int, lines[i].split()))\n        a1 = b[0]\n        a3 = b[-1]\n        a2 = b[1] - a1\n        results.append(f\"{a1} {a2} {a3}\")\n\n    return \"\\n\".join(results)"}
{"task_id": 133, "completion": "def find_missing_word(input_data):\n    testcases = input_data.strip().split('\\n')[1:]\n    results = []\n\n    for i in range(0, len(testcases), 2):\n        n = int(testcases[i])\n        bigrams = testcases[i + 1].split()\n\n        if bigrams[0][0] == bigrams[-1][1]:\n            first_letter = bigrams[0][0]\n            if first_letter == 'a':\n                word = 'a' + 'b' * (n - 1)\n            else:\n                word = 'b' + 'a' * (n - 1)\n        else:\n            if bigrams[0][1] == bigrams[1][0]:\n                first_two = bigrams[0][0] + bigrams[0][1]\n                if first_two == 'ab':\n                    word = 'ab' + ''.join([bigram[1] for bigram in bigrams])\n                else:\n                    word = 'ba' + ''.join([bigram[1] for bigram in bigrams])\n            else:\n                first_two = bigrams[1][0] + bigrams[0][1]\n                if first_two == 'ab':\n                    word = 'ab' + ''.join([bigram[1] for bigram in bigrams])\n                else:\n                    word = 'ba' + ''.join([bigram[1] for bigram in bigrams])\n\n        results.append(word)\n\n    return '\\n'.join(results)"}
{"task_id": 134, "completion": "def beautiful_coloring(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    for i in range(1, 2*t+1, 2):\n        n = int(input_lines[i])\n        elements = list(map(int, input_lines[i+1].split()))\n\n        for d in range(1, max(elements)+1):\n            red = set()\n            blue = set()\n            valid_d = True\n\n            for elem in elements:\n                if elem % d == 0:\n                    if elem in red:\n                        valid_d = False\n                        break\n                    red.add(elem)\n                else:\n                    if elem in blue:\n                        valid_d = False\n                        break\n                    blue.add(elem)\n\n            if valid_d:\n                output.append(str(d))\n                break\n        else:\n            output.append('0')\n\n    return '\\n'.join(output)"}
{"task_id": 135, "completion": "def min_possible_score(input_str):\n    def calculate_score(n, k, a):\n        score = 0\n        a.sort()\n        \n        for i in range(k):\n            score += a.pop(-1) // a.pop(0)\n        \n        return score + sum(a)\n\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n    \n    results = []\n\n    for _ in range(t):\n        n, k = map(int, input_lines.pop(0).split())\n        a = list(map(int, input_lines.pop(0).split()))\n        \n        results.append(calculate_score(n, k, a))\n\n    return \"\\n\".join(map(str, results))"}
{"task_id": 136, "completion": "def reconstruct_repertoire(test_cases_str):\n    test_cases = test_cases_str.strip().split(\"\\n\")\n    result = []\n\n    for i in range(1, len(test_cases), 2):\n        cities = int(test_cases[i])\n        concerts = list(map(int, test_cases[i + 1].split()))\n        total_duration = sum(concerts)\n        a_values = []\n\n        for idx in range(cities):\n            max_duration = max(concerts[idx], (cities - 1) * concerts[idx])\n            possible_a_values = set()\n\n            for a_i in range(1, min(10**9, total_duration) + 1):\n                expected_duration = a_i\n                valid = True\n\n                for k in range(1, cities + 1):\n                    town_index = (idx + k - 1) % cities\n                    expected_duration += a_i * k\n\n                    if expected_duration != concerts[town_index]:\n                        valid = False\n                        break\n\n                if valid:\n                    possible_a_values.add(a_i)\n\n            if len(possible_a_values) == 1:\n                a_values.append(possible_a_values.pop())\n            else:\n                result.append(\"NO\")\n                break\n\n        else:\n            result.append(\"YES\")\n            result.append(\" \".join(str(a) for a in a_values))\n\n    return \"\\n\".join(result)"}
{"task_id": 137, "completion": "def can_turn_into(input_str):\n    x, y = map(int, input_str.split())\n\n    if x == y:\n        return \"YES\"\n\n    while x < y:\n        x_bin = bin(x)[2:]\n        new_x1 = int(x_bin + '0', 2)\n        new_x2 = int(x_bin + '1', 2)\n      \n        if new_x1 <= y and new_x1 >= x:\n            x = new_x1\n        elif new_x2 <= y and new_x2 >= x:\n            x = new_x2\n        else:\n            return \"NO\"\n\n    return \"YES\" if x == y else \"NO\""}
{"task_id": 138, "completion": "def calculate_max_total_cost(input_string: str) -> str:\n    inputs = input_string.strip().split(\"\\n\")\n    n, m, q = map(int, inputs[0].split())\n    a = list(map(int, inputs[1].split()))\n    b = list(map(int, inputs[2].split()))\n    queries = list(map(int, inputs[3].split()))\n\n    a.sort()\n    b.sort()\n\n    result = []\n    for k in queries:\n        total_cost = 0\n        j = 0\n        for i in range(n):\n            while j < m and b[j] <= a[i] + k:\n                j += 1\n            if j > 0:\n                total_cost += b[j - 1]\n                j -= 1\n        result.append(total_cost)\n\n    return \"\\n\".join(map(str, result))"}
{"task_id": 139, "completion": "def check_strings(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    results = []\n\n    for i in range(1, t + 1):\n        s = input_lines[i]\n        if s[:len(s) // 2] == s[len(s) // 2:]:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return '\\n'.join(results) + \"\\n\""}
{"task_id": 140, "completion": "def count_polycarp_numbers(input_string):\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    test_cases = list(map(int, lines[1:]))\n    \n    results = []\n    \n    for n in test_cases:\n        square_root = int(n ** 0.5)\n        cube_root = int(n ** (1/3))\n        \n        square_set = {i ** 2 for i in range(1, square_root + 1) if i ** 2 <= n}\n        cube_set = {i ** 3 for i in range(1, cube_root + 1) if i ** 3 <= n}\n        \n        count = len(square_set.union(cube_set))\n        results.append(str(count))\n    \n    return '\\n'.join(results)"}
{"task_id": 141, "completion": "def find_b(input_string):\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n    test_cases = []\n    for line in input_lines[1:]:\n        a, s = map(int, line.split())\n        test_cases.append((a, s))\n    \n    results = []\n    \n    for a, s in test_cases:\n        current_s = s\n        b = 0\n        multiplier = 1\n\n        while current_s > 0:\n            b_digit = current_s % 10\n            a_digit = a % 10\n\n            if a_digit > b_digit:\n                diff = 10 - (a_digit - b_digit)\n            else:\n                diff = b_digit - a_digit\n                \n            b += diff * multiplier\n            multiplier *= 10\n            current_s //= 10\n            a //= 10\n\n        if a == 0 and b < s:\n            results.append(str(b))\n        else:\n            results.append(\"-1\")\n    \n    return '\\n'.join(results)"}
{"task_id": 142, "completion": "from itertools import combinations\n\ndef maximize_min_joy(input_str):\n    def find_max_min_joy(shops, friends, joy_values):\n        max_min_joy = float('-inf')\n        for shops_to_visit in combinations(range(shops), friends - 1):\n            min_joy_values = [min(joy_values[i][friend] for i in shops_to_visit) for friend in range(friends)]\n            max_min_joy = max(max_min_joy, min(min_joy_values))\n        return max_min_joy\n\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    input_lines = input_lines[1:]\n\n    output = []\n    for _ in range(t):\n        input_lines.pop(0)  # Remove empty line between test cases\n        shops, friends = map(int, input_lines.pop(0).split())\n\n        joy_values = []\n        for _ in range(shops):\n            joy_values.append(list(map(int, input_lines.pop(0).split())))\n\n        output.append(find_max_min_joy(shops, friends, joy_values))\n\n    return '\\n'.join(map(str, output))"}
{"task_id": 143, "completion": "def min_ops_to_mex(t):\n    results = []\n    \n    def compute_min_ops(n, arr):\n        results = [-1] * (n + 1)\n        excess = [0] * (n + 1)\n\n        for num in arr:\n            if num < n:\n                excess[num] += 1\n        \n        mex = 0\n        for i in range(n):\n            if excess[mex] == 0:\n                results[mex] = n - i\n            else:\n                excess[mex] -= 1\n            if mex == num:\n                while mex < n and excess[mex] == 0:\n                    mex += 1\n        \n        results[mex] = 0\n        \n        return results\n    \n    test_cases = t.split('\\n')\n    index = 1\n    \n    for _ in range(int(test_cases[0])):\n        n = int(test_cases[index])\n        arr = list(map(int, test_cases[index + 1].split()))\n        result = compute_min_ops(n, arr)\n        results.append(result)\n        \n        index += 2\n    \n    return results\n\nt = \"5\\n3\\n0 1 3\\n7\\n0 1 2 3 4 3 2\\n4\\n3 0 0 0\\n7\\n4 6 2 3 5 0 5\\n5\\n4 0 1 0 4\\n\"\noutput = min_ops_to_mex(t)\n\nfor result in output:\n    print(*result)"}
{"task_id": 144, "completion": "def fair_game_schedule(input_string: str) -> str:\n    input_lines = input_string.strip().split('\\n')\n    t = int(input_lines[0])\n\n    output = []\n    current_line = 1\n\n    for _ in range(t):\n        n, m, k = map(int, input_lines[current_line].split())\n        current_line += 1\n\n        players = list(range(1, n + 1))\n        b = [0] * n\n\n        for _ in range(k):\n            schedule = [[] for _ in range(m)]\n            num_players = n // (m * k)\n            \n            for i in range(n):\n                table_index = i % m\n                table_size = num_players + 1 if i < m * (num_players + 1) else num_players\n                schedule[table_index].append(players[i])\n                b[players[i] - 1] += 1 if table_size == num_players + 1 else 0\n            \n            output.append('\\n'.join([' '.join(map(str, table)) for table in schedule]))\n        \n        output.append('')\n\n    return '\\n'.join(output)"}
{"task_id": 145, "completion": "def calculate_minimum_detonation(input_data):\n    input_lines = input_data.strip().split('\\n')\n    t = int(input_lines[0])\n    current_line = 1\n    output = []\n\n    for _ in range(t):\n        n, k = map(int, input_lines[current_line].split())\n        current_line += 1\n        mines = [list(map(int, input_lines[i+current_line].split())) for i in range(n)]\n        current_line += n\n\n        detonation_times = set()\n        max_time = 0\n\n        for x, y, time in mines:\n            detonation_times.add((x, y))\n            for i in range(x - k, x + k + 1):\n                detonation_times.add((i, y))\n            for j in range(y - k, y + k + 1):\n                detonation_times.add((x, j))\n\n            max_time = max(max_time, time + k)\n\n        output.append(str(max_time))\n\n    return '\\n'.join(output)"}
{"task_id": 146, "completion": "def permutation_queries(input_string):\n    input_list = input_string.strip().split('\\n')\n    n, q = map(int, input_list[0].split())\n    permutation = list(map(int, input_list[1].split()))\n\n    def swap_elements(x, y):\n        permutation[x - 1], permutation[y - 1] = permutation[y - 1], permutation[x - 1]\n\n    def find_final_value(i, k):\n        idx = i - 1\n        for _ in range(k):\n            idx = permutation[idx] - 1\n        return permutation[idx]\n\n    result = []\n    for query in input_list[2:]:\n        query = list(map(int, query.split()))\n        if query[0] == 1:\n            swap_elements(query[1], query[2])\n        elif query[0] == 2:\n            result.append(find_final_value(query[1], query[2]))\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 147, "completion": "def is_consistent_array(s):\n    count_n = s.count('N')\n    \n    if count_n == 0 or count_n % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"task_id": 148, "completion": "def lattice_triangle_area(testcases):\n    result = []\n    testcases = testcases.strip().split('\\n')\n    t = int(testcases[0])\n    \n    def area(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])))\n\n    for i in range(1, 4*t, 4):\n        w, h = map(int, testcases[i].split())\n        x1, x2 = list(map(int, testcases[i+1].split()[1:])), list(map(int, testcases[i+2].split()[1:]))\n        y1, y2 = list(map(int, testcases[i+3].split()[1:])), list(map(int, testcases[i+4].split()[1:]))\n\n        max_area = 0\n        for xi in x1[1:]:\n            for yj in y1[1:]:\n                area1 = area((0, x1[x1.index(xi)-1]), (0, y1[y1.index(yj)]), (w, xi))\n                area2 = area((w, xi), (w, yj), (0, x1[x1.index(xi)-1]))\n                max_area = max(max_area, area1, area2)\n\n        result.append(max_area)\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 149, "completion": ""}
{"task_id": 150, "completion": "def minimum_coins_needed(input_string: str) -> str:\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    results = []\n    for i in range(1, len(lines), 2):\n        n = int(lines[i])\n        flavors = list(map(int, lines[i+1].split()))\n        \n        min_cost = min(flavors)\n        \n        count_3 = min_cost // 3\n        count_2 = min((min_cost % 3) // 2, 1)\n        count_1 = min_cost % 3 - (count_2 * 2)\n        \n        total_coins = count_3 + count_2 + count_1\n        results.append(total_coins)\n    return '\\n'.join(str(result) for result in results)"}
{"task_id": 151, "completion": "def process_queries(input_str: str) -> str:\n    lines = input_str.strip().split('\\n')\n    q = int(lines[0])\n    queries = lines[1:]\n    array = []\n\n    for query in queries:\n        if query.startswith('1'):\n            array.append(query.split()[1])\n        else:\n            x, y = query.split()[1:]\n            array = [y if elem == x else elem for elem in array]\n\n    return ' '.join(array)"}
{"task_id": 152, "completion": "def solve_bipartite_array(input_str: str) -> str:\n    output = []\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])\n    index = 1\n\n    for _ in range(t):\n        n = int(lines[index])\n        p = list(map(int, lines[index + 1].split()))\n        \n        a = [0] * n\n        current = 0\n        \n        for i in range(n):\n            if current + 1 < p[i]:\n                current = p[i] - 1\n            else:\n                current = p[i] - 1\n                p[i] = -p[i]\n                \n            a[i] = p[i]\n\n        if all(a[i] < a[i + 1] for i in range(n - 1)):\n            output.append(\"YES\")\n            output.append(' '.join(map(str, a)))\n        else:\n            output.append(\"NO\")\n\n        index += 2\n\n    return '\\n'.join(output)"}
{"task_id": 153, "completion": "MOD = 998244353\n\ndef calculate_xor_value(n, strings):\n    XOR_RESULT_MOD = 998244353\n    result_xor = 0\n\n    def calculate_function_value(s):\n        ans = 0\n        chars = set()\n\n        for char in s:\n            temp = set()\n            temp.add(char)\n\n            for c in chars:\n                temp.add(c + char)\n\n            chars = chars.union(temp)\n            ans += len(chars)\n\n        return (ans * len(s)) % XOR_RESULT_MOD\n\n    for bitmask in range(1 << n):\n        curr_s = \"\"\n\n        for i in range(n):\n            if bitmask & (1 << i):\n                curr_s += strings[i]\n\n        result_xor ^= calculate_function_value(curr_s)\n\n    return result_xor\n\n"}
{"task_id": 154, "completion": "def check_rectangle_possible(testcases):\n    return [\"YES\" if l1 + l2 == l3 or l1 + l3 == l2 or l2 + l3 == l1 else \"NO\" for l1, l2, l3 in testcases]"}
{"task_id": 155, "completion": "def reevaluate_ratings(input_str):\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    output = []\n\n    curr_line = 1\n    for _ in range(t):\n        n = int(input_lines[curr_line])\n        p = list(map(int, input_lines[curr_line + 1].split()))\n        s = input_lines[curr_line + 2]\n\n        liked_songs = [p[i] for i in range(n) if s[i] == '1']\n        disliked_songs = [p[i] for i in range(n) if s[i] == '0']\n\n        liked_songs.sort(reverse=True)\n        disliked_songs.sort(reverse=True)\n\n        ratings = [0] * n\n        idx_like, idx_dislike = 0, 0\n\n        for i in range(n):\n            if s[i] == '1':\n                ratings[i] = liked_songs[idx_like]\n                idx_like += 1\n            else:\n                ratings[i] = disliked_songs[idx_dislike]\n                idx_dislike += 1\n\n        output.append(' '.join(map(str, ratings)))\n\n        curr_line += 3\n\n    return '\\n'.join(output)"}
{"task_id": 156, "completion": "def min_steps_to_reach_sum(t):\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        \n        current_sum = sum(arr)\n        excess_sum = max(current_sum - k, 0)\n        if excess_sum == 0:\n            results.append(0)\n            continue\n        \n        total_steps = 0\n        for num in arr:\n            if excess_sum >= num:\n                excess_sum -= num\n                total_steps += num\n            else:\n                total_steps += excess_sum\n                break\n        \n        results.append(total_steps)\n    \n    return results\n\n# Input reading and function call\n"}
{"task_id": 157, "completion": "def count_distinct_strings(input_string: str) -> str:\n    MOD = 998244353\n\n    n, k, s = map(str, input_string.strip().split('\\n'))\n    n, k = map(int, n.split())\n    s = s.strip()\n\n    def choose(n: int, r: int) -> int:\n        res = 1\n        for i in range(1, r + 1):\n            res = (res * (n - i + 1) // i) % MOD\n        return res\n\n    count = 0\n    if k == 0:\n        return '1\\n'\n\n    for i in range(n):\n        ones_count = s[i:].count('1')\n        if ones_count == k:\n            count += choose(ones_count, k)\n\n    count %= MOD\n    return str(count) + '\\n'"}
{"task_id": 158, "completion": "from itertools import permutations\n\n\ndef find_maximum_surprise(input_string):\n    input_lines = input_string.strip().split('\\n')\n\n    t = int(input_lines[0])\n    result = []\n    idx = 1\n\n    def calculate_surprise_value(n, m, x, answers):\n        max_surprise_value = 0\n        max_permutation = []\n        for permutation in permutations(range(1, m + 1)):\n            surprise_value = 0\n            for i in range(n):\n                points = sum(permutation[j - 1] for j in range(1, m + 1) if answers[i][j - 1] == '1')\n                surprise_value += abs(x[i] - points)\n            if surprise_value > max_surprise_value:\n                max_surprise_value = surprise_value\n                max_permutation = permutation\n        return max_permutation\n\n    for _ in range(t):\n        n, m = map(int, input_lines[idx].split())\n        idx += 1\n        x = list(map(int, input_lines[idx].split()))\n        idx += 1\n        answers = input_lines[idx: idx + n]\n        idx += n\n        result.append(' '.join(map(str, calculate_surprise_value(n, m, x, answers))))\n\n    return '\\n'.join(result)"}
{"task_id": 159, "completion": "from math import factorial, isqrt\n\ndef find_quadratic_subset(n):\n    def is_quadratic(num):\n        return isqrt(num) ** 2 == num\n\n    max_subset_size = 0\n    quadratic_subset = set()\n\n    for i in range(1, n + 1):\n        product = 1\n        subset = set()\n\n        for j in range(1, i + 1):\n            product *= factorial(j)\n            subset.add(j)\n\n            if is_quadratic(product):\n                if len(subset) > max_subset_size:\n                    max_subset_size = len(subset)\n                    quadratic_subset = subset.copy()\n\n    return max_subset_size, quadratic_subset\n\n"}
{"task_id": 160, "completion": "def time_to_clean(test_cases_str):\n    test_cases = test_cases_str.strip().split('\\n')\n    results = []\n    \n    for test_case in test_cases:\n        n, m, r_b, c_b, r_d, c_d = map(int, test_case.split())\n        \n        row_diff = abs(r_b - r_d)\n        col_diff = abs(c_b - c_d)\n\n        if r_b == r_d or c_b == c_d:\n            results.append(str(max(row_diff, col_diff)))\n        else:\n            results.append(str(min(row_diff, col_diff) + abs(row_diff - col_diff)))\n\n    return '\\n'.join(results)"}
{"task_id": 161, "completion": "def find_bob_picked_number(input_string):\n    def calculate_midpoint(l, r):\n        return (r - l + 1) // 2 + l\n\n    output = []\n\n    test_cases = input_string.split(\"\\n\")\n    t = int(test_cases[0].strip())\n    idx = 1\n\n    for _ in range(t):\n        n = int(test_cases[idx])\n        idx += 1\n\n        ranges = []\n        range_map = {}\n\n        for _ in range(n):\n            l, r = map(int, test_cases[idx].split())\n            ranges.append([l, r])\n            idx += 1\n\n        range_set = [[1, n]]\n\n        for l, r in reversed(ranges):\n            d = calculate_midpoint(l, r)\n            range_map[(l, r)] = d\n            \n            new_ranges = []\n            if l <= d - 1:\n                new_ranges.append([l, d - 1])\n            if d + 1 <= r:\n                new_ranges.append([d + 1, r])\n            \n            range_set.remove([l, r])\n            range_set.extend(new_ranges)\n\n        for l, r in ranges:\n            output.append(f\"{l} {r} {range_map[(l, r)]}\")\n\n    return \"\\n\".join(output)"}
{"task_id": 162, "completion": "def max_stones_smallest_heap(test_cases_str):\n    test_cases = test_cases_str.strip().split('\\n')\n    results = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        heaps = list(map(int, test_cases[i + 1].split()))\n\n        min_heap = min(heaps[0], heaps[1])\n        for j in range(2, n):\n            max_moves = min(heaps[j] // 3, min(heaps[j], min_heap * 2) // 2)\n            heaps[j] -= 3 * max_moves\n            heaps[j - 1] += max_moves\n            heaps[j - 2] += 2 * max_moves\n            min_heap = min(min_heap, heaps[j - 1], heaps[j - 2])\n\n        results.append(str(min_heap))\n\n    return '\\n'.join(results)"}
{"task_id": 163, "completion": "def expected_time_to_clean(t: str):\n    MOD = 10 ** 9 + 7\n\n    def expected_time(n, m, r_b, c_b, r_d, c_d, p):\n        def inverse_mod(a):\n            m0, x0, x1 = MOD, 0, 1\n            while a > 1:\n                q = a // MOD\n                MOD, a = a % MOD, MOD\n                x0, x1 = x1 - q * x0, x0\n            return x1 + m0 if x1 < 0 else x1\n\n        def get_initial_distance():\n            return abs(r_d - r_b) + abs(c_d - c_b)\n\n        initial_distance = get_initial_distance()\n        if initial_distance == 0:\n            return 0\n\n        prob = p / 100\n        time_same = inverse_mod(prob)\n        time_other = pow(2, MOD - 2, MOD) * (n + m - 2) % MOD\n\n        if r_b == r_d or c_b == c_d:\n            return (time_same - 1) % MOD\n\n        return (time_same + time_other) % MOD\n\n    results = []\n    for _ in range(t):\n        n, m, r_b, c_b, r_d, c_d, p = map(int, t.split())\n        result = expected_time(n, m, r_b, c_b, r_d, c_d, p)\n        results.append(result)\n\n    return results"}
{"task_id": 164, "completion": "def smallest_string_representation(s):\n    n, k, c, tree = s\n    adj_list = [[] for _ in range(n + 1)]\n    for i, (l, r) in enumerate(tree, 1):\n        if l != 0:\n            adj_list[i].append(l)\n        if r != 0:\n            adj_list[i].append(r)\n\n    def in_order_traversal(u):\n        if u == 0:\n            return []\n        left = in_order_traversal(tree[u - 1][0])\n        right = in_order_traversal(tree[u - 1][1])\n        return left + [c[u - 1]] + right\n\n    result = in_order_traversal(1)\n\n    duplicates_allowed = k\n    q = [[1, 0]]\n    while q:\n        u, parent_repeat = q.pop()\n        if parent_repeat:\n            if duplicates_allowed > 0:\n                duplicates_allowed -= 1\n                result[u - 1] *= 2\n\n        for v in adj_list[u]:\n            q.append([v, parent_repeat or result[u - 1] == 2 * c[u - 1]])\n\n    return \"\".join(result).strip()\n\n# Test cases\ntest_cases = [{'input': '4 3\\nabab\\n2 3\\n0 0\\n0 4\\n0 0\\n', 'output': 'baaaab'},\n              {'input': '8 3\\nkdaracyn\\n2 5\\n0 3\\n0 4\\n0 0\\n6 8\\n0 7\\n0 0\\n0 0\\n', 'output': 'darkcyan'},\n              {'input': '8 2\\nkadracyn\\n2 5\\n3 4\\n0 0\\n0 0\\n6 8\\n0 7\\n0 0\\n0 0\\n', 'output': 'daarkkcyan'}]\n\nfor test in test_cases:\n    input_lines = test['input'].strip().split('\\n')\n    n, k = map(int, input_lines[0].split())\n    c = input_lines[1]\n    tree = [tuple(map(int, line.split())) for line in input_lines[2:]]\n    output = smallest_string_representation((n, k, c, tree))\n    assert output == test['output']\n\nprint(\"All test cases pass\")"}
