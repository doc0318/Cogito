{"task_id": "9ce37bc2d361f5bb8a0568fb479b8a38", "completion": "def maximum_removal(s):\n    n = len(s)\n    position = [0]*26\n    is_used = [False]*26\n    arr = [0]*26\n    last_pos = [-1]*26\n    next_pos = [-1]*n\n    prev_pos = [-1]*n\n    \n    for i in range(n):\n        arr[i] = ord(s[i]) - ord('a')\n        \n    for i in range(n-1, -1, -1):\n        if last_pos[arr[i]] != -1:\n            prev_pos[last_pos[arr[i]]] = i\n        next_pos[i] = last_pos[arr[i]]\n        last_pos[arr[i]] = i\n        \n    for i in range(25, -1, -1):\n        if last_pos[i] != -1 and (i == 0 or last_pos[i-1] != -1):\n            position[i] = last_pos[i]\n            \n    ans = 0\n    for i in range(26):\n        k = position[i]\n        while k != -1:\n            if (k > 0 and arr[k-1] == i-1) or (next_pos[k] != -1 and arr[next_pos[k]] == i-1):\n                is_used[k] = True\n                ans += 1\n                if k > 0 and arr[k-1] == i:\n                    is_used[k-1] = True\n                if next_pos[k] != -1 and arr[next_pos[k]] == i:\n                    is_used[next_pos[k]] = True\n            k = prev_pos[k]\n    \n    return n - ans\n\n"}
{"task_id": "8de14db41d0acee116bd5d8079cb2b02", "completion": "def min_chars_to_remove(filename):\n    count = 0\n    consecutive_x = 0 \n    \n    for char in filename:\n        if char == 'x':\n            consecutive_x += 1\n        else:\n            consecutive_x = 0\n\n        if consecutive_x >= 3:\n            count += 1\n\n    return count"}
{"task_id": "d0a8604b78ba19ab769fd1ec90a72e4e", "completion": "def nth_smallest_suitable_number(n):\n    return str(2*int(n) + 1)\n"}
{"task_id": "711d15e11016d0164fb2b0c3756e4857", "completion": "def chainword_instances(input_string):\n    inputs_list = input_string.strip().split('\\n')\n    n, m = map(int, inputs_list[0].split())\n    words = inputs_list[1:]\n    \n    mod = 998244353\n    lengths = [len(word) for word in words]\n    f = [0] * 2010\n    s = [0] * 2010\n    f[0] = 1\n    \n    for length in lengths:\n        for j in range(2000, -1, -1):\n            if f[j] != 0:\n                f[j + length] = (f[j + length] + f[j]) % mod\n            if s[j] != 0:\n                s[j + length] = (s[j + length] + s[j]) % mod\n        \n        for j in range(length * 2, 2000, -1):\n            if f[j - length] != 0:\n                s[j] = (s[j] + f[j - length]) % mod\n            \n        for j in range(length, 2000 - length + 1):\n            if f[j] != 0:\n                f[j + length] = (f[j + length] + f[j]) % mod\n                \n    for i in range(2000, -1, -1):\n        if f[i] != 0:\n            s[i] = (s[i] + f[i]) % mod\n\n    return str(s[m] % mod)\n"}
{"task_id": "788ed59a964264bd0e755e155a37e14d", "completion": "def min_maps_to_study(input_str: str) -> str:\n    N, P = list(map(float, input_str.split()))\n    N = int(N)\n    if N <= 2:\n        return '0'\n    if P == 1.0:\n        return str(N - 1)\n    if P == 0.0:\n        return '0'\n\n    low = 1\n    high = N - 1\n\n    while low <= high:\n        mid = low + (high - low) // 2\n        if ((3 * mid - 2) / ((3 * N - 2) ** 2) + (mid / (3 * N - 2)) >= P):\n            if (mid == low or ((3 * (mid - 1) - 2) / ((3 * N - 2) ** 2) + ((mid - 1) / (3 * N - 2)) < P)):\n                return str(mid)\n            high = mid - 1\n        else:\n            low = mid + 1\n    return 'Impossible'"}
{"task_id": "ad014bde729222db14f38caa521e4167", "completion": "def solve(input: str) -> int:\n    n, m, q, *lst = map(int, input.split())\n    p_org, p_cur = lst[:n], lst[:n]\n    edges = [sorted(lst[i * 2 + n:i * 2 + n + 2]) for i in range(m)]\n    del_edge_queries = []\n    for i in range(q):\n        typ, num = lst[m * 2 + i * 2:m * 2 + i * 2 + 2]\n        if typ == 1:\n            v = num - 1\n            for edge in edges:\n                if edge and v in edge:\n                    v = edge[1 - edge.index(v)]\n            w = p_org.index(max(p_org[i] for i in edges[v] if p_cur[i] != 0))\n            p_cur[w], p_org[w] = 0, 0\n            print(p_cur[w])\n        else:\n            del edges[num - 1]\n"}
{"task_id": "24e2f10463f440affccc2755f4462d8a", "completion": "def count_valid_permutations_from_string(input_string):\n    n, x, pos = map(int, input_string.split(' '))\n    MOD = 10 ** 9 + 7\n\n    def factorial(num):\n        result = 1\n        for i in range(2, num + 1):\n            result = (result * i) % MOD\n        return result\n\n    left, right = 0, n\n    count = 1\n    smaller, larger = x - 1, n - x\n\n    while left < right:\n        mid = (left + right) // 2\n        if mid < pos:\n            count = (count * smaller) % MOD\n            smaller -= 1\n            left = mid + 1\n        elif mid > pos:\n            count = (count * larger) % MOD\n            larger -= 1\n            right = mid\n        else:\n            left = mid + 1\n\n    count = (count * factorial(smaller + larger)) % MOD\n    return count"}
{"task_id": "9812de5f2d272511a63ead8765b23190", "completion": "def sum_of_madnesses(input):\n    n, m, p = map(int, input.split())\n    fac = [0 for _ in range(m+10)]\n    ifac = [0 for _ in range(m+10)]\n    fac[0] = ifac[0] = ifac[1] = 1\n    for i in range(1, m+10):\n        fac[i] = fac[i-1]*i%p \n    for i in range(2, m+10):\n        ifac[i] = (p-p//i) * ifac[p%i] % p\n    for i in range(2, m+10):\n        ifac[i] = ifac[i-1]*ifac[i]%p\n    def comb(n, r):\n        if r>n or r<0:\n            return 0\n        return fac[n] * ifac[r] % p * ifac[n-r] %p\n    DP1 = [0 for _ in range(m+1)]\n    DP2 = [0 for _ in range(m+1)]\n    DP3 = [0 for _ in range(m+1)]\n    DP1[0] = DP2[0] = DP3[0] = 1\n    for i in range(1, m+1):\n        DP1[i] = DP1[i-1]*(n-i+1)%p\n        DP2[i] = DP2[i-1]*pow(i, p-2, p)%p\n        DP3[i] = DP1[i]*DP2[i]%p\n    DP = [0 for _ in range(m+1)]\n    tmp = [0 for _ in range(m+1)]\n    ans1, ans2 = 0, 0\n    DP[0] = 1\n    for i in range(1, m+1):\n        DP[i] = (DP[i-1] + DP3[i-1]*(n-i+1))%p\n        tmp[i] = (tmp[i-1] + DP3[i-1]*comb(n, i-1))%p \n    for i in range(m):\n        ans1 = (ans1+tmp[n-i])%p\n        ans2 = (ans2 + tmp[m-i]*DP[n-i])%p\n        DP[n-i] = (DP[n-i] + p - DP3[n-i])%p\n        tmp[n-i] = (tmp[n-i] + p - DP3[n-i]*comb(n, n-i))%p\n    return (ans1+ans2)%p\n"}
{"task_id": "19a0c05eb2d1559ccfe60e210c6fcd6a", "completion": "from collections import deque, defaultdict\n\ndef Bertown_navigation(input_string):\n    # Parse the input\n    int_lines = input_string.strip().split('\\n')\n    n, m = map(int, int_lines[0].split())\n    edges = []\n    for i in range(1, m+1):\n        u, v = map(int, int_lines[i].split())\n        edges.append((u-1, v-1))\n\n    path_length = int(int_lines[m+1])\n    path = list(map(int, int_lines[m+2].split()))\n\n    # Generate Graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[v].append(u)\n\n    # Breadth First Search\n    q = deque([path[-1] - 1])\n    d = [0] * n\n    Next = [0] * n\n    used = [0] * n\n    used[path[-1] - 1] = 1\n\n    while q:\n        v = q.popleft()\n        for to in graph[v]:\n            if not used[to]:\n                used[to] = 1\n                d[to] = d[v] + 1\n                q.append(to)\n            if d[to] == d[v] + 1:\n                Next[to] += 1\n\n    # Calculate the minimum and maximum rebuilds\n    mn = mx = 0\n    for i in range(path_length - 1):\n        if d[path[i] - 1] != d[path[i + 1] - 1] + 1:\n            mn += 1\n            mx += 1\n        elif Next[path[i] - 1] > 1:\n            mx += 1\n\n    # Return the result as a string\n    return '{} {}'.format(mn, mx)\n"}
{"task_id": "dc466d9c24b7dcb37c0e99337b4124d2", "completion": "MOD = 10**9+7\ndef calculate(nk):\n    n, k = map(int, nk.split())\n    inv = [0]*(n+1)\n    for i in range(1, n+1):\n        if i == 1: \n            inv[i] = 1\n        else: \n            inv[i] = (MOD - (MOD//i) * inv[MOD%i] % MOD) % MOD\n    dp = [0]*(n+2)\n    dp[n] = 1\n    for _ in range(k):\n        for i in range(n, 0, -1):\n            dp[i//2] = (dp[i//2] + dp[i] * inv[2]) % MOD\n    ans = 0\n    for i in range(1, n+1):\n        ans = (ans + i * dp[i]) % MOD\n    return ans\n"}
{"task_id": "04610fbaa746c083dda30e21fa6e1a0c", "completion": "def product_formula(input_str):\n    MOD = 10**9 + 7\n    x, n = map(int, input_str.split())\n\n    def prime_factors(n):\n        i = 2\n        factors = set()\n        while i * i <= n:\n            if n % i:\n               i += 1\n            else:\n               n //= i\n               factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n\n    def binary_exponentiation(x, n):\n        if n == 0:\n            return 1\n        elif n % 2 == 1:\n            return (x * binary_exponentiation(x, n - 1)) % MOD\n        else:\n            tmp = binary_exponentiation(x, n // 2)\n            return (tmp * tmp) % MOD\n\n    primes = prime_factors(x)\n    result = 1\n    for prime in primes:\n        exponent = 0\n        div = prime\n        while div <= n:\n            exponent += n // div\n            div *= prime\n        result = (result * binary_exponentiation(prime, exponent)) % MOD\n    return str(result)\n"}
{"task_id": "11e6559cfb71b8f6ca88242094b17a2b", "completion": "from collections import defaultdict\n\ndef solve_dominoes(domino_string):\n    inputs = list(map(int, domino_string.split()))\n    n, m = inputs[0], inputs[1]\n    edges = [(inputs[i], inputs[i+1]) for i in range(2, len(inputs), 2)]\n    graph = defaultdict(set)\n    degree = [0] * (n+1)\n\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n        degree[u] += 1\n        degree[v] += 1\n\n    ans = m\n    visited = [0 for _ in range(n+1)]\n    stack = []\n\n    def solve(u, p):\n        nonlocal ans\n        visited[u] = 1\n        stack.append(u)\n\n        for v in graph[u]:\n            if v == p:\n                continue\n            if visited[v] == 1:\n                ret = 7\n                while stack and stack[-1] != v:\n                    ret = min(ret, degree[stack[-1]])\n                    stack.pop()\n                ans = min(ans, ret + m - len(stack))\n                continue\n\n            solve(v, u)\n        \n        if stack and stack[-1] == u: \n            stack.pop()\n            \n    for i in range(1, n+1):\n        if not visited[i]:\n            solve(i, 0)\n\n    return str(ans)\n"}
{"task_id": "3ff1c25a1026c90aeb14d148d7fb96ba", "completion": "import math\n\ndef find_pair(r):\n    r = int(r)\n    for x in range(1, int(math.sqrt(r)) + 1):\n        numerator = r - x**2 - x - 1\n        if numerator > 0 and numerator % (2 * x) == 0:\n            y = numerator // (2 * x)\n            return f\"{x} {y}\"  \n    return \"NO\""}
{"task_id": "1bd29d7a8793c22e81a1f6fd3991307a", "completion": "def min_triangulation(n):\n    n = int(n)\n    # dp[i][j] will store the minimum triangulation weight of the subpolygon from vertex i to vertex j\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Iterate over the length of the subpolygons\n    for length in range(3, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            dp[i][j] = float('inf')  # Initialize to a large number\n            # Try every possible 'k' to split the polygon into two parts\n            for k in range(i + 1, j):\n                # Only update dp[i][j] if we find a smaller triangulation weight\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n\n    # The result will be the minimum weight triangulation of the entire polygon (from vertex 1 to vertex n)\n    return dp[1][n]"}
{"task_id": "42f25d492bddc12d3d89d39315d63cb9", "completion": "def max_bourles(data):\n    data = list(map(int, data.split()))\n    n, m, r = data[0], data[1], data[2]\n    buy = sorted(data[3:3+n])\n    sell = sorted(data[3+n:], reverse=True)\n\n    if sell[0] > buy[0]:\n        stocks = r // buy[0]\n        r -= stocks * buy[0]\n        r += stocks * sell[0]\n\n    return str(r)\n"}
{"task_id": "c9e79e83928d5d034123ebc3b2f5e064", "completion": "def calc_total_length(input_string):\n    MOD = 998244353\n    inv = [0, 1]\n    fac = [1, 1]\n    ifac = [1, 1]\n    \n    for i in range(2, 4040):\n        inv.append((MOD - MOD // i) * inv[MOD % i] % MOD)\n        fac.append(fac[-1] * i % MOD)\n        ifac.append(ifac[-1] * inv[i] % MOD)\n    \n    def C(n, k):\n        if k > n or k < 0: \n            return 0\n        return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD\n    \n    def solve(x, n, m, k):        \n        ans = 0\n        for i in range(k):\n            ans = (ans + C(n, i) * C(m + n - i - 1, n - 1) % MOD) % MOD\n        return (C(m + n, n) - ans) % MOD\n    \n    x, n, k = map(int, input_string.strip().split())\n    m = x * 2\n    ans = 0\n    for i in range(1, m + 1):\n        ans = (ans + (m - i + 1) * (solve(i - 1, n, m - i, k) - solve(i, n, m - i + 1, k - 1) % MOD) % MOD) % MOD\n    ans = ans * fac[n] % MOD * pow(fac[2] * fac[n] % MOD, MOD - 2, MOD) % MOD\n    return str(ans)\n"}
{"task_id": "ce8350be138ce2061349d7f9224a5aaf", "completion": "def count_queries(inp):\n  inputs = [list(map(int, x.split())) for x in inp.split('\\n')]\n  num_segments = inputs[0][0]\n  segments = inputs[1:]\n  \n  points_covered = []\n  \n  for segment in segments:\n    for i in range(segment[0], segment[1] + 1):\n      if i not in points_covered:\n        points_covered.append(i)\n        \n  return str(len(points_covered) - 1)\n\nprint(count_queries('2 4\\n1 2\\n3 4'))  # Expected output: '4'\nprint(count_queries('4 6\\n1 3\\n2 3\\n4 6\\n5 6'))  # Expected output: '5'\n\ndef count_queries(inp):\n  inputs = [list(map(int, x.split())) for x in inp.split('\\n')]\n  num_segments = inputs[0][0]\n  segments = inputs[1:]\n  \n  points_covered = []\n  \n  for segment in segments:\n    for i in range(segment[0], segment[1] + 1):\n      if i not in points_covered:\n        points_covered.append(i)\n        \n  return str(len(points_covered))\n"}
{"task_id": "f8af5dfcf841a7f105ac4c144eb51319", "completion": "def min_layers(N):\n    N = int(N)\n    layers = 0\n    for length in range(1, N + 1):\n        segments = length\n        layers += (segments + 1) // 2\n    return layers\n\nprint(min_layers('2'))  # Outputs: 1\nprint(min_layers('3'))  # Outputs: 2\nprint(min_layers('4'))  # Outputs: 2\n"}
{"task_id": "4b9f470e5889da29affae6376f6c9f6a", "completion": ""}
{"task_id": "838f2e75fdff0f13f002c0dfff0b2e8d", "completion": "def xorangles(n):\n    n = int(n)\n    count = 0  \n    for a in range(1, n + 1):\n        for b in range(a, n + 1):  \n            c = a ^ b\n            if b <= c <= n and a + b > c:\n                count += 1\n    return str(count)\n\nprint(xorangles('6'))  # prints: 1\nprint(xorangles('10'))  # prints: 2\n"}
{"task_id": "5e74750f44142624e6da41d4b35beb9a", "completion": "def even_odd_game(n):\n    if int(n) % 2 == 0:\n        return 'Mahmoud'\n    else:\n        return 'Ehab'\n\n"}
{"task_id": "236177ff30dafe68295b5d33dc501828", "completion": "def pizza_cuts(n):\n    n = int(n)\n    if n % 2 == 0:\n        return str(n // 2 + 1)\n    else:\n        return str(n)\n"}
{"task_id": "d37dde5841116352c9b37538631d0b15", "completion": "import math\n\ndef good_pairs(input_string):\n\n    l, r, x, y = map(int, input_string.split(' '))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    if y % x != 0:\n        return 0\n\n    q = y // x\n    count = 0\n\n    for d in range(1, int(math.sqrt(q)) + 1):\n        if q % d == 0:\n            cd = q // d\n            if gcd(d, cd) == 1:\n                a, b = x * d, x * cd\n                if l <= a <= r and l <= b <= r:\n                    count += 2 if d != cd else 1\n    return count\n"}
{"task_id": "a40e78a7144ac2fae1890ac7598990bf", "completion": "def solve(input_string):\n    mod = 998244353\n    input_list = list(map(int,input_string.strip().split()))\n    n = input_list[0]\n    G = [[] for _ in range(n+1)]\n    dp1, dp2 = [1]*(n+1), [0]*(n+1)\n    for i in range(1, len(input_list), 2):\n        u, v = input_list[i], input_list[i+1]\n        G[u].append(v)\n        G[v].append(u)\n    dfs_order = [0]\n    parent = [0]*(n+1)\n    def dfs(v, p):\n        parent[v] = p\n        for u in G[v]:\n            if u == p: continue\n            dfs_order.append(u)\n            dfs(u, v)\n    dfs(1, 0)\n    for v in dfs_order[::-1]:\n        p = parent[v]\n        total, total2 = 0, 0\n        for u in G[v]:\n            if u == p: continue\n            total2 = (total2 + total*dp2[u]%mod - dp1[u]*dp2[u]%mod + mod) % mod\n            total = (total + dp1[u]) % mod\n        dp1[v] = (dp2[v] + total2 + 1) % mod\n        dp2[v] = total\n    return str((dp1[1] + dp2[1]) % mod)\n"}
{"task_id": "0034806908c9794086736a2d07fc654c", "completion": ""}
{"task_id": "3dc56bc08606a39dd9ca40a43c452f09", "completion": "def min_time_to_make_triangle(s):\n    a, b, c = sorted(map(int, s.split()))\n    if a + b > c:\n        return '0'\n    else:\n        return str(c - a - b + 1)"}
{"task_id": "609195ef4a970c62a8210dafe118580e", "completion": "def winning_probability(input_string):\n    p, s, r = map(int, input_string.split())\n    mod = 998244353\n    inv = [1, 1]\n    factorial = [1, 1]\n    inv_factorial = [1, 1]\n    for i in range(2, 3010):\n        inv.append((mod - (mod // i) * inv[mod % i] % mod) % mod)\n        factorial.append(factorial[-1] * i % mod)\n        inv_factorial.append(inv_factorial[-1] * inv[i] % mod)\n    dp = [0] * (s + 1)\n    dp[0] = 1\n    for i in range(1, r):\n        for j in range(s, i - 1, -1):\n            dp[j] = (dp[j] + dp[j - i] * inv_factorial[i]) % mod\n    dp2 = [0] * (s + 1)\n    for i in range(s - r + 1):\n        dp2[i] = dp[i]\n    for i in range(s - r + 1, s + 1):\n        dp2[i] = (dp2[i - 1] + dp[i] * inv_factorial[p]) % mod\n    answer = 0\n    for i in range(max(0, s - p + 1), r):\n        x = dp2[s - i - 1] if s - i - 1 >= 0 else 0\n        y = inv_factorial[p - 1] if i < r else 0\n        answer += ((dp[i] - x + mod) % mod * factorial[s - i + p - 1] % mod * y) % mod\n    return str(answer % mod)\n"}
{"task_id": "8909ac99ed4ab2ee4d681ec864c7831e", "completion": "def cyclic_shifts(s):\n    unique_shifts = set()\n\n    for i in range(len(s)):\n        shifted_string = s[i:] + s[:i]\n        unique_shifts.add(shifted_string)\n\n    return len(unique_shifts)"}
{"task_id": "ceb3807aaffef60bcdbcc9a17a1391be", "completion": "def can_give_out_all_balloons(input_string):\n    n_k, s = input_string.strip().split('\\n')\n    n, k = map(int, n_k.split())\n    color_count = [0]*26\n    for i in range(n):\n        color = ord(s[i]) - ord('a')\n        color_count[color] += 1\n    for count in color_count:\n        if count > k:\n            return 'NO'\n    return 'YES'\n"}
{"task_id": "24fd5cd218f65d4ffb7c5b97b725293e", "completion": "MOD = 998244353\ndef floral_beauty(n: str) -> str:\n    n = int(n)\n    a, b, c, d = 0, 2, 2, 2\n\n    for _ in range(3, n + 1):\n        x = (d + b) % MOD\n        y = (2 * d + b) % MOD\n        z = (2 * x + 2 * y - a) % MOD\n        a, b, c, d= b, c, d, z\n        \n    return str((d*2)%MOD)\n"}
{"task_id": "2b8c2deb5d7e49e8e3ededabfd4427db", "completion": "def can_be_divided(input_string):\n\n    lines = input_string.strip().split('\\n')\n    n = int(lines[0].strip())  # First line contains the value of n\n    sequence = list(map(int, lines[1].strip().split()))  # Second line contains the sequence\n\n    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1 and n % 2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n"}
{"task_id": "82a4a60eac90765fb62f2a77d2305c01", "completion": "def max_compote_fruits(s):\n    a,b,c = map(int, s.split())\n    while a * 2 > b or a * 4 > c:\n        a -= 1\n    return str(a + a * 2 + a * 4)\n"}
{"task_id": "f52af273954798a4ae38a1378bfbf77a", "completion": "import math\n\ndef size_of_display(n):\n    n = int(n)\n    a = int(math.sqrt(n))\n    while n % a != 0:\n        a -= 1\n    b=n//a\n    return  \"{} {}\".format(a, b)\n\n"}
{"task_id": "78d013b01497053b8e321fe7b6ce3760", "completion": "def min_price(s):\n    n, c1, c2, p = map(int, s.split())\n    adults = len([1 for a in str(p) if a=='1'])\n    rec = [10**18]*(n+1)\n    rec[0] = 0\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            if j <= adults:\n                rec[i] = min(rec[i], rec[i-j]+c1+c2*(j-1)*(j-1))\n    return str(rec[n])\n\nprint(min_price('3 4 1 011'))  # prints: 8\nprint(min_price('4 7 2 1101')) # prints: 18\n"}
{"task_id": "7853e03d520cd71571a6079cdfc4c4b0", "completion": "def shell_game(input_string):\n    n, x = map(int, input_string.split('\\n'))\n    position = [1, 0, 0, 1, 1, 0]\n    return str(position[n % 6]) if x == 1 else str((n % 2) + 1)\n"}
{"task_id": "d82278932881e3aa997086c909f29051", "completion": "def is_quasi_palindromic(x):\n    # Strip trailing zeros\n    x_without_zeros = x.rstrip('0')\n\n    # Check if the string without trailing zeros is palindromic\n    return \"YES\" if x_without_zeros == x_without_zeros[::-1] else \"NO\"\n"}
{"task_id": "ab8a2070ea758d118b3c09ee165d9517", "completion": "def more_flights_s2f(nights):\n    s = 0\n    f = 0\n    for i in range(len(nights)-1):\n        if nights[i] == 'S' and nights[i+1] == 'F':\n            s += 1\n        elif nights[i] == 'F' and nights[i+1] == 'S':\n            f += 1\n    if s > f:\n        return 'YES'\n    else:\n        return 'NO'\n"}
{"task_id": "3a0c1b6d710fd8f0b6daf420255d76ee", "completion": "def find_pretty_integer(s):\n    list1, list2 = sorted(s.split(\"\\n\")[0].split()), sorted(s.split(\"\\n\")[1].split())\n    min1, min2 = min(list1), min(list2)\n    if min1 < min2:\n        return min1 + min2\n    elif min2 < min1:\n        return min2 + min1\n    else:\n        return min1\n\nprint(find_pretty_integer('2\\n3\\n4\\n2\\n5 7 6'))  # Output: \"25\"\nprint(find_pretty_integer('8 8\\n1 2 3 4 5 6 7 8\\n8 7 6 5 4 3 2 1'))   # Output: \"1\"\n"}
{"task_id": "68ca8a8730db27ac2230f9fe9b120f5f", "completion": "def golden_age(input_string):\n    x, y, l, r = map(int, input_string.split())\n\n    # Generate all unlucky years in the given interval [l, r]\n    unlucky_years = set()\n    i = 1\n    while i <= r:\n        j = 1\n        while i + j <= r:\n            if i + j >= l:\n                unlucky_years.add(i + j)\n            if y > r // j:  # Avoid overflow and unnecessary iterations\n                break\n            j *= y\n        if x > r // i:  # Avoid overflow and unnecessary iterations\n            break\n        i *= x\n\n    # Convert the set to a sorted list and handle edge cases by adding l-1 and r+1\n    unlucky_years = sorted(list(unlucky_years) + [l - 1, r + 1])\n\n    # Find the maximum interval between consecutive unlucky years (golden age)\n    max_golden_age = 0\n    for i in range(1, len(unlucky_years)):\n        max_golden_age = max(max_golden_age, unlucky_years[i] - unlucky_years[i - 1] - 1)\n\n    return str(max_golden_age)\n\nprint(golden_age(\"2 3 1 10\"))\nprint(golden_age(\"3 5 10 22\"))\nprint(golden_age(\"2 3 3 5\"))\n"}
{"task_id": "1c80040104e06c9f24abfcfe654a851f", "completion": "def can_reach_treasure(challenge):\n    x1, y1, x2, y2, x, y = map(int, challenge.split())\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    if dx % x == 0 and dy % y == 0 and (dx // x) % 2 == (dy // y) % 2:\n        return 'YES'\n    return 'NO'"}
{"task_id": "9300f1c07dd36e0cf7e6cb7911df4cf2", "completion": "def max_bananas(s):\n\n    m, b = map(int, s.split())\n    max_bananas_collected = 0\n\n\n    for y in range(b + 1):\n        x = m * (b - y)\n        bananas = ((x + 1) * x // 2) * (y + 1) + ((y + 1) * y // 2) * (x + 1)\n        max_bananas_collected = max(max_bananas_collected, bananas)\n\n    return str(max_bananas_collected)\n\nprint(max_bananas('1 5'))  # Expected output: '30'\nprint(max_bananas('2 3'))  # Expected output: '25'\n"}
{"task_id": "7bf30ceb24b66d91382e97767f9feeb6", "completion": "def factorial_GCD(input_string):\n    def factorial(n):\n        return 1 if n<2 else n*factorial(n-1) \n\n    A, B = map(int, input_string.split())\n    return str(factorial(min(A, B)))\n"}
{"task_id": "0644605611a2cd10ab3a9f12f18d7ae4", "completion": "def faulty_permutations(input_string):\n    n, k = map(int, input_string.split())\n    mod = 10**9+7\n    factorial = [1]*(n+1)\n    dp = [0]*(n+1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n+1):\n        factorial[i] = factorial[i-1]*i % mod\n        dp[i] = (dp[i-1] + (i-1)*dp[i-2] % mod) % mod\n\n    answer = factorial[n]\n\n    if k <= n:\n        for i in range(k, n):\n            subtracted = factorial[n]\n            subtracted *= pow(factorial[i], mod-2, mod)\n            subtracted *= pow(factorial[n-i], mod-2, mod)\n            subtracted *= dp[i]\n            subtracted %= mod\n            answer = (answer + mod - subtracted) % mod\n\n    return str(answer)\n"}
{"task_id": "b9fa2bb8001bd064ede531a5281cfd8a", "completion": "def max_commands(s):\n    u = d = l = r = 0\n    for command in s:\n        if command == 'U':\n            u += 1\n        elif command == 'D':\n            d += 1\n        elif command == 'L':\n            l += 1\n        elif command == 'R':\n            r += 1\n    return 2 * min(u, d) + 2 * min(l, r)\n\nprint(max_commands('LDUR'))  # Output: 4\nprint(max_commands('RRRUU'))  # Output: 0\nprint(max_commands('LLRRRR'))  # Output: 4\n"}
{"task_id": "d3a8a3e69a55936ee33aedd66e5b7f4a", "completion": "def max_modulo_subsequence(input_string):\n    arr, m = map(int,input_string.split()[0:2])\n    nums = [int(i) for i in input_string.split()[2:]]\n    prefix = [0] * (m + 1)\n    prefix[0] = 0\n\n    for num in nums:\n        new_prefix = prefix[:]\n        for i in range(m):\n            new_prefix[(i+num) % m] = max(new_prefix[(i+num) % m], num + prefix[i])\n        prefix = new_prefix\n\n    return str(max(prefix))\n\nprint(max_modulo_subsequence('4 4\\n5 2 4 1'))  # Outputs: 3\nprint(max_modulo_subsequence('3 20\\n199 41 299'))  # Outputs: 9\n"}
{"task_id": "698da80c7d24252b57cca4e4f0ca7031", "completion": "def min_steps(s):\n    r, x, y, x1, y1 = map(int, s.split())\n    dx, dy = x1 - x, y1 - y\n    dist = ((dx * dx + dy * dy) ** 0.5)\n    return max(-(-dist // (2 * r)), 1) if dist != 0 else 0\n\nsolution = min_steps('2 0 0 0 4') # It should return: 1\nprint(solution)\nsolution = min_steps('1 1 1 4 4') # It should return: 2\nprint(solution)\nsolution = min_steps('4 5 6 5 6') # It should return: 0\nprint(solution)\n"}
{"task_id": "60dbfc7a65702ae8bd4a587db1e06398", "completion": "def max_factorial_number(a):\n    number_mapping = {'0': '', '1': '', '2': '2', '3': '3', '4': '322', '5': '5', '6': '53', '7': '7', '8': '7222', '9': '7332'}\n\n    result = ''\n\n    for digit in a:\n        result += number_mapping[digit]\n\n    return ''.join(sorted(result, reverse=True))\n"}
{"task_id": "e03c6d3bb8cf9119530668765691a346", "completion": "def solve(nk):\n    n, k = map(int, nk.split())\n    answer = [i+1 for i in range(k-1)]\n    answer += [i for i in range(n, k-1, -1)]\n    return \" \".join(map(str, answer))\n"}
{"task_id": "185ff90a8b0ae0e2b75605f772589410", "completion": "def num_of_ways(s):\n    a, b, c, l = map(int, s.split())\n    total_ways = (l + 1) * (l + 2) * (l + 3) // 6 \n\n \n    for i in range(l + 1):\n        max_increase_a = min(l - i, a - b - c + i)\n        if max_increase_a >= 0:\n            total_ways -= (max_increase_a + 1) * (max_increase_a + 2) // 2\n\n\n    for i in range(l + 1):\n        max_increase_b = min(l - i, b - c - a + i)\n        if max_increase_b >= 0:\n            total_ways -= (max_increase_b + 1) * (max_increase_b + 2) // 2\n\n\n    for i in range(l + 1):\n        max_increase_c = min(l - i, c - a - b + i)\n        if max_increase_c >= 0:\n            total_ways -= (max_increase_c + 1) * (max_increase_c + 2) // 2\n\n    return str(total_ways)"}
{"task_id": "775766790e91e539c1cfaa5030e5b955", "completion": "def sock_days(a, b):\n    different_colored_socks_days = min(a, b)\n    same_colored_socks_days = (max(a, b) - different_colored_socks_days) // 2\n    return different_colored_socks_days, same_colored_socks_days\n"}
{"task_id": "bf8a133154745e64a547de6f31ddc884", "completion": "def min_bitcoins(s):\n    HP_Y, ATK_Y, DEF_Y, HP_M, ATK_M, DEF_M, P_HP, P_ATK, P_DEF = map(int, s.replace('\\n', ' ').split())\n    \n    _max = float('inf')\n    \n    for Y_ATK in range(1, max(ATK_M * 2, ATK_Y) + 1):\n        for Y_DEF in range(max(DEF_Y, ATK_M), ATK_M * 2 + 1):\n            if Y_ATK > DEF_M:\n                Y_HP = HP_Y\n            else:\n                Y_HP = max(HP_Y, ((ATK_M - Y_DEF) + 1) * ((HP_M // (Y_ATK - DEF_M)) + 2))\n            _max = min(_max, ((Y_HP - HP_Y) * P_HP) + ((Y_ATK - ATK_Y) * P_ATK) + ((Y_DEF - DEF_Y) * P_DEF))\n\n    return str(_max)\n"}
{"task_id": "52e07d176aa1d370788f94ee2e61df93", "completion": "def chess_winner(n):\n    n = int(n)\n    if n % 2 == 0:\n        return \"white\\n1 2\"\n    else:\n        return \"black\"\n"}
{"task_id": "1f68bd6f8b40e45a5bd360b03a264ef4", "completion": "def cancel_code(A):\n    A = int(A)\n    count = 0\n    for x in range(1, A*2):\n        if sum(i for i in range(1, x+1) if x % i == 0) == A:\n            count += 1\n    return str(count)\n"}
{"task_id": "d6c876a84c7b92141710be5d76536eab", "completion": "def can_choose_balls(input_str):\n    input_str = input_str.split()\n    balls = list(map(int, input_str))\n    balls.sort()\n    for i in range(0,len(balls)-2):\n        if balls[i+2] - balls[i] <= 2:\n            return 'YES'\n    return 'NO'\n\nprint(can_choose_balls('18 55 16 17'))  # Output: 'YES'\nprint(can_choose_balls('40 41 43 44 44 44'))  # Output: 'NO'\nprint(can_choose_balls('5 972 3 4 1 4 970 971'))  # Output: 'YES'\n"}
{"task_id": "1c4cf1c3cb464a483511a8a61f8685a7", "completion": "import re\n\ndef count_buses(input_str):\n    a, ta, b, tb, h, m = map(int, re.findall(r'\\d+', input_str))  # Use raw string (r'') for regex\n    start_time = h * 60 + m\n    departure_time_a = 5 * 60\n    end_time_a = departure_time_a + ta\n    departure_time_b = departure_time_a\n    end_time_b = 1440\n    bus_count = 0\n    while departure_time_b < end_time_b:\n        if max(start_time, departure_time_b) < min(start_time + ta, departure_time_b + tb):\n            bus_count += 1\n        departure_time_b += b\n    return str(bus_count)\n"}
{"task_id": "7bffa6e8d2d21bbb3b7f4aec109b3319", "completion": "def min_distance(input_string):\n    positions = sorted(list(map(int, input_string.split())))\n    return str(positions[2] - positions[0])\n"}
{"task_id": "069d0cb9b7c798a81007fb5b63fa0f45", "completion": "def time_to_lunch(seat):\n    row, pos = int(seat[:-1]), seat[-1]\n    row_cycle = (row + 1) // 2\n    total_time = row_cycle * 7 * 6 # 7 seconds per serving cycle and 6 passengers in a row\n    if row % 2 == 0:\n        total_time -= 6 # Subtract the serving time for one whole row if the row number is odd\n    position_time = {'f': 1, 'e': 2, 'd': 3, 'a': 4, 'b': 5, 'c': 6}[pos] # Time due to seat position in the row\n    return total_time + position_time\n"}
{"task_id": "581f61b1f50313bf4c75833cefd4d022", "completion": "from math import comb\n\ndef calc_binary(r):\n    if r == -1:\n        return 0\n    b = bin(r+1)[2:]\n    ret = 0\n    for i in range(len(b)):\n        if b[i] == '1':\n            ret += comb(len(b)-i-1, i+1)\n    return ret\n\ndef years_with_one_zero(s):\n    l , r = map(int, s.strip().split())\n    return str(calc_binary(r) - calc_binary(l-1))\n"}
{"task_id": "757cd804aba01dc4bc108cb0722f68dc", "completion": "def final_state_of_slimes(n):\n    n = int(n)\n    slimes = []\n    for i in range(n):\n        slimes.append(1)\n        while len(slimes) > 1 and slimes[-1] == slimes[-2]:\n            slimes[-2] += 1\n            slimes.pop()\n    return ' '.join(map(str, slimes))\n"}
{"task_id": "3c4b2d1c9440515bc3002eddd2b89f6f", "completion": "def max_string(input_string):\n    n_and_a = input_string.split()\n    n, a = int(n_and_a[0]), list(map(int, n_and_a[1:]))\n\n    a.sort(reverse=True)\n\n    max_length = 0\n    prev_occurrence = float('inf')\n\n    for occ in a:\n        if occ < prev_occurrence:\n            prev_occurrence = occ\n        else:\n            if prev_occurrence > 1:\n                prev_occurrence -= 1\n            else:\n                break\n        max_length += prev_occurrence\n\n    return max_length"}
{"task_id": "3d3432b4f7c6a3b901161fa24b415b14", "completion": "def max_games(n):\n    n = int(n)\n    players = [1, 2]\n   \n    while n > players[-1]:\n        players.append(players[-1] + players[-2])\n        \n    if n == players[-1]:\n        return len(players) - 1\n   \n    return len(players) - 2 + (n >= players[-2] + players[-3])\n"}
{"task_id": "7bd5521531950e2de9a7b0904353184d", "completion": "def count_possible_routes(commands):\n    x, y = 0, 0\n    visited = {(0, 0): 1}\n    total_routes = 0\n    command_map = {'U': (0, 1), 'R': (1, 0), 'D': (0, -1), 'L': (-1, 0)}\n\n    for command in commands:\n        dx, dy = command_map[command]\n        x += dx\n        y += dy\n\n        if (x, y) in visited:\n            total_routes += visited[(x, y)]\n            visited[(x, y)] += 1\n        else:\n            visited[(x, y)] = 1\n\n    return total_routes\n"}
{"task_id": "18410980789b14c128dd6adfa501aea5", "completion": "def number_of_ordered_pairs(n):\n    s, x = map(int, n.split())\n\n    if s < x or (s + x) % 2 != 0:\n        return '0'\n\n    a_and_b = (s - x) // 2\n\n    if a_and_b & x != 0:\n        return '0'\n\n\n    count = 1\n    original_x = x  \n\n\n    while x > 0:\n        if x % 2 == 1:\n            count *= 2  \n        x //= 2\n\n    if s == original_x:\n        count -= 2\n\n    return str(count)\n\nprint(number_of_ordered_pairs('9 5'))  # '4'\nprint(number_of_ordered_pairs('3 3'))  # '2'\nprint(number_of_ordered_pairs('5 2'))  # '0'\n"}
{"task_id": "4fb83b890e472f86045981e1743ddaac", "completion": "def find_best_grade(s):\n    from collections import deque\n    lines = s.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    a = [0] + list(map(int, lines[1].split()))\n    edges = [tuple(map(int, x.split())) for x in lines[2:]]\n    g = [[] for _ in range(n+1)] \n    grade = float('inf')\n    for u,v in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for root in range(1, n+1):  \n        visited = [0]*(n+1)\n        visited[root] = 1\n        effort = [0]*(n+1)\n        effort[root] = a[root]\n        stack = deque([root])\n        while stack: \n            node = stack[-1]\n            if g[node]:\n                next_node = g[node].pop()\n                if not visited[next_node]:\n                    stack.append(next_node)\n                    visited[next_node] = 1\n                    effort[next_node] = max(effort[node], a[next_node])\n            else:\n                stack.pop()\n        effort.sort()\n        grade = min(grade, effort[k])\n    return str(grade)\n\nprint(find_best_grade('4 2\\n1 5 5 5\\n1 2\\n1 3\\n1 4'))  # Output: '1'\nprint(find_best_grade('5 3\\n3 6 1 4 2\\n1 2\\n2 4\\n2 5\\n1 3'))  # Output: '3'\n"}
{"task_id": "f1b43baa14d4c262ba616d892525dfde", "completion": "def max_offices(n_str):\n    n = int(n_str)\n    return str(2 * (2**n - 1))\n"}
{"task_id": "509db9cb6156b692557ba874a09f150e", "completion": "def min_turns(degree):\n    degree = degree % 360\n    turns = [abs(degree - 90 * i % 360) if abs(degree - 90 * i % 360) <= 180 else 360 - abs(degree - 90 * i % 360) for i in range(4)]\n    return str(turns.index(min(turns)))\n"}
{"task_id": "cfe19131644e5925e32084a581e23286", "completion": "def table_variants(nk):\n    n, k = map(int, nk.strip().split())\n    MOD = 777777777\n\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    dp[0][0] = 1\n\n    for i in range(1,n+1):\n        dp[i][0] = dp[i-1][0]\n\n        for j in range(1, i+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n\n    ways = [[0]*(n+1) for _ in range(n+1)]\n    ways[0][0] = 1\n\n    for x in range(1, n+1):\n        for y in range(x+1):\n            for z in range(x-y+1):\n                ways[x][y] += ways[x-z][y] * dp[n-x+z][z] % MOD\n                ways[x][y] %= MOD\n\n    result = 0\n    for i in range(n-k+1):\n        result += ways[n][i] * dp[n][k] % MOD\n        result %= MOD\n\n    return str(result)\n"}
{"task_id": "656ed7b1b80de84d65a253e5d14d62a9", "completion": "import sys\nfrom math import factorial as fact\n\nmod = 10 ** 9 + 7\n\ndef combinations(n, k):\n    return fact(n) // (fact(k) * fact(n - k))\n\ndef calc(n, f, m):\n    if f == 0:\n        return combinations(n + m - 1, n - 1)\n    else:\n        return sum([(-1) ** i * combinations(m, i) * combinations(n + m - 1 - i * f, n - 1) % mod\n                    for i in range(m // f + 1)])\n\ndef election_results(m_input):\n    m = int(m_input.strip())\n    dp = [[[0 for _ in range(9)] for _ in range(9)] for _ in range(9)]\n    dp[0][0][0] = 1\n\n    for d in range(8):\n        for a in range(9):\n            for b in range(a + 1):\n                if dp[d][a][b] == 0:\n                    continue\n                cnt = dp[d][a][b]\n                for na in range(10):\n                    if na in [4, 7]:\n                        nb = min(a + 1, 8)\n                    else:\n                        nb = a\n                    dp[d + 1][nb][b] = (dp[d + 1][nb][b] + cnt * calc(8 - nb, nb - b, d)) % mod\n\n    result = 0\n    for a in range(9):\n        for b in range(a):\n            result = (result + dp[8][a][b]) % mod\n\n    return str(result)\n"}
{"task_id": "c03b6379e9d186874ac3d97c6968fbd0", "completion": "MOD = 10 ** 9 + 7\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = result * x % MOD\n        x = x * x % MOD\n        y //= 2\n    return result\n\ndef inverse(x):\n    return power(x, MOD - 2)\n\ndef multiply(x, y):\n    return x * y % MOD\n\ndef combination(n, r):\n    if r > n or r < 0:\n        return 0\n    r = min(r, n - r)\n    result = 1\n    for i in range(r):\n        result = multiply(result, n - i)\n        result = multiply(result, inverse(i + 1))\n    return result\n\ndef count_winning_pairs(input_str):\n    N, M = map(int, input_str.split())\n      \n    dp = [[0 for _ in range(N + 1)] for _ in range(M + 1)]\n    dp[0][0] = 1\n    for m in range(1, M + 1):\n        dp[m][0] = 2 * dp[m - 1][0] % MOD\n        for n in range(1, min(m, N) + 1):\n            dp[m][n] = (2 * dp[m - 1][n] + dp[m - 1][n - 1]) % MOD\n    result = 0\n    for n in range(N + 1):\n        result = (result + combination(N, n) * dp[M][n]) % MOD\n    return str(result)\n"}
{"task_id": "83bcfe32db302fbae18e8a95d89cf411", "completion": "def min_splitters(nk):\n    n, k = map(int, nk.split())\n    total_pipes = k*(k+1)//2\n    if n > total_pipes + 1:\n        return \"-1\"\n    elif n <= k + 1:\n        return \"1\"\n    else:\n        n -= 1\n        left, right = 1, k\n        while left < right:\n            mid = (left + right) // 2\n            if mid * (mid + 1) // 2 >= n:\n                right = mid\n            else:\n                left = mid + 1\n        return str(left)\n\n    print(min_splitters('4 3'))  # Returns '2'\n    print(min_splitters('5 5'))  # Returns '1'\n    print(min_splitters('8 4'))  # Returns '-1'\n"}
{"task_id": "d3c10d1b1a17ad018359e2dab80d2b82", "completion": "def safe_variants(hint):\n    digits = list(range(10))\n    letters = []\n    total = 1\n\n    for val in hint:\n        if val.isalpha() and val not in letters:\n            letters.append(val)\n\n    for idx, val in enumerate(hint):\n        if val == \"?\":\n            total *= 9 if idx == 0 else 10\n        elif val.isalpha():\n            total *= digits.pop() if letters.index(val) == 0 and hint[0].isalpha() else digits.pop(-1)\n\n    return str(total)\n"}
{"task_id": "1f0e8bbd5bf4fcdea927fbb505a8949b", "completion": "def minimum_moves(inputString):\n    n, m, *a = map(int, inputString.split())\n    d = {i: [] for i in range(1, max(a)+1)}\n    for i in range(n):\n        for j in range(m):\n            d[a[i*m+j]].append((i, j))\n    res = 0\n    for v in d.values():\n        v.sort()\n        x0, y0 = v[len(v)//2]\n        res += sum(abs(x - x0) + abs(y - y0) for x, y in v)\n    return str(res)\n\nprint(minimum_moves('2 3 1 1 2 2 3 3')) #Output: 2\nprint(minimum_moves('3 4 1 3 2 6 2 1 5 6 4 4 5 3')) #Output: 4\n"}
{"task_id": "9b543e07e805fe1dd8fa869d5d7c8b99", "completion": "def max_number_of_ones(string):\n    numbers = list(map(int, string.split()))\n    count_of_ones = numbers.count(1)\n    max_value, current_value = 0, 0\n\n    for i in numbers:\n        current_value = max(0, current_value + (1 if i == 0 else -1))\n        max_value = max(max_value, current_value)\n\n    return str(count_of_ones + max_value)\n\nprint(max_number_of_ones(\"1 0 0 1 0\"))  # Outputs: 4\nprint(max_number_of_ones(\"1 0 0 1\"))  # Outputs: 4\n"}
{"task_id": "f3c96123334534056f26b96f90886807", "completion": "def valid_set(s):\n    points = list(map(int, s.split()))\n    points = [(points[i], points[i + 1]) for i in range(0, len(points), 2)]\n\n    x_coords = set(point[0] for point in points)\n    y_coords = set(point[1] for point in points)\n\n    if len(x_coords) != 3 or len(y_coords) != 3:\n        return \"ugly\"\n\n\n    x_sorted = sorted(x_coords)\n    y_sorted = sorted(y_coords)\n\n\n    all_points = {(x, y) for x in x_sorted for y in y_sorted}\n    all_points.remove((x_sorted[1], y_sorted[1]))\n\n    return \"respectable\" if set(points) == all_points else \"ugly\""}
{"task_id": "c7aa8a95d5f8832015853cffa1374c48", "completion": "def find_bricks_painted_twice(code):\n    from math import gcd\n    x, y, a, b = map(int, code.split())\n    lcm = (x*y)//gcd(x,y)\n    return str((b//lcm) - ((a-1)//lcm))\n\n"}
{"task_id": "b3b986fddc3770fed64b878fa42ab1bc", "completion": "ddef solve(input_str):\n    a, b, c = map(int, input_str.split())\n    if (a + b + c) % 2 != 0:\n        return \"Impossible\"\n    if a > b + c or b > a + c or c > a + b:\n        return \"Impossible\"\n    ab = (a + b - c) // 2\n    bc = (b + c - a) // 2\n    ca = (c + a - b) // 2\n    return f\"{ab} {bc} {ca}\"\n\nprint(solve([1, 1, 2]))  # Outputs: \"Possible\"\nprint(solve([3, 4, 5]))  # Outputs: \"Possible\"\nprint(solve([4, 1, 1]))  # Outputs: \"Impossible\"\n"}
{"task_id": "391c2abbe862139733fcb997ba1629b8", "completion": "def longest_common_subsequence(input_string):\n    s1, s2, virus = input_string.split('\\n')\n    \n    len1, len2, lenv = len(s1), len(s2), len(virus)\n\n    # Create the dp and path tables to store intermediate results\n    dp = [[[0] * (lenv + 1) for _ in range(len2 + 1)] for _ in range(len1 + 1)]\n    path = [[[None] * (lenv + 1) for _ in range(len2 + 1)] for _ in range(len1 + 1)]\n\n    # Fill the dp and path tables based on the conditions\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                for k in range(lenv + 1):\n                    if k < lenv and s1[i - 1] == virus[k]:\n                        if dp[i - 1][j - 1][k] + 1 > dp[i - 1][j - 1][k + 1]:\n                            dp[i][j][k + 1] = dp[i - 1][j - 1][k] + 1\n                            path[i][j][k + 1] = s1[i - 1]\n                        else:\n                            dp[i][j][k + 1] = dp[i - 1][j - 1][k + 1]\n                            path[i][j][k + 1] = path[i - 1][j - 1][k + 1]\n                    elif k == lenv:\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k])\n                        path[i][j][k] = path[i - 1][j][k] if dp[i - 1][j][k] > dp[i][j - 1][k] else path[i][j - 1][k]\n                    else:\n                        dp[i][j][k] = dp[i - 1][j - 1][k] + 1\n                        path[i][j][k] = path[i - 1][j - 1][k] + s1[i - 1]\n            else:\n                for k in range(lenv + 1):\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k])\n                    path[i][j][k] = path[i - 1][j][k] if dp[i - 1][j][k] > dp[i][j - 1][k] else path[i][j - 1][k]\n\n    # Find the max value in the dp table for the last row and column\n    k = dp[len1][len2].index(max(dp[len1][len2]))\n    \n    # Return the corresponding path or '0' if no valid subsequence\n    return path[len1][len2][k] if path[len1][len2][k] else '0'\n"}
{"task_id": "f40900973f4ebeb6fdafd75ebe4e9601", "completion": "def min_bracket_cost(s):\n    inputs = list(map(int, s.split()))\n    n, m = inputs[0], inputs[1]\n    a = inputs[2:2+n]\n    b = inputs[2+n:2+2*n]\n    MOD = 10**9 + 7\n    dp = [[0]*(2*n+1) for _ in range(2*n+1)]\n    inf = float('inf')\n    dp[0][0] = 0\n    for i in range(2*n):\n        for j in range(i+1):\n            if i-j <= j:\n                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + a[i%n])\n            if i >= j:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j+1] + b[i%n])\n    return min(dp[n*i][n]*(i<=m) + dp[n*2][n]*(i<=m-1) for i in range(1, m+2)) % MOD\n"}
{"task_id": "7dbf58806db185f0fe70c00b60973f4b", "completion": "def minimum_moves(input_string):\n    r1, c1, r2, c2 = map(int, input_string.split())\n\n    rook_moves = 1 if r1 == r2 or c1 == c2 else 2\n\n    if (r1 + c1) % 2 != (r2 + c2) % 2:\n        bishop_moves = 0\n    elif abs(r1 - r2) == abs(c1 - c2):\n        bishop_moves = 1\n    else:\n        bishop_moves = 2\n\n    king_moves = abs(r1 - r2) if abs(r1 - r2) > abs(c1 - c2) else abs(c1 - c2)\n\n    return f\"{rook_moves} {bishop_moves} {king_moves}\""}
{"task_id": "5fdaf8ee7763cb5815f49c0c38398f16", "completion": "def can_press_all_panels(input_string):\n    lines = input_string.strip().split('\\n')\n    k = int(lines[0])\n    panel_layout = [list(line) for line in lines[1:]]\n    timing_counts = {str(i): 0 for i in range(1, 10)}\n\n    for row in panel_layout:\n        for panel in row:\n            if panel != '.':\n                timing_counts[panel] += 1\n\n    for count in timing_counts.values():\n        if count > 2 * k:\n            return \"NO\"\n    return \"YES\""}
{"task_id": "ee9fa8be2ae05a4e831a4f608c0cc785", "completion": "def bear_bush_position(input_str):\n    n, sx, sy, dx, dy, t = map(int, input_str.split())\n    sx -= 1\n    sy -= 1\n    dx %= n\n    dy %= n\n    direction = [(0, 0), (0, 1), (1, 0), (-1, 0), (0, -1)]\n    move = [(dx, dy), (1, 1), (1, -1), (-1, -1), (-1, 1)]\n    for _ in range(t):\n        new_move = [0, 0]\n        for i in range(5):\n            new_sx = (sx + direction[i][0] + n) % n\n            new_sy = (sy + direction[i][1] + n) % n\n            new_dx = (dx + move[i][0]) % n\n            new_dy = (dy + move[i][1]) % n\n            if new_sx + new_dx + 2 > new_move[0] + new_move[1]:\n                new_move = [new_dx, new_dy]  \n                sx, sy = new_sx, new_sy\n        dx, dy = new_move\n    sx += 1\n    sy += 1\n    return f'{sx} {sy}'\n"}
{"task_id": "8b26ca1ca2b28166c3d25dceb1f3d49f", "completion": "def minimum_insertions(DNA):\n    counter, insertions = 1, 0   # change here \n    current_char = DNA[0]\n\n    for i in range(1, len(DNA)):  # iterate from the 2nd character\n        if DNA[i] == current_char:\n            counter += 1\n        else:\n            if counter % 2 == 0:\n                insertions += 1\n            current_char = DNA[i]\n            counter = 1  \n\n    if counter % 2 == 0:\n        insertions += 1     \n\n    return insertions\n\nprint(minimum_insertions(\"GTTAAAG\"))  # Expected output is 1\nprint(minimum_insertions(\"AACCAACCAAAAC\"))  # Expected output is 5\n"}
{"task_id": "a2616b1681f30ce4b2a5fdc81cf52b50", "completion": "from heapq import *\ndef find_permutation(s):\n        n, m, *a = map(int, s.split())\n    q, h, cups, mx, t = [], [], [-1]*n, 0, 0\n    for i in range(0, 2*m, 2):\n        x = a[i] - 1\n        y = a[i+1] - 1\n        if cups[x] != -1:\n            if cups[x] != y:\n                return '-1'\n        else:\n            while t < y and q:\n                p = heappop(q)\n                if p > mx:\n                    mx = p\n                    cups[mx] = t\n                    t += 1\n                else:\n                    return '-1'\n            cups[x] = y\n            h.append(x)\n        while t < n and (not q or q[0] > mx):\n            if not h or h[-1] > t:\n                cups[t] = t\n                t += 1\n            elif q and q[0] == t:\n                heappop(q)\n                mx = t\n            elif h:\n                p = h.pop()\n                mx = max(mx, p)\n                cups[p] = t\n                t += 1\n            else:\n                return '-1'\n    while t < n:\n        if q and q[0] == t:\n            heappop(q)\n            mx = t\n        elif h and h[-1] < t:\n            p = h.pop()\n            mx = max(mx, p)\n            cups[p] = t\n        elif not q or (h and h[-1] > q[0]):\n            cups[t] = t\n        else:\n            return '-1'\n        t += 1\n    return ' '.join(str(i+1) for i in sorted(range(n), key=cups.__getitem__)) \n"}
{"task_id": "111673158df2e37ac6c019bb99225ccb", "completion": "def count_sets(input_str):\n    def power(x, y, p):\n        result = 1\n        x = x%p\n        while y > 0:\n            if(y&1):\n                result = (result*x)%p\n            y = y>>1 # y = y/2\n            x = (x*x)%p\n        return result\n    \n    MOD = 10**9 + 7\n    N = 5005\n    n, k = list(map(int,input_str.split()))\n    facts = [0]*N\n    r_facts = [0]*N\n    \n    facts[0] = r_facts[0] = 1\n    for i in range(1,N):\n        facts[i] = (facts[i-1]*i)%MOD\n    r_facts[N-1] = power(facts[N-1], MOD-2, MOD)\n    \n    for i in range(N-2,-1,-1):\n        r_facts[i]=(r_facts[i+1]*(i+1))%MOD\n    \n    dp = [[0]*N for _ in range(N)]\n    for i in range(n+1):\n        dp[i][0] = power(2,i*(i-1)//2,MOD)\n    \n    for i in range(1,n+1):\n        for j in range(1,i+1):\n            dp[i][j]=(dp[i-1][j-1] + dp[i-1][j]*2*j%MOD + dp[i-1][j]*j*(j-1)//2)%MOD\n    \n    dp2 = [0]*(n*2 + 1)\n    dp2[1] = 2\n    for i in range(2,n*2+1):\n        dp2[i] = (dp2[i-1] + facts[i]*r_facts[2]%MOD*r_facts[i-2])%MOD\n    \n    if k > dp2[-1]:\n        return \"0\"\n    result = 0\n    for l in range(n+1):\n        if l*(l-1)//2 <= k:\n            result+=(dp[n][l]*dp2[k-l*(l-1)//2])%MOD\n            result%=MOD\n            \n    return str(result)\n"}
{"task_id": "d73d9610e3800817a3109314b1e6f88c", "completion": "def max_balls_destroyed(str_input):\n    n_k_x, inc_ball_color_str = str_input.split('\\n')[:-1], str_input.split('\\n')[-1:]\n\n    n, k, x = [int(i) for i in n_k_x[0].split()]\n    inc_ball_colors = [int(i) for i in inc_ball_color_str[0].split()]\n\n    past_counts = [0] * (n + 2)\n    future_counts = [0] * (n + 2)\n    colors = [0] + inc_ball_colors + [0]\n    \n    # count past same color counts\n    for i in range(1, n+1):\n        if colors[i] == colors[i - 1]:\n            past_counts[i] = past_counts[i - 1] + 1\n        else:\n            past_counts[i] = 1\n            \n    # count future same color counts        \n    for i in range(n, 0, -1):\n        if colors[i] == colors[i + 1]:\n            future_counts[i] = future_counts[i + 1] + 1\n        else:\n            future_counts[i] = 1\n\n    destroyed_ball_max = 0\n    for i in range(1, n+1):\n        if colors[i] == x and past_counts[i] + future_counts[i] > 2:\n            left = i - past_counts[i]\n            right = i + future_counts[i]\n            while left > 0 and right < n + 1:\n                if colors[left] == colors[left - 1] and colors[right] == colors[left] and future_counts[left - 1] + past_counts[right + 1] > 1:\n                    left -= future_counts[left - 1]\n                    right += past_counts[right + 1]\n                else:\n                    break\n            destroyed_ball_max = max(destroyed_ball_max, right-left-1)\n    \n    return destroyed_ball_max\n"}
{"task_id": "faa343ad6028c5a069857a38fa19bb24", "completion": "def min_subway_cost(s):\n    n, m, a, b = map(int, s.split())\n\n    cost_per_ride_single = a\n    cost_per_ride_m = b / m\n\n    if cost_per_ride_single < cost_per_ride_m:\n        total_cost = n * a\n    else:\n        m_tickets_needed = n // m\n        total_cost = m_tickets_needed * b\n        remaining_rides = n % m\n        cost_for_remaining_rides = min(remaining_rides * a, b)\n        total_cost += cost_for_remaining_rides\n\n    return str(total_cost)"}
{"task_id": "e56f6c343167745821f0b18dcf0d0cde", "completion": "def max_number_after_swaps(input_str):\n    a, k = input_str.split()\n    a = list(a)\n    k = int(k)\n\n    for i in range(len(a)):\n        if k <= 0:\n            break\n        max_val = max(a[i:min(i + k + 1, len(a))])\n        max_ind = a[i:min(i + k + 1, len(a))].index(max_val) + i\n        while i < max_ind:\n            a[max_ind], a[max_ind - 1] = a[max_ind - 1], a[max_ind]\n            max_ind -= 1\n            k -= 1 \n\n    return \"\".join(a)\n\nprint(max_number_after_swaps('1990 1'))  # Output: '9190'\nprint(max_number_after_swaps('300 0'))  # Output: '300'\nprint(max_number_after_swaps('1034 2'))  # Output: '3104'\nprint(max_number_after_swaps('9090000078001234 6'))  # Output: '9907000008001234'\n"}
{"task_id": "67410b7d36b9d2e6a97ca5c7cff317c1", "completion": "def max_toasts(s):\n    n, k, l, c, d, p, nl, np = map(int, s.split())\n    return str(min(k*l//nl, c*d, p//np) // n)\n"}
{"task_id": "4e166b8b44427b1227e0f811161d3a6f", "completion": "def max_tugriks(input_string):\n    inpt = input_string.strip().split('\\n')\n    g, n, b, d = map(int, inpt[0].split())\n    inpt = inpt[1:]\n    dp = [[0]*(g+1) for _ in range(n+2)]\n    dp[0][0] = 0\n    dough = [0] + [b] + [int(inpt[i].split()[2]) for i in range(n)]\n    price = [0] + [d] + [int(inpt[i].split()[3]) for i in range(n)]\n    \n    for i in range(1, len(dough)):\n        if dough[i] == 0:\n            dough[i] = 1  # replacing zero dough requirement to 1 to avoid division by zero error\n    \n    v = [(price[i]/dough[i], dough[i], i) for i in range(len(dough))]\n    v.sort(reverse = True)\n    \n    for i in range(g+1):\n        if v[0][1] == 0:  \n            dp[0][i] = 0  # if dough requirement is zero the bun cannot be made\n        else:\n            dp[0][i] = i//dough[v[0][2]]*price[v[0][2]]\n            \n    for i in range(1,n+2):\n        for j in range(g+1):\n            dp[i][j] = dp[i-1][j]\n            q = v[i][2]\n            p = min([j//dough[q], int(inpt[q-2].split()[0])//int(inpt[q-2].split()[1])]) if q>1 else j//dough[q]\n            for k in range(1,p+1):\n                dp[i][j] = max([dp[i][j], dp[i-1][j-k*dough[q]]+k*price[q]])\n    return str(max(map(max,dp)))\n\nmax_tugriks(\"100 1 25 50\\n15 5 20 10\")\n"}
{"task_id": "097674b4dd696b30e102938f71dd39b9", "completion": "def max_spider_free_cells(s):\n    n, m = map(int, s.split())\n    if n == 1 or m == 1:\n        return str(max(n, m) - 1)\n    else:\n        return str(2 * (n + m - 2))\n\nprint(max_spider_free_cells('1 1'))  # Output: 0\nprint(max_spider_free_cells('2 3'))  # Output: 4\n"}
{"task_id": "cb2aa02772f95fefd1856960b6ceac4c", "completion": "def is_lucky(num):\n    return set(str(num)) <= {'4','7'}\n\ndef lucky_numbers(string):\n    n,k = map(int,string.strip().split())\n    lucky_count=0\n    for i in range(1, n+1):\n        if is_lucky(i):\n            lucky_count+=1\n            if lucky_count==k:\n                return str(i)\n    return \"-1\"\n\nprint(lucky_numbers(\"7 4\"))\nprint(lucky_numbers(\"4 2\"))\n"}
{"task_id": "b715f0fdc83ec539eb3ae2b0371ee130", "completion": "def count_strings(input_string):\n    mod = 1000000007\n    k, n = map(int, input_string.split())\n    fact = [1]\n    pow_k = [1]\n    for i in range(1, n+1):\n        fact.append((fact[-1] * i) % mod)\n        pow_k.append((pow_k[-1] * k) % mod)\n    c = [0]*(n+1)\n    c[0] = 1\n    for i in range(1, n+1):\n        c[i] = c[i-1] * (n-i+1) % mod * pow(i, mod-2, mod) % mod\n    f = [0]*(n+1)\n    f[0] = 1\n    for i in range(1, n+1):\n        f[i] = f[i-1] * (k-1) % mod\n    ans = pow_k[n]\n    for m in range(1, n+1):\n        if m > k:\n            break\n        temp = c[m] * f[n-m] % mod\n        if m < n:\n            temp = temp * (m+1) % mod\n        ans = (ans - temp + mod) % mod\n    return str(ans)\nprint(count_strings('2 2'))  # should return '10'\nprint(count_strings('3 5'))  # should return '1593'\nprint(count_strings('2 139'))  # should return '717248223'\n"}
{"task_id": "87d869a0fd4a510c5e7e310886b86a57", "completion": "def vasya_state(s:str) -> str:\n\n    s = s.strip().split('\\n')\n    n, m = map(int, s[0].split())\n    states = list(map(int, s[1].split()))\n    edges = [list(map(int, x.split())) for x in s[2:]]\n\n    operations = [[] for _ in range(n)]\n    reverse_operations = [[] for _ in range(n)]\n    forward_visits = [0]*n\n    reverse_visits = [0]*n\n\n    for a, b in edges:\n        operations[a-1].append(b-1)\n        reverse_operations[b-1].append(a-1)\n\n    def DFS(node_list, operations, visit_tracker):\n        stack = node_list.copy()\n        while stack:\n            node = stack.pop()\n            if visit_tracker[node] != 1:\n                visit_tracker[node] = 1\n                stack.extend(operations[node])\n\n    DFS([i for i in range(n) if states[i]==1], operations, forward_visits)\n    DFS([i for i in range(n) if states[i]==2], reverse_operations, reverse_visits)\n    \n    return '\\n'.join(['1' if forward_visits[i] & reverse_visits[i] else '0' for i in range(n)])\n"}
{"task_id": "7419c4268a9815282fadca6581f28ec1", "completion": "def max_profit(data):\n    # reading data\n    array = data.split(\"\\n\")[1:]\n    array = [tuple(map(int,i.split())) for i in array]\n    array = sorted(array, key = lambda x: -x[1]+x[0])\n\n    # initialization\n    total_items = int(data.split(\"\\n\")[0].split()[-1])\n    total_profit = 0\n\n    # iterate over each item and get profit\n    for buy, sell ,quantity in array:\n        if quantity <= total_items and buy <= sell:\n            total_profit += (sell-buy)*quantity\n            total_items -= quantity\n        elif buy <= sell:\n            total_profit += (sell-buy)*total_items\n            break\n    return total_profit\n"}
{"task_id": "8ab25ed4955d978fe20f6872cb94b0da", "completion": "def total_tiles(input):\n    a, b, c = map(int, input.split(' '))\n    return a*b + b*c + a*c - a - b - c + 1\n"}
{"task_id": "c706cfcd4c37fbc1b1631aeeb2c02b6a", "completion": "def maximize_nines(price_discount):\n    price, discount = map(int, price_discount.split())\n    nines_price = price\n    dec = 10\n    while price - nines_price <= discount:\n        nines_price = (price // dec) * dec - 1\n        dec *= 10\n    return nines_price + dec // 10\n"}
{"task_id": "984788e4b4925c15c9c6f31e42f2f8fa", "completion": "def count_integer_triangles(s):\n    w, h = map(int, s.split())\n    w += 1\n    h += 1\n\n    even_w, odd_w = w // 2 + w % 2, w // 2\n    even_h, odd_h = h // 2 + h % 2, h // 2\n\n    total_points = w * h \n    even_points = even_w * even_h + odd_w * odd_h \n    odd_points = total_points - even_points\n\n    total_combinations = total_points * (total_points - 1) * (total_points - 2)\n    degenerate_combinations = w * h * (h - 1) + h * w * (w - 1)\n    \n    non_degenerate_combinations = total_combinations - degenerate_combinations\n\n    return str(non_degenerate_combinations)\n"}
{"task_id": "0f7f10557602c8c2f2eb80762709ffc4", "completion": "def count_lucky_numbers(n):\n    n = int(n)\n    lucky_numbers = set()\n    stack = [(0, set())]\n\n    while stack:\n        number, digits = stack.pop()\n        if number != 0 and number <= n:\n            lucky_numbers.add(number)\n        if number > n or len(digits) > 2:\n            continue\n        for digit in range(10):\n            if number == 0 and digit == 0:\n                continue\n            new_digits = digits | {digit}\n            if len(new_digits) <= 2:\n                new_number = number * 10 + digit\n                stack.append((new_number, new_digits))\n\n    return len(lucky_numbers)"}
{"task_id": "230a3c4d7090401e5fa3c6b9d994cdf2", "completion": "def can_divide_watermelon(weight):\n    weight = int(weight)\n    return 'YES' if weight != 2 and weight % 2 == 0 else 'NO'\n"}
{"task_id": "6d67559744583229455c5eafe68f7952", "completion": "def camelDrawings(n, t):\n    n, t = map(int, (n, t)) #convert string to int\n    dp = [[[[[0 for _ in range(2)] for _ in range(5)] for _ in range(t+1)] for _ in range(t+1)] for _ in range(n+1)]\n    dp[0][0][0][0][0] = 1\n\n    for i in range(n):\n        for up in range(min(i+1,t)+1):\n            for down in range(min(i-up+1,t-1)+1):\n                for k in range(1, 5):\n                    for last in range(k):\n                        dp[i+1][up][down][k][0] += dp[i][up][down][last][0] + dp[i][up][down][last][1]\n                        dp[i+1][up+1][down][k][1] += dp[i][up][down][last][1]\n                for k in range(1, 5):\n                    for last in range(k+1, 5):\n                        dp[i+1][up+1][down][k][0] += dp[i][up][down][last][0]\n                        if down < t-1:\n                            dp[i+1][up][down+1][k][1] += dp[i][up][down][last][0] + dp[i][up][down][last][1]\n\n    answer = 0\n    for last in range(5):\n        for flag in range(2):\n            answer += dp[n][t][t-1][last][flag]\n\n    return str(answer % 1000000007)\n\nprint(camelDrawings(\"6\", \"1\"))\nprint(camelDrawings(\"4\", \"2\")) \n"}
{"task_id": "e4a4affb439365c843c9f9828d81b42c", "completion": "def minimum_time(v, d, g, r):\n\n    v = float(v)\n    d = float(d)\n    g = float(g)\n    r = float(r)\n\n    cycle_length = g + r\n    time_to_reach_lights = d / v\n    cycles_passed = time_to_reach_lights // cycle_length\n    remaining_time = time_to_reach_lights - cycles_passed * cycle_length\n\n    if remaining_time > g:\n        time_to_reach_lights += cycle_length - remaining_time\n\n    return \"{:.8f}\".format(time_to_reach_lights)\n\nprint(minimum_time(2, 1, 3, 4))  # Outputs '0.66666667'\nprint(minimum_time(5, 4, 3, 1))  # Outputs '0.80000000'\n"}
{"task_id": "37feadce373f728ba2a560b198ca4bc9", "completion": "def beautiful_numbers(data):\n    def divisible(number):\n        for digit in str(number):\n            if digit == '0' or number % int(digit) != 0:\n                return False\n        return True\n    result = []\n    lines = data.split(\"\\n\")\n    for i in range(1, int(lines[0])+1):\n        count = 0\n        start, end = map(int, lines[i].split())\n        for j in range(start, end+1):\n            if divisible(j):\n                count +=1\n        result.append(str(count))\n    return \"\\n\".join(result)"}
{"task_id": "c5d19dc8f2478ee8d9cba8cc2e4cd838", "completion": "def can_say_hello(s):\n    hello = 'hello'\n    index = 0\n    for letter in s:\n        if letter == hello[index]:\n            index += 1\n            if index == len(hello): \n                return 'YES'\n    return 'NO'\n"}
{"task_id": "a11c9679d8e2dca51be17d466202df6e", "completion": "def email_conversion(s):\n    s = s.replace('dot', '.', s.count('dot') - 1)\n    s = s.replace('at', '@', s.count('at') - 1)\n    s = s[::-1].replace('tad', '.', 1)[::-1]\n    return s.replace('dot', '.')\n"}
{"task_id": "1a335a9638523ca0315282a67e18eec7", "completion": "def empty_cells(n):\n    # convert to int\n    n = int(n)\n\n    # base case\n    if n == 0:\n        return 0\n\n    # recursively add empty cells for every quadrant that a cookie is placed in\n    return 4*empty_cells(n-1) + (4**n - 2**n)\n"}
{"task_id": "2c4b2a162563242cb2f43f6209b59d5e", "completion": "def max_weight(s):\n    l, r = map(int, s.split())\n    mid = int('5' + '0' * (len(str(r)) - 1))\n\n    def reflection(n):\n        return int(''.join(str(9 - int(d)) for d in str(n)))\n\n    if r < mid:\n        return str(r * reflection(r))\n    elif l <= mid:\n        return str(mid * reflection(mid))\n    else:\n        return str(l * reflection(l))\n\nprint(max_weight('3 7'))  # Expected output: \"20\"\nprint(max_weight('1 1'))  # Expected output: \"8\"\nprint(max_weight('8 10'))  # Expected output: \"890\"\n"}







