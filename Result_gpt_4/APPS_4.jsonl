{"task_id": 3554, "completion": "from collections import Counter\n\ndef get_score(dice):\n    c = Counter(dice)\n    score = 0\n\n    # Special cases\n    if c == Counter(range(1,7)):\n        return 1000\n\n    if len([x for x in c.values() if x==2]) == 3:\n        return 750\n\n    # General cases\n    triples = [3,2,3,4,5,6]\n    for i in range(1,7):\n        q, r = divmod(c[i], 3)\n        score += (q * triples[i-1] * 100)\n        if i in [1,5]:\n            score += (r * 10 * i)\n\n    return score if score > 0 else \"Zonk\"\n"}
{"task_id": 1, "completion": "import re \n\ndef drop_cap(str_): \n    return re.sub(r'\\b\\w{3,}\\b', lambda x: x.group().capitalize(), str_)"}
{"task_id": 4561, "completion": "def solve(st):\n    for i in range(len(st) // 2):\n        if abs(ord(st[i]) - ord(st[-i-1])) not in [0, 2]:\n            return False\n    return True"}
{"task_id": 4468, "completion": "def simplify(n):\n    n = str(n)\n    result = []\n    l = len(n) - 1\n    for i in n:\n        if int(i) != 0:\n            result.append(\"{}*10**{}\".format(i, l))\n        l -= 1\n    return \"+\".join(result)"}
{"task_id": 3613, "completion": "def is_substitution_cipher(string1, string2):\n    return len(set(zip(string1, string2))) == len(set(string1)) == len(set(string2))"}
{"task_id": 4465, "completion": "def super_size(n):\n    return int(''.join(sorted(str(n), reverse=True)))"}
{"task_id": 3045, "completion": "def elevator(left, right, call):\n  # Check if the distance between the left elevator and the call is less than the distance between the right elevator and the call\n  if abs(left - call) < abs(right - call):\n    return \"left\"\n  # If the distances are equal or the right elevator is closer, return \"right\"\n  else:\n    return \"right\""}
{"task_id": 4276, "completion": "def solution(n):\n    return round(float(n) * 2) / 2"}
{"task_id": 2882, "completion": "def cumulative_triangle(n):\n    n = int(n)\n    first_num = n*(n - 1)//2 + 1\n    last_num = first_num + n - 1\n    return str((first_num + last_num)*n // 2)"}
{"task_id": 4440, "completion": "def validate_pin(pin):\n    return len(pin) in (4, 6) and pin.isdigit()"}
{"task_id": 2771, "completion": "def hofstadter_Q(n):\n    sequence = [1, 1]\n    for i in range(2, n):\n        sequence.append(sequence[i - sequence[i - 1]] + sequence[i - sequence[i - 2]])\n        \n    return sequence[n - 1]"}
{"task_id": 4335, "completion": "def anagrams(word, words):\n    return [w for w in words if sorted(w) == sorted(word)]"}
{"task_id": 3512, "completion": "def last_fib_digit(n):\n    n = n % 60\n    if n <= 1:\n        return n\n    fib_seq_last_digit = [0, 1] + [0] * (n - 1)\n    \n    for i in range(2, n + 1):\n        fib_seq_last_digit[i] = (fib_seq_last_digit[i - 1] + fib_seq_last_digit[i - 2]) % 10\n    return fib_seq_last_digit[n]"}
{"task_id": 3435, "completion": "def alphabet_war(fight):\n    powers = {\"w\":-4,\"p\":-3,\"b\":-2,\"s\":-1,\"m\":4,\"q\":3,\"d\":2,\"z\":1}\n    fight = list(fight)\n    for i in range(1, len(fight)-1):\n        if fight[i] == '*':\n            fight[i-1] = fight[i+1] = '_'\n    fight = ''.join(fight).replace('*','')\n    result = sum(powers.get(a,0) for a in fight)\n    return \"Let's fight again!\" if result == 0 else \"Left side wins!\" if result < 0 else \"Right side wins!\""}
{"task_id": 3387, "completion": "def name_in_str(str, name):\n    name = name.lower()\n    str = str.lower()\n    i, j = 0, 0\n    while i < len(str) and j < len(name):\n        if str[i] == name[j]:\n            j += 1\n        i += 1\n    return j == len(name)"}
{"task_id": 4024, "completion": "def special_number(number):\n    return \"Special!!\" if set(str(number)) <= set('012345') else \"NOT!!\"\n"}
{"task_id": 3478, "completion": "def battle(player1, player2):\n    survivingPlayer1 = [creature for i, creature in enumerate(player1) if i >= len(player2) or creature[1] > player2[i][0]]\n    survivingPlayer2 = [creature for i, creature in enumerate(player2) if i >= len(player1) or creature[1] > player1[i][0]]\n    \n    return {'player1': survivingPlayer1, 'player2': survivingPlayer2}\n"}
{"task_id": 3766, "completion": "def getAllPrimeFactors(n):\n    if isinstance(n, (int)) and n > 0:\n        factors = []\n        i = 2\n        while n != 1:\n            if n % i == 0:\n                factors.append(i)\n                n = n // i\n            else:\n                i += 1\n        return factors\n    else:\n        return []"}
{"task_id": 3292, "completion": "def calc(x):\n    total1 = ''.join(str(ord(c)) for c in x)\n    sum1 = sum(int(d) for d in total1)\n    total2 = total1.replace('7', '1')\n    sum2 = sum(int(d) for d in total2)\n    return sum1 - sum2\n"}
{"task_id": 2886, "completion": "def find(s):\nimport re\n    matches = re.findall(r'(\\!+\\?+|\\?+\\!+)', s)\n    if matches:\n        return max(matches, key=len)\n    else:\n        return \"\""}
{"task_id": 4515, "completion": "def max_difference(arr):\n    max_diff = -1\n    max_diff_couple = ''\n    for couple in arr:\n        a, b = map(int, couple.split('-'))\n        diff = abs(a-b)\n        if diff > max_diff:\n            max_diff, max_diff_couple = diff, couple\n    if max_diff == 0:\n        return False\n    else:\n        return max_diff_couple"}
{"task_id": 3068, "completion": "def vowel_back(st):\n    result =''\n    for i in st:\n        if i in 'aeiou':\n            if i in 'code':\n                result += i\n            else:\n                if chr((ord(i) - 5 - 97) % 26 + 97) in 'code':\n                    result += i\n                else:\n                    result += chr((ord(i) - 5 - 97) % 26 + 97)\n        else:\n            if chr((ord(i) + 9 - 97) % 26 + 97) in 'code':\n                result += i\n            else:\n                result += chr((ord(i) + 9 - 97) % 26 + 97)\n    return result\n"}
{"task_id": 4214, "completion": "import re\n\ndef spin_solve(sentence):\n    result = []\n    words = re.findall(r\"[\\w']+|[.,!?;]\", sentence)\n\n    for word in words:\n        if ',' not in word:\n            if len(word) > 6 or word.count('t') + word.count('T') > 1:\n                result.append(word[::-1])\n            elif len(word) == 2:\n                result.append(word.upper())\n            elif len(word) == 1:\n                result.append(\"0\")\n            else:\n                result.append(word)\n        else:\n            if len(word) > 7 or word.count('t') + word.count('T') > 1:\n                result.append(word[:-1][::-1] + \",\")\n            else:\n                result.append(word[:-1].upper() + \",\")\n\n    return ' '.join(result)\n"}
{"task_id": 3884, "completion": "Here's a JavaScript solution for the problem:\n\n```javascript\nconst gymSlang = (phrase) => {\n  return phrase\n    // case preserving replace function\n    .replace(/probably|instagram|do not|going to|combination/gi, (match) => {\n      switch(match.toLowerCase()){\n        case 'probably':\n          return match[0] + 'rolly';\n        case 'i am':\n          return match[0] + '\\'m';\n        case 'instagram':\n          return 'insta' + match[match.length - 2] + match[match.length - 1];\n        case 'do not':\n          return match[0] + 'on\\'t';\n        case 'going to':\n          return 'gonna';\n        case 'combination':\n          return 'combo' + match[match.length - 2] + match[match.length - 1];\n      }\n    });\n};\n"}
{"task_id": 3732, "completion": "def is_madhav_array(arr):\n    if len(arr) < 2:\n        return False\n    \n    sum_elements = 0\n    n = 2\n\n    for i in range(1, len(arr)):\n        sum_elements += arr[i]\n        if sum_elements == arr[0]:\n            sum_elements = 0\n            if i + n < len(arr):\n                i += n\n                n += 1\n            elif i + n == len(arr):\n                return True\n            else:\n                return False\n        elif sum_elements > arr[0]:\n            return False\n\n    return False\n"}
{"task_id": 3569, "completion": "def is_lucky(ticket):\n    ticket_numbers = [int(i) for i in ticket]\n    return sum(ticket_numbers[:3]) == sum(ticket_numbers[3:])\n"}
{"task_id": 2755, "completion": "def multiple_of_index(arr):\n    return [val for idx, val in enumerate(arr) if idx != 0 and val % idx == 0]\n"}
{"task_id": 4168, "completion": "def string_hash(s):\n    a = sum(ord(char) for char in s)\n    b = sum(ord(s[i]) - ord(s[i-1]) for i in range(1, len(s)))\n    c = (a | b) & (~a << 2)\n    d = c ^ (32 * (s.count(' ') + 1))\n    return d\n"}
{"task_id": 4391, "completion": "def yellow_be_gone(s):\n    color_dict = {'gold': 'ForestGreen', 'khaki': 'LimeGreen', 'lemonchiffon': 'PaleGreen',\n                  'lightgoldenrodyellow': 'SpringGreen', 'lightyellow': 'MintCream',\n                  'palegoldenrod': 'LightGreen', 'yellow': 'Lime'}\n    s_lower = s.lower()\n    if s_lower in color_dict:\n        return color_dict[s_lower]\n    if s[0] == '#':\n        R, G, B = sorted([int(s[i:i+2], 16) for i in [1, 3, 5]], reverse=True)\n        color = '#{:02x}{:02x}{:02x}'.format(R, G, B)\n        return color.upper() if s.isupper() else color\n    return s\n"}
{"task_id": 4344, "completion": "def rectangles(n, m):\n    return (n * (n - 1) // 2) * (m * (m - 1) // 2)"}
{"task_id": 3856, "completion": "def sieve(n):\n    primes = [True] * (n+1)\n    primes[0] = primes[1] = False\n    for i, isprime in enumerate(primes):\n        if isprime:\n            for n in range(i*i, n+1, i):\n                primes[n] = False\n    return primes\n\ndef solve(a, b):\n    primes = sieve(2*b)\n    seq = [i for i in range(2, len(primes)) if primes[i]]\n    dom_sum = 0\n    for p in seq:\n        if primes[p] and a<=p<=b:\n            dom_sum += p\n    return dom_sum\n"}
{"task_id": 3698, "completion": "def tiyFizzBuzz(s):\n    res = ''\n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                if char in 'AEIOU':\n                    res += 'Iron Yard'\n                else:\n                    res += 'Iron'\n            elif char in 'aeiou':\n                res += 'Yard'\n            else:\n                res += char\n        else:\n            res += char\n    return res\n"}
{"task_id": 4268, "completion": ""}
{"task_id": 2704, "completion": "def almost_increasing_sequence(sequence):\n    count = 0\n    for i in range(len(sequence) - 1):\n        if sequence[i] >= sequence[i + 1]: \n            count += 1\n            if i - 1 >= 0 and i + 2 < len(sequence) and sequence[i] > sequence[i + 2] and sequence[i + 1] <= sequence[i - 1]: \n                count += 1\n    return count <= 1"}
{"task_id": 3978, "completion": "def check_for_factor(base, factor):\n    return base % factor == 0\n"}
{"task_id": 4262, "completion": "function calc_tip(p, r) {\n    p = Math.round(p / 10) * 10;\n    var T = Math.floor(p / 10);\n    if (r === 1) {\n        T += 1;\n    } else if (r === 0) {\n        T -= 1;\n    } else if (r === -1) {\n        T = Math.floor(T / 2) - 1;\n    }\n    return Math.max(0, T);\n}\n```\n\nThe function first rounds the input price `p` to the nearest 10 and then calculates the base tip `T` by dropping the last single digit. The rating `r` is then applied to adjust `T`. In case where the final tip is negative, the function simply returns 0."}
{"task_id": 2798, "completion": "def to_alternating_case(string):\n    return string.swapcase()\n"}
{"task_id": 4411, "completion": "def find_missing_number(numbers):\n    total = len(numbers) + 1\n    return total * (total + 1) // 2 - sum(numbers)"}
{"task_id": 3741, "completion": "def vector_affinity(a_def, b_def):\n    # convert string to list\n    a = [int(x) for x in a_def[1:-1].split(', ')]\n    b = [int(x) for x in b_def[1:-1].split(', ')]\n  \n    matching_elements = sum([i==j for i,j in zip(a,b)])\n    return matching_elements / max(len(a), len(b))\n"}
{"task_id": 3242, "completion": "def maximum_product(arr):\n    max_product = -float('inf')\n    result = None\n    for num in arr:\n        temp_arr = arr[:]\n        temp_arr.remove(num)\n        product = 1\n        for i in temp_arr:\n            product *= i\n        if product > max_product or (product == max_product and num < result):\n            max_product = product\n            result = num\n    return result"}
{"task_id": 4453, "completion": "def shortest_steps_to_num(num):\n    num = int(num)\n    steps = 0\n    while num != 1:\n        if num % 2 == 0:\n            num /= 2\n        else:\n            num -= 1\n        steps += 1\n    return steps"}
{"task_id": 3616, "completion": "def prime_primes(N):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = [i for i in range(2, N) if is_prime(i)]\n\n    count = 0\n    the_sum = 0.0\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            count += 1\n            the_sum += primes[i] / primes[j]\n\n    return [count, int(the_sum)]"}
{"task_id": 3439, "completion": "def solve(n):\n    n = str(n)\n    a = '1' + '0' * (len(n) - 1)\n    b = str(int(n) - int(a))\n    return sum(int(i) for i in a) + sum(int(i) for i in b)\n"}
{"task_id": 3155, "completion": "def fit_in(a, b, m, n):\n    return max(a, b) <= min(m, n) and (a + b) <= max(m, n)\n"}
{"task_id": 3562, "completion": "def count_inversion(sequence):\n    return sum(1 for i in range(len(sequence)) for j in range(i+1, len(sequence)) if sequence[i] > sequence[j])\n"}
{"task_id": 3883, "completion": "def solve(s):\n    vowels = sorted([char for char in s if char in 'aeiou'])\n    consonants = sorted([char for char in s if char not in 'aeiou'])\n    \n    if abs(len(vowels) - len(consonants)) > 1:\n        return \"failed\"\n\n    if len(vowels) >= len(consonants):\n        result = ''.join(a + b for a, b in zip(vowels, consonants))\n        if len(vowels) > len(consonants):\n            result += vowels[-1]\n    else:\n        result = ''.join(a + b for a, b in zip(consonants, vowels))\n        if len(consonants) > len(vowels):\n            result += consonants[-1]\n\n    return result\n"}
{"task_id": 4277, "completion": "def difference_in_ages(ages):\n    ages = sorted(ages)\n    return (ages[0], ages[-1], ages[-1]-ages[0])"}
{"task_id": 3836, "completion": "def factors(x):\n    if not isinstance(x, int) or x < 1:\n        return -1\n    return sorted([i for i in range(1, x + 1) if x % i == 0], reverse=True)\n"}
{"task_id": 3531, "completion": "import sympy\n\ndef valid_mersenne(n):\n    mersenne = 2**n - 1\n    return sympy.isprime(mersenne)\n"}
{"task_id": 1643, "completion": "def almost_everywhere_zero(n, k): \n    n = list(map(int, str(n))) \n    l = len(n) \n    dp = [[0 for _ in range(l+1)] for __ in range(l+1)]\n    dp[0][0] = 1\n    for i in range(1, l+1): \n        for j in range(i): \n            for d in range((10 if j else 1), n[i-1]+1): \n                dp[i][j+1] += dp[i-1][j] \n            dp[i][j] += dp[i-1][j] \n        dp[i][i] += 1 \n    return sum(dp[l][0:k+1])\n\n"}
{"task_id": 1627, "completion": "def is_polydivisible(s, b):\n    return all(int(s[:i], b) % i == 0 for i in range(1, len(s) + 1))\n"}
{"task_id": 1663, "completion": "def count_divisors(n):\n    n = int(n)\n    i = 1\n    total = 0\n    while i * i < n:\n      total += n // i\n      i += 1\n    smaller_than_sqrt = total\n    if i * i == n:\n        smaller_than_sqrt -= i\n    return 2 * total - i + 1 + smaller_than_sqrt\n"}
{"task_id": 1640, "completion": "def mix(s1, s2):\n    counter1, counter2 = [0]*26, [0]*26\n    for letter in s1: \n        if letter.islower(): counter1[ord(letter)-ord('a')] += 1\n    for letter in s2: \n        if letter.islower(): counter2[ord(letter)-ord('a')] += 1\n\n    res = []\n    for i in range(26):\n        count1, count2 = counter1[i], counter2[i]\n        if max(count1, count2)>1: \n            which = '1' if count1>count2 else '2' if count2>count1 else '='\n            res.append(('{}:{}'.format(which, chr(i+ord('a'))*max(count1, count2))))\n\n    return '/'.join(sorted(res, key=lambda x: (-len(x), x)))\n"}
{"task_id": 1654, "completion": "def solve_runes(runes):\n    for digit in range(10):\n        new_runes = runes.replace('?', str(digit))\n        left, right = new_runes.split('=')\n        if '*' in left:  \n            num1, num2 = [int(i) for i in left.split('*')]\n            if num1 * num2 == int(right): \n                return digit\n        elif '+' in left:\n            num1, num2 = [int(i) for i in left.split('+')]\n            if num1 + num2 == int(right): \n                return digit\n        elif '-' in left:\n            num1, num2 = [int(i) for i in left.split('-')]\n            if num1 - num2 == int(right): \n                return digit\n    return -1\n"}
{"task_id": 1616, "completion": "def parse_int(string):\n    num_word_map = {\"zero\": 0, \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4,\n                    \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9,\n                    \"ten\": 10, \"eleven\": 11, \"twelve\": 12, \"thirteen\": 13,\n                    \"fourteen\": 14, \"fifteen\": 15, \"sixteen\": 16, \"seventeen\": 17,\n                    \"eighteen\": 18, \"nineteen\": 19, \"twenty\": 20, \"thirty\": 30,\n                    \"forty\": 40, \"fifty\": 50, \"sixty\": 60, \"seventy\": 70,\n                    \"eighty\": 80, \"ninety\": 90, \"hundred\": 100,\n                    \"thousand\": 1000, \"million\": 1000000}\n    num_string = string.replace(' and ', ' ').replace('-', ' ').split()\n    num_res = 0\n    current = 0\n\n    for word in num_string:\n        if word in num_word_map:\n            num = num_word_map[word]\n            if num >= 100:\n                if current == 0: \n                    current = 1\n                current *= num\n            else:\n                current += num\n        else:\n            num_res += current\n            current = 0\n            \n    num_res += current\n    return num_res\n"}
{"task_id": 1642, "completion": "import math\nfrom functools import lru_cache\n\ndef multiply_to_n(n, k):\n    @lru_cache(maxsize=None)\n    def dp(i, prev):\n        if i == k:\n            return prev <= n and n % prev == 0\n        return sum(dp(i + 1, prev * x) for x in range(1, math.floor((n / prev) ** (1 / (k - i))) + 1))\n\n    return dp(0, 1)\n"}
{"task_id": 1665, "completion": "def same_structure_as(original, other):\n    if type(original) == list and type(other) == list:\n        return len(original) == len(other) and all(map(same_structure_as, original, other))\n    else:\n        return not isinstance(original, list) and not isinstance(other, list)\n"}
{"task_id": 1648, "completion": "def spinning_rings(inner_max, outer_max):\n    inner_max += 1\n    outer_max += 1\n    product = inner_max * outer_max\n    while outer_max:\n        inner_max, outer_max = outer_max, inner_max % outer_max\n    return product // inner_max - 1\n"}
{"task_id": 1617, "completion": "import math\n\ndef converter(n, decimals=0, base=math.pi):\n    if n < 0:\n        return \"-\" + converter(-n, decimals, base)\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    integer = int(n)\n    fractional = n - integer\n\n    result = \"\"\n    while integer > 0:\n        integer, remainder = divmod(integer, base)\n        result = chars[int(remainder)] + result\n\n    if decimals > 0:\n        result += \".\"\n        for _ in range(decimals):\n            fractional *= base\n            digit = int(fractional)\n            fractional -= digit\n            result += chars[digit]\n\n    return result or \"0\"\n"}
{"task_id": 1660, "completion": "import re\nfrom collections import defaultdict\n\ndef simplify(poly):\n    # Parse all monomials and coefficients\n    monomials = re.findall('[+-]?[\\d]*[a-z]+', poly)\n    \n    # Store them in a dictionary\n    poly_dict = defaultdict(int)\n    for mono in monomials:\n        coeff = re.match('[+-]?[\\d]*', mono).group()\n        coeff = int(coeff) if coeff[1:] else (-1 if coeff[:1] == '-' else 1)\n        \n        # Variables are sorted on declaration\n        var = ''.join(sorted(re.findall('[a-z]', mono)))\n        \n        poly_dict[var] += coeff\n    \n    # Assemble them back into a string, following the rules of ordering and simplifying\n    simplified = [f'{\"\" if v == 1 else \"-\" if v == -1 else v}{k}' for k, v in \n                  sorted(poly_dict.items(), key=lambda x: (len(x[0]), x)) if poly_dict[k]]\n    \n    return '+'.join(simplified).replace('+-', '-')\n"}
{"task_id": 1613, "completion": "def solution(s, markers):\n    lines = s.split('\\n')\n    for i in range(len(lines)):\n        for marker in markers:\n            pos = lines[i].find(marker)\n            if pos != -1:\n                lines[i] = lines[i][:pos]\n        lines[i] = lines[i].rstrip(' ')\n    return '\\n'.join(lines)\n"}
{"task_id": 1630, "completion": "def survivor(zombies):\n    zombies.sort()\n    result = 0\n    for i in range(len(zombies)):\n        if zombies[i] > result + 1:\n            break\n        result += zombies[i]\n    return result if result < sum(zombies) else -1\n"}
{"task_id": 1668, "completion": "def next_smaller(n):\n    num_list = list(str(n))\n    length = len(num_list)\n    \n    for i in range(length-2,-1,-1):\n        if num_list[i] > num_list[i+1]:\n            break\n    else:\n        return -1\n    \n    for j in range(length-1, i, -1):\n        if num_list[j] < num_list[i]:\n            num_list[i], num_list[j] = num_list[j], num_list[i]\n            break\n    \n    num_list[i+1:] = reversed(num_list[i+1:])\n    result = int(''.join(num_list))\n    \n    if len(str(result)) == length:\n        return result\n    else:\n        return -1\n"}
{"task_id": 1634, "completion": "import math\n\ndef total_inc_dec(x):\n    return math.comb(x + 10, 10) + math.comb(x + 9, 9) - 10*x - 1 if x > 0 else 1\n"}
{"task_id": 1645, "completion": ""}
{"task_id": 1666, "completion": "from math import gcd\nfrom functools import reduce\n\ndef solution(a):\n    a = str(a)\n# convert the input string to list of integers\n    arr = list(map(int, a.strip(\"[]\").split(\", \")))\n\n    # calculate the gcd of all numbers in the list and multiply it by the list length\n    return len(arr) * reduce(gcd, arr)"}
{"task_id": 1659, "completion": "def exp_sum(n):\n    n = int(n)\n    if n < 0:\n        return 0\n    dp = [1] + [0]*n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[j - i]\n    return dp[n]"}
{"task_id": 1647, "completion": "def next_bigger(n):\n    n = str(n)\n    for i in range(len(n)-2, -1, -1):\n        if n[i] < n[i+1]:\n            t = n[i:]\n            m = min(filter(lambda x: x > t[0], t))\n            return int(n[:i] + m + ''.join(sorted(t.replace(m, '', 1))))\n    return -1\n"}
{"task_id": 1646, "completion": "import heapq\n\ndef green(n):\n    h = [1]\n    visited = set()\n    val = None\n    for _ in range(n):\n        while h[0] in visited:\n            heapq.heappop(h)\n        val = heapq.heappop(h)\n        visited.add(val)\n        heapq.heappush(h, 10*val)\n        heapq.heappush(h, 10*val + 1)\n    return str(val)\n"}
{"task_id": 1656, "completion": "def countSubsequences(needle, haystack):\n    len1 = len(haystack)\n    len2 = len(needle)\n\n    # Creating a 2-dimensional array (table) with a size of (len1 + 1) * (len2 + 1)\n    table = [[0 for _ in range(len1 + 1)] for _ in range(len2 + 1)]\n  \n    for i in range(len2 + 1):\n        for j in range(len1 + 1):\n            if i == 0:\n                # If 'needle' is empty, there is one subsequence - the empty sequence.\n                table[i][j] = 1\n            elif j == 0:\n                # If 'needle' is not empty and 'haystack' is empty, there are no subsequences.\n                table[i][j] = 0\n            else:\n                # If the current characters match, add the count of the previous characters.\n                # If the current characters do not match, retain the count of previous characters.\n                if needle[i - 1] == haystack[j - 1]:\n                    table[i][j] = (table[i - 1][j - 1] + table[i][j - 1]) % int(1E8)\n                else:\n                    table[i][j] = table[i][j - 1]\n\n    return table[len2][len1] % int(1E8)\n"}
{"task_id": 1649, "completion": "def traverse_TCP_states(events):\n    state = 'CLOSED'  # initial state\n    state_dict = {\n        'CLOSED': {'APP_PASSIVE_OPEN': 'LISTEN', 'APP_ACTIVE_OPEN': 'SYN_SENT'},\n        'LISTEN': {'RCV_SYN': 'SYN_RCVD', 'APP_SEND': 'SYN_SENT', \n                   'APP_CLOSE': 'CLOSED'},\n        'SYN_RCVD': {'APP_CLOSE': 'FIN_WAIT_1', 'RCV_ACK': 'ESTABLISHED'},\n        'SYN_SENT': {'RCV_SYN': 'SYN_RCVD', 'RCV_SYN_ACK': 'ESTABLISHED', \n                     'APP_CLOSE': 'CLOSED'},\n        'ESTABLISHED': {'APP_CLOSE': 'FIN_WAIT_1', 'RCV_FIN': 'CLOSE_WAIT'},\n        'FIN_WAIT_1': {'RCV_FIN': 'CLOSING', 'RCV_ACK': 'FIN_WAIT_2', \n                       'RCV_FIN_ACK': 'TIME_WAIT'},\n        'CLOSING': {'RCV_ACK': 'TIME_WAIT'},\n        'FIN_WAIT_2': {'RCV_FIN': 'TIME_WAIT'},\n        'TIME_WAIT': {'APP_TIMEOUT': 'CLOSED'},\n        'CLOSE_WAIT': {'APP_CLOSE': 'LAST_ACK'},\n        'LAST_ACK': {'RCV_ACK': 'CLOSED'}\n    }\n    \n    for event in events:\n        if event in state_dict[state]:  \n            state = state_dict[state][event]\n        else:\n            return 'ERROR'\n\n    return state"}
{"task_id": 1621, "completion": "def count_change(money, coins):\n    dp = [0] * (money + 1)\n    dp[0] = 1\n    for coin in coins:\n        for x in range(coin, money+1):\n            dp[x] += dp[x-coin]\n    return dp[money]\n"}
{"task_id": 1628, "completion": "from math import gcd\n\ndef proper_fractions(n):\n    def phi(n):\n        result = n\n        p = 2\n        while(p * p <= n):\n            if n % p:\n                p += 1\n            else:\n                n //= p\n                result -= result // p\n        if n > 1:\n            result -= result // n\n        return result\n\n    return phi(n)\n"}
{"task_id": 1604, "completion": "def labyrinthPaths(input):\n    mod=10**9+7\n    data=input.split(\"\\n\")\n    grid= list(map(list, data[1:] ))\n    n,m=len(grid), len(grid[0])\n    dp = [[0]*m for _ in range(n)]\n    if grid[0][0] == \"R\": return str(0)+'\\n'\n    dp[0][0]=1\n    for i in range(1,m):\n        if grid[0][i]!='R' and dp[0][i-1]==1: dp[0][i]=1\n    for i in range(1,n):\n        if grid[i][0]!='R' and dp[i-1][0]==1: dp[i][0]=1\n    for i in range(1,n): \n        for j in range(1,m):\n            if grid[i][j]!=\"R\":\n                dp[i][j]= dp[i-1][j]+dp[i][j-1]\n            else:\n                if dp[i-1][j]==1 or dp[i][j-1]==1 : return str(0)+'\\n'\n    return str(dp[n-1][m-1]%mod)+'\\n'\n    \n\nprint(labyrinthPaths('4 4\\n...R\\n.RR.\\n.RR.\\nR...\\n'))# 4\nprint(labyrinthPaths('2 3\\n...\\n..R\\n')) # 0\nprint(labyrinthPaths('1 1\\n.\\n')) # 1\nprint(labyrinthPaths('1 5\\n..R..\\n')) # 0\nprint(labyrinthPaths('2 2\\n.R\\nR.\\n')) # 0\nprint(labyrinthPaths('5 5\\n.....\\n..R..\\n.....\\n.....\\n.....\\n')) # 144\nprint(labyrinthPaths('5 5\\n.....\\n..R..\\n.....\\n..R..\\n.....\\n')) # 85\nprint(labyrinthPaths('2 2\\n..\\n.R\\n')) # 1\nprint(labyrinthPaths('5 5\\n.....\\n.....\\n..R..\\n.....\\n.....\\n')) # 125"}
{"task_id": 1622, "completion": "def bowling_score(frames):\n    frames = frames.split()\n    score = []\n    for f in frames:\n        if f == 'X':\n            score.append(10)\n        else:\n            for s in f:\n                if s == '/':\n                    score[-1] = 10 - score[-1]\n                    score.append(score[-1])\n                elif s.isdigit():\n                    score.append(int(s))\n    for i, frame in enumerate(frames[:-1]):\n        if 'X' in frame:\n            if i+2 < 10 and 'X' in frames[i+1]:\n                score[i] += score[i+2] + (score[i+4] if i+3 < 10 and 'X' in frames[i+2] else score[i+3])\n            else:\n                score[i] += score[i+2]\n        elif '/' in frame:\n            score[i] += score[i+2]\n    return sum(score[:i+3])\n\n"}
{"task_id": 1658, "completion": "from fractions import Fraction\nfrom math import factorial\n\ndef expand(x, digits):\n    x = Fraction.from_float(x)\n    numerator = denominator = Fraction(0)\n    i = 0\n    while len(str(numerator.numerator)) < digits:\n        frac = Fraction(x ** i, factorial(i))\n        numerator += frac\n        i += 1\n    return [numerator.numerator, numerator.denominator]\n"}
{"task_id": 1626, "completion": "def solve(n):\n    start = 1\n    end = n\n    while start < end:\n        mid = (start + end) // 2\n        if mid * (mid + 1) // 2 < n:\n            start = mid + 1\n        else:\n            end = mid\n    k = start * (start + 1) // 2\n    if k == n:\n        return int(str(start)[-1])\n    else:\n        return int(str(start - 1)[n - start * (start - 1) // 2 - 1])\n"}
{"task_id": 1629, "completion": "def exchange_sort(sequence):\n    mn = min(sequence)\n    mx = max(sequence)\n    mid = 7 + 8 + 9 - mn - mx\n    return sequence.count(mid) - sequence[:sequence.count(mn)].count(mid) + sequence.count(mx) - sequence[sequence.count(mn)+sequence.count(mid):].count(mx)\n"}
{"task_id": 1618, "completion": "def differentiate(equation, point):\n    equation = equation.replace('-', '+-')\n    terms = equation.split('+')\n    deriv = 0\n    for term in terms:\n        term = term.replace('^', ' ')\n        if 'x' in term:\n            list_of_term = term.split('x')\n            if len(list_of_term[0]) == 0:\n                coeff = 1\n            elif list_of_term[0] == '-':\n                coeff = -1\n            else:\n                coeff = int(list_of_term[0])\n            if ' ' in list_of_term[1]:\n                pow_coeff = int(list_of_term[1].split(' ')[1])\n                coeff = coeff * pow_coeff\n                pow_coeff = pow_coeff -1\n            else:\n                pow_coeff = 1\n            deriv += coeff * (point ** pow_coeff)\n        else:\n            pass\n    return deriv\n\n"}
{"task_id": 1638, "completion": "def longest_palindrome(s):\n    if s == \"\":\n        return ''\n    to_check = '#' + '#'.join(s) + '#'\n    rl = [0] * len(to_check)\n    max_right = 0\n    pos = 0\n    max_len = 0\n    max_center = 0\n    for i in range(len(to_check)):\n        if i < max_right:\n            rl[i] = min(rl[2 * pos - i], max_right - i)\n        else:\n            rl[i] = 1\n        while i - rl[i] >= 0 and i + rl[i] < len(to_check) and to_check[i - rl[i]] == to_check[i + rl[i]]:\n            rl[i] += 1\n        if rl[i] + i - 1 > max_right:\n            max_right = rl[i] + i - 1\n            pos = i\n        if max_len < rl[i]:\n            max_len = rl[i]\n            max_center = i\n    start = (max_center - max_len)//2\n    return s[start : start + max_len - 1]"}
{"task_id": 2096, "completion": "def max_subsequence(input_data):\n    input_lines = input_data.strip().split('\\n')\n    n = int(input_lines[0])\n    sequence = list(map(int, input_lines[1].split()))\n    sorted_sequence = sorted(sequence)\n    map_positions = {val: idx for idx, val in enumerate(sequence)}\n    visited_index = [False]*n\n    result = []\n\n    for i in range(n):\n        if visited_index[i] is False:\n            current_cycle = []\n            j = i\n            while visited_index[j] is False:\n                visited_index[j] = True\n                current_cycle.append(j+1)\n                j = map_positions[sorted_sequence[j]]\n            result.append(current_cycle)\n\n    output = [str(len(result))]\n    for subsequence in result:\n        output.append(\"{} {}\".format(len(subsequence), \" \".join(map(str, subsequence))))\n    return \"\\n\".join(output)"}
{"task_id": 2098, "completion": "from heapq import *\ndef min_bytecoins_needed(input1):\n    n,m = map(int,input1.split(\"\\n\")[0].split())\n    Party = [ [] for _ in range(m+1)]\n    for i in range(1,n+1):\n        p,c = map(int,input1.split(\"\\n\")[i].split())\n        Party[p].append(-c)\n    for i in range(2,m+1):\n        Party[i].sort()\n    Party[1].sort()\n    ans = [0]*5000\n    ans[len(Party[1])] = sum([-x for x in Party[1]])\n    heap = []\n    sum1 = 0\n    for i in range(2,m+1):\n        for j in range(len(Party[i])-1):\n            heappush(heap,-Party[i][j])\n            sum1 += -Party[i][j]\n    for i in range(len(Party[1])+1,n+1):\n        while len(heap)>=i:\n            sum1 -= -heappop(heap)\n        if len(Party[1])<i:\n            if not Party[1] or not heap or -Party[1][-1]>heap[0]:\n                break\n            sum1 += -Party[1][-1]\n            heappush(heap,-Party[1].pop())\n        ans[i] = ans[i-1]+sum1\n    return str(min(ans[l] for l in range(len(Party[1]),n+1)))+\"\\n\""}
{"task_id": 2189, "completion": "def game_winner(t, description):\n    results = []\n    for game in range(t):\n        n, piles = description[game]\n        total = sum(piles)\n        max_pile = max(piles)\n        if max_pile > total // 2 or total % 2 == 1:\n            results.append('T')\n        else:\n            results.append('HL')\n    return results\n\ndef from_input_string(input_string: str) -> 'Tuple':\n    inputs = input_string.strip().split('\\n')\n    t = int(inputs[0])\n    description = []\n    for i in range(1, len(inputs), 2):\n        n = int(inputs[i])\n        a = list(map(int, inputs[i+1].split()))\n        description.append((n, a))    \n    return t, description\n\ndef from_output_string(output_string: str) -> 'Any':\n    return output_string.strip().split('\\n')\n\ndef to_input_string(inputs: 'Tuple') -> str:\n    t, description = inputs\n    description_strs = ['\\n'.join([str(n), ' '.join(map(str, a))]) for n, a in description]\n    return '\\n'.join([str(t)] + description_strs)\n\ndef to_output_string(output: 'Any') -> str:\n    return '\\n'.join(output)"}
{"task_id": 2063, "completion": "def solve(input_str: str):\n    data = list(map(int, input_str.split()))\n\n    n, m = data[0], data[1]  # number of employees and languages\n\n    languages = list()\n    no_lang = True  # flag to indicate if an employee knows any languages\n\n    idx = 2  # index to access data\n    for i in range(n):\n        k = data[idx]  # number of languages employee i knows\n        idx += 1\n        temp = set()  # temporarily store languages an employee knows\n        for _i in range(k):\n            temp.add(data[idx])\n            idx += 1\n            no_lang = False\n        languages.append(temp)\n\n    if no_lang: return str(n)  # if none of the employees know any languages, the cost is the total number of employees.\n\n    visited = [False]*n  # to track visited employees\n    groups = []  # list of employee groups\n\n    for i in range(n):\n        if not visited[i]:  # if employee i is not visited\n            group = []  # to store group of employees that can correspond with each other\n            stack = [i]  # using a stack data structure for depth first search\n            while stack:\n                cur = stack.pop()\n                if visited[cur]: continue\n                visited[cur] = True\n                group.append(cur)\n                for j in range(n):\n                    if languages[cur] & languages[j]:  # if the common languages of employee cur and j is not empty, they are in the same group\n                        stack.append(j)\n            groups.append(group)\n\n    return str(len(groups)-1)"}
{"task_id": 2092, "completion": "def jinotega_flights(data):\n    flights_data = data.strip().split('\\n')\n    total_flights = int(flights_data[0])\n\n    # Jinotega returns home after every competition.\n    # So, if the total number of flights is even, Jinotega will be at home.\n    if total_flights % 2 == 0:\n        return 'home'\n    else:\n        return 'contest'"}
{"task_id": 2218, "completion": "def final_balances(s):\n    p = list(map(int, s.split()))\n    n = p[0]\n    a = [0] * n\n    x = [0] * n\n    m = [0] * (200007)\n    q = p[n+1]\n    o = [-1] * n\n    idx = 0\n    ptr = 1\n    m[idx] = 0\n    for i in range(n):\n        x[i] = p[i+1]\n    for _ in range(q):\n        y = p[ptr+n+1]\n        if y == 1:\n            p1 = p[ptr+n+2]-1 \n            p2 = p[ptr+n+3]\n            x[p1] = p2\n            o[p1] = idx\n        else:\n            idx += 1\n            m[idx] = max(m[idx-1], p[ptr+n+2])\n        ptr += y+1\n    for i in range(idx,0,-1):\n        m[i-1] = max(m[i-1], m[i])\n    for i in range(n):\n        a[i] = max(x[i], m[o[i]+1])\n    return a"}
{"task_id": 2224, "completion": "def find_number_of_ways(nstr, astr, bstr):\n    n = int(nstr)\n    a = list(map(int, astr))\n    b = list(map(int, bstr))\n\n    p = [[0, 0], [0, 0]]\n\n    for i in range(n):\n        p[a[i]][b[i]] += 1\n\n    return str(p[0][1] * p[1][0] + p[0][1] * p[1][1] + p[0][1] * p[0][0])"}
{"task_id": 2010, "completion": "def destroy_towers(input):\n    data = list(map(int, input.split()))\n    n = data.pop(0)\n    max_left = [0] * n\n    max_right = [0] * n\n    max_left[0] = max_right[n - 1] = 1\n\n    for i in range(1, n):\n        max_left[i] = min(max_left[i - 1] + 1, data[i])\n\n    for i in range(n - 2, -1, -1):\n        max_right[i] = min(max_right[i + 1] + 1, data[i])\n\n    max_days = max(min(max_left[i], max_right[i]) for i in range(n))\n    return str(max_days) + \"\\n\""}
{"task_id": 2064, "completion": "def solve_maze(game_input):\n    n, q, *flips = map(int, game_input.split())\n    grid = [[0] * n for _ in range(2)]\n    block = [0] * 3\n    result = []  \n    \n    for i in range(0, len(flips), 2):\n        row = flips[i] - 1\n        col = flips[i+1] - 1\n        neighbours = [(1-row, col + i) for i in range(-1,2) if 0<=col+i<n]\n        \n        for nr, nc in neighbours:\n            if grid[nr][nc] != 0:\n                block[grid[row][col]] -= 1\n                \n        grid[row][col] = 1 if grid[row][col] == 0 else 0\n        \n        for nr, nc in neighbours:\n            if grid[nr][nc] != 0:\n                block[grid[row][col]] += 1\n                \n        if block[1] > 0:\n            result.append(\"No\")\n        else:\n            result.append(\"Yes\")\n    return \"\\n\".join(result)"}
{"task_id": 2174, "completion": "def count_distinct_values(s):\n    nums = list(map(int, s.strip().split()))\n    n, a = nums[0], nums[1:]\n    distinct_values = set()\n    for i in range(n):\n        OR_values = {a[i]}\n        for j in range(i - 1, -1, -1):\n            if a[i] | a[j] == a[j]:\n                break\n            OR_values.add(a[i] | a[j])\n            a[j] = a[j] | a[i]\n        distinct_values |= OR_values\n    return len(distinct_values)"}
{"task_id": 2233, "completion": "def bubble_cuppolynomials(input):\n    MOD = 10**9 + 7\n    tests = input.split()\n    t = int(tests[0])\n    m = list(map(int, tests[1:]))\n    res = []\n    for i in range(t):\n        d = m[i]\n        answer = ((d // 2 + 1) ** 2) % MOD if d % 2 == 0 else ((d // 2 + 1) * (d // 2 + 2)) % MOD\n        res.append(str(answer))\n    return \"\\n\".join(res)"}
{"task_id": 2166, "completion": "import collections\n\ndef game_result(input):\n    # Parse the input\n    input = input.strip().split(\"\\n\")\n    n = int(input[0])\n    k1, *s1 = map(int, input[1].split())\n    k2, *s2 = map(int, input[2].split())\n\n    # Initialize the game states and count of remaining steps\n    dp = [[0]*n for _ in range(2)]\n    cnt = [[0]*n for _ in range(2)]\n    q = collections.deque([])\n\n    # Set the initial game states\n    dp[0][0] = dp[1][0] = -1\n    for i in range(1, n):\n        cnt[0][i] = k1\n        cnt[1][i] = k2\n        if k1 > k2:\n            dp[0][i] = 1\n            q.append((0, i))\n        elif k1 < k2:\n            dp[1][i] = 1\n            q.append((1, i))\n\n    # Perform a BFS to find all game outcomes\n    while q:\n        i, j = q.popleft()\n        for k in (s1 if i == 0 else s2):\n            nj = (j - k + n) % n\n            if dp[i^1][nj] != 0: \n                continue\n            if dp[i][j] == 1:\n                dp[i^1][nj] = -1\n            elif dp[i][j] == -1 and cnt[i^1][nj] > 1:\n                cnt[i^1][nj] -= 1\n            else:\n                dp[i^1][nj] = 1                \n            if dp[i^1][nj] != 0:\n                q.append((i^1, nj))\n\n    # Prepare the results for printing\n    states = ['Lose' if x == -1 else 'Win' if x == 1 else 'Loop' for x in dp[0][1:]]\n    rick_result = ' '.join(states)\n\n    states = ['Lose' if x == -1 else 'Win' if x == 1 else 'Loop' for x in dp[1][1:]]\n    morty_result = ' '.join(states)\n\n    return f'{rick_result}\\n{morty_result}\\n'"}
{"task_id": 2133, "completion": "def min_rooms(input_string):\n    input_lines = input_string.strip().split('\\n')\n    n = int(input_lines[0])\n    time_slots = [0]*7\n    \n    for group in input_lines[1:]:\n        for i, classes in enumerate(group):\n            if classes == '1':\n                time_slots[i] += 1\n    \n    return str(max(time_slots)) + '\\n'"}
{"task_id": 2184, "completion": "from collections import defaultdict\n\ndef nice_sequence(data):\n    data = data.strip().split('\\n')\n    n, q = map(int, data[0].split())\n    A = list(map(int, data[1].split()))\n    MX = max(A) + 2\n    inf = float('inf')\n    lmost = [inf] * MX\n    rmost = [-inf] * MX\n    freq = [0] * MX\n    cnt = [0] * MX\n\n    st = defaultdict(list)\n    for i in range(n):\n        st[A[i]].append(i)\n        \n    for x, arr in st.items():\n        for i in arr:\n            lmost[x] = min(lmost[x], i)\n            rmost[x] = max(rmost[x], i)\n            freq[x] += 1\n\n    block = []\n    for x in range(1, MX):\n        if freq[x]:\n            block.append([lmost[x], rmost[x], freq[x]])\n    block.sort()\n\n    for L, R, F in block:\n        cnt[R] = max(cnt[R], F)\n    for i in range(MX-1):\n        cnt[i+1] = max(cnt[i], cnt[i+1])\n        \n    return str(n - cnt[-1]) + \"\\\\n\""}
{"task_id": 2183, "completion": "def find_length(input_string):\n    MOD = 10**9 + 7\n    tests = input_string.strip().split('\\n')[1:]\n    results = []\n\n    for i in range(0, len(tests), 2):\n        x = int(tests[i])\n        s = list(map(int, tests[i+1]))\n        length = len(s)\n        cursor = 1\n        while cursor <= length: \n            length = (length + (length - cursor) * (s[cursor-1] - 1)) % MOD\n            for _ in range(s[cursor-1] - 1):\n                if len(s) < x:\n                    s += s[cursor:]\n            cursor += 1\n        results.append(str(length % MOD))\n\n    return \"\\n\".join(results)"}
{"task_id": 1607, "completion": "def count_qaq_subsequences(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] != 'Q':\n            continue\n        for j in range(i + 1, len(s)):\n            if s[j] != 'A':\n                continue\n            for k in range(j + 1, len(s)):\n                if s[k] == 'Q':\n                    count += 1\n    return count"}
{"task_id": 2190, "completion": "def psycho_killing_steps(input):\n    input_lines = input.strip().split('\\n')\n    n = int(input_lines[0])\n    psycho_ids = list(map(int, input_lines[1].split()))\n    steps = 0\n    while True:\n        killed = [False]*n\n        for i in range(n-1):\n            if psycho_ids[i] > psycho_ids[i+1]:\n                killed[i+1] = True\n        if all(not k for k in killed):\n            break\n        psycho_ids = [psycho_ids[i] for i in range(n) if not killed[i]]\n        n = len(psycho_ids)\n        steps += 1\n    return str(steps)"}
{"task_id": 2095, "completion": "def minimum_changes(n, nodes):\n    scc = [-1] * (n + 1)\n    stack = []\n    \n    def find(u):\n        if scc[u] < 0:\n            scc[u] = len(stack)\n            stack.append(u)\n            scc[u] = find(nodes[u])\n        elif scc[u] < len(stack):\n            cycle = stack[scc[u]:]\n            rep = min(cycle)\n            for v in cycle:\n                nodes[v] = rep\n            scc[u] = len(stack)\n        return scc[u]\n        \n    for u in range(1, n+1):\n        if scc[u] < 0:\n            find(u)\n    find(0)\n    \n    for u in range(1, n+1):\n        if scc[u] == -1:\n            scc[u] = scc[nodes[u]]\n\n    changes = sum(u != nodes[u] for u in range(1, n+1))\n    \n    return changes, nodes[1:]\n\ndef from_input_string(input_string: str):\n    data = input_string.strip().split('\\n')\n    n = int(data[0])\n    nodes = [0] + list(map(int, data[1].split()))\n    return n, nodes\n\ndef to_input_string(inputs) -> str:\n    n, nodes = inputs\n    nodes = ' '.join(str(i) for i in nodes[1:])\n    return \"{}\\n{}\".format(n, nodes)\n\ndef from_output_string(output_string: str):\n    data = output_string.strip().split('\\n')\n    changes = int(data[0])\n    parent = list(map(int, data[1].split()))\n    return changes, parent\n\ndef to_output_string(output) -> str:\n    changes, parent = output\n    parent = ' '.join(str(i) for i in parent)\n    return \"{}\\n{}\".format(changes, parent)"}
{"task_id": 2042, "completion": "from bisect import bisect_right\n\ndef max_photos(s):\n   s = s.strip().split(\"\\n\")\n    n, a, b, t = map(int, s[0].split())\n    arr = s[1]\n\n    p = [0] * (n + 1)\n    q = [0] * (n + 1)\n\n    tmp = ['h'] + list(arr) + ['h']\n    dis = [0] * (n + 2)\n\n    for i in range(1, n + 2):\n        dis[i] = dis[i - 1] + (tmp[i] == 'w') * b + 1\n\n    p[1] = min(n, bisect_right(dis, a + t))\n    l = a + t - dis[p[1]]\n\n    for i in range(1, n + 1):\n        p[i + 1] = min(n, bisect_right(dis, a * (n - i) + t - dis[p[i]] + dis[i]))\n        l = min(l, a * (n - i - 1) + t - dis[p[i + 1]] + dis[i + 1])\n\n    for i in range(n, 0, -1):\n        q[i] = max(q[i + 1], p[min(n, n - i + bisect_right(dis, l + dis[i]))] + i)\n\n    return str(max(p + q))"}
{"task_id": 2037, "completion": "def elevator_time(input):\n    input = input.split('\\n')\n    n = int(input[0])\n    ab = [list(map(int, x.split())) for x in input[1:n+1]]\n    up = [ [] for _ in range(10)]\n    down = [ [] for _ in range(10)]\n    for i, (a, b) in enumerate(ab):\n        if a < b:\n            up[a].append((b, i))\n        else:\n            down[a].append((b, i))\n    up = [sorted(x, reverse=True) for x in up]\n    down = [sorted(x) for x in down]\n    time = -3\n    now = 1\n    cnt = [-1]*n\n    while True:\n        while up[now] or down[now]:\n            while up[now] and (len(down[now]) == 0 or up[now][-1][1] < down[now][0][1]):\n                b, i = up[now].pop()\n                time += abs(b-now)+3\n                now = b\n                cnt[i] = time\n            while down[now] and (len(up[now]) == 0 or down[now][0][1] < up[now][-1][1]):\n                b, i = down[now].pop(0)\n                time += abs(b-now)+3\n                now = b\n                cnt[i] = time\n        nxt1 = nxt2 = 10\n        for i in range(now+1, 10):\n            if up[i] or down[i]:\n                nxt1 = i\n                break\n        for i in range(now-1, 0, -1):\n            if up[i] or down[i]:\n                nxt2 = i\n                break\n        if nxt1 == nxt2 == 10:\n            break\n        if nxt1 != 10 and (nxt2 == 10 or up[nxt1][-1][1] < down[nxt2][0][1]):\n            time += nxt1-now+2\n            now = nxt1\n        elif nxt2 != 10 and (nxt1 == 10 or down[nxt2][0][1] < up[nxt1][-1][1]):\n            time += now-nxt2+2\n            now = nxt2\n    return str(max(cnt))"}
{"task_id": 2199, "completion": "def max_happiness(s):\n    lines = s.split('\\n')[:-1]\n    n, k = map(int, lines[0].split())\n    graph = [[] for _ in range(n+1)]\n    for line in lines[1:]:\n        u, v = map(int, line.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visit = [0]*(n+1)\n    order = []\n    stack = [1]\n    while stack:\n        v = stack[-1]\n        if visit[v]:\n            stack.pop()\n            order.append((visit[v]-1-len(graph[v]), v))\n        else:\n            visit[v] = sum(visit[i] for i in graph[v] if visit[i]) + 1\n            stack += [i for i in graph[v] if not visit[i]]\n    order.sort(reverse=True)\n    return str(sum(i for i, v in order[:k]))"}
{"task_id": 2144, "completion": "def balance_boxes(inputs):\n    lines = inputs.strip().split('\\n')\n    k = int(lines[0])\n    boxes = []\n    sum_boxes = 0\n    val_to_box = {}\n    for i in range(1, k+1):\n        nums = list(map(int, lines[i].split()))\n        n, box = nums[0], nums[1:]\n        boxes.append(box)\n        sum_boxes += sum(box)\n        for v in box:\n            val_to_box[v] = i - 1\n    \n    if sum_boxes % k != 0:\n        return \"No\\n\"\n    \n    average = sum_boxes // k\n    chosen = [-1]*k\n    dest = [-1]*k\n    \n    for i, box in enumerate(boxes):\n        for v in box:\n            if chosen[i] != -1:\n                break\n            cycle = [i]\n            while True:\n                v = average - sum([boxes[j][chosen[j]] if chosen[j] != -1 else 0 for j in cycle])\n                if v in val_to_box and val_to_box[v] not in cycle:\n                    cycle.append(val_to_box[v])\n                elif len(cycle) > 1 and v == boxes[cycle[0]][chosen[cycle[0]] if chosen[cycle[0]] != -1 else 0]:\n                    break\n                else:\n                    cycle = []\n                    break\n            if cycle:\n                for j in range(len(cycle)):\n                    chosen[cycle[j]] = boxes[cycle[j]].index(v)\n                    dest[cycle[j]] = cycle[(j + 1) % len(cycle)]\n                break\n    \n    if min(chosen) == -1:\n        return \"No\\n\"\n    else:\n        res = \"Yes\\n\"\n        for i in range(k):\n            res += \"{} {}\\n\".format(boxes[i][chosen[i]], dest[i] + 1)\n        return res"}
{"task_id": 2170, "completion": "import heapq\n\ndef optimal_carrots_time(input_string):\n    data = input_string.split()\n    n = int(data[0])\n    k = int(data[1])\n    lengths = [int(x) for x in data[2:]]\n\n    pq = []\n    for i in lengths:\n        b = -1 * i * i\n        heapq.heappush(pq, [b,i,1])  # Priority is negative of square length of carrot\n        \n    for _ in range(k-n):\n        b, i, j = heapq.heappop(pq)\n        j += 1\n        a = i // j\n        c = i % j\n        b = -1 * (a*a*(j-c) + a*a*c + (a+1)*(a+1)*c)\n        heapq.heappush(pq, [b,i,j])\n\n    return str(-1 * sum(i[0] for i in pq)) + '\\n'"}
{"task_id": 2070, "completion": "def final_number(s):\n    mod = 10**9 + 7\n    input_list = list(map(int,s.split()))\n    n = input_list[0]\n    a = input_list[1:]\n    coef = [1]\n    for i in range(n): \n        coef.append((coef[-1] * (n - i)) % mod) \n        coef[-1] = (coef[-1] * pow(i + 1, mod - 2, mod)) % mod\n    a = sorted(a)\n    ans = 0\n    if n % 2 == 0:    \n        cur = [0, 0]\n        for i in range(n // 2):   \n            cur[0] += a[i] * coef[n // 2 - i - 1] % mod\n            cur[1] += a[-i - 1] * coef[n // 2 - i - 1] % mod\n        ans = (cur[0] - cur[1]) % mod\n    else:\n        cur = [0, 0]  \n        for i in range(n // 2):  \n            cur[0] += a[i] * coef[n // 2 - i] % mod   \n            cur[1] += a[-i - 1] * coef[n // 2 - i] % mod\n        ans = (cur[0] + cur[1]) * pow(2, mod - 2, mod)  \n        ans %= mod\n    return str(ans)"}
{"task_id": 2215, "completion": "import heapq\n\ndef max_train_routes(s):\n    n, m, k, *data = map(int, s.split())\n    INF = 10**15\n    edge = [[] for _ in range(n+1)]\n    dist = [INF for _ in range(n+1)]\n    shortest_train_route = [INF for _ in range(n+1)]\n    used_train_route = [False for _ in range(n+1)]\n    heap = []\n\n    for i in range(m):\n        u, v, x = data[3*i:3*i+3]\n        edge[u].append([x, v])\n        edge[v].append([x, u])\n\n    for i in range(m, m+k):\n        s, y = data[2*i:2*i+2]\n        edge[1].append([y, s])\n        shortest_train_route[s] = min(shortest_train_route[s], y)\n\n    dist[1] = 0\n    heapq.heappush(heap, (0, 1))\n\n    while heap:\n        v = heapq.heappop(heap)[1]\n        for l, u in edge[v]:\n            if dist[v] + l < dist[u]:\n                dist[u] = dist[v] + l\n                if l == shortest_train_route[u]:\n                    used_train_route[u] = True\n                heapq.heappush(heap, (dist[u], u))\n\n    return k - sum(used_train_route)"}
{"task_id": 2187, "completion": "def max_groups(n_str):\n    n = int(n_str)\n    if n == 1:\n        return [\"0\\n\"]\n\n    vis = [0 for _ in range(0, n + 1)]\n    ans = []\n    num = [i for i in range(0, n + 1)]\n  \n    for x in range(n, 1, -1):\n        if vis[x] == 0:\n            holder = []\n            for j in range(x, 0, -x):\n                if vis[j] == 0:\n                    holder.append(num[j])\n                    vis[j] = 1\n            if x == 2 and len(holder) % 2 != 0:\n                vis[holder[-1]] = 0\n                holder.pop()\n                ans[-1].append(2)\n            ans.extend([holder[i:i + 2] for i in range(0, len(holder), 2)])\n\n    cnt = sum([len(i) for i in ans]) // 2\n    ret = str(cnt) + '\\\\n'\n    for group in ans:\n        ret += \"{} {}\\\\n\".format(group[0], group[1])\n        \n    return [ret]"}
{"task_id": 2047, "completion": "from collections import deque\n\ndef parking_problem(s):\n    data = list(map(int, s.split()))\n    n, k, *data = data\n\n    # convert list to grid\n    grid = [data[n*i:n*(i+1)] for i in range(4)]\n    \n    # make positions queue\n    cars = deque([(2,i) for i in range(n)]+[(3,n-1-i) for i in range(n)])\n    \n    # move cars to its spots\n    moved = [False]*k\n    res = []\n    for _ in range(n*2):\n        x, y = cars[-1]\n        if grid[x][y] and [grid[x-2][y], grid[x+2][y]].count(grid[x][y]):\n            res.append((grid[x][y],y+1+(grid[x-2][y]==grid[x][y])*2))\n            moved[grid[x][y]-1] = True\n            grid[x][y] = 0\n        cars.rotate(1)\n\n    moves = -1\n    while not all(moved) and moves:\n        x0, y0 = cars[-1]\n        x1, y1 = cars[0]\n        moved = [False]*k\n        res = []\n        moves = 20000\n        while moves and not all(moved):\n            if x0==x1 and grid[x1][y1]:\n                res.append((grid[x1][y1],y1+1+2*(x1<2)))\n                moved[grid[x1][y1]-1] = True\n                grid[x1][y1] = 0\n                x0, y0 = x1, y1\n            elif grid[x1][y1]:\n                x0, y0 = x1, y1\n                cars.rotate(1)\n                x1, y1 = cars[0]\n                moves -= 1\n            else:\n                grid[x0][y0], grid[x1][y1] = 0, grid[x0][y0]\n                res.append((grid[x1][y1],y1+1+(x1<2)*2))\n                cars.rotate(1)\n                x1, y1 = cars[0]\n                moves -= 1\n\n    if any(grid[i][j] for i in [1,2] for j in range(n)):\n        return '-1'\n        \n    return f\"{len(res)}\\n\" + \"\\n\".join(f\"{a} {b} {c}\" for a, b, c in res)"}
{"task_id": 2026, "completion": "def minimum_cost_to_reach_station_n(input1):\n    input_lines = [x for x in input1.split('\\n') if x]\n    n, d = map(int, input_lines[0].split())\n    a = [0] + list(map(int, input_lines[1].split())) + [0]\n    coordinates = [list(map(int, line.split())) for line in input_lines[2:]]\n    dp = [float('inf')]*n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + d *(abs(coordinates[i][0]-coordinates[j][0])+abs(coordinates[i][1]- coordinates[j][1]))-a[i])\n    return str(dp[-1]) + \"\\n\""}
{"task_id": 2146, "completion": "def max_fun_factor(s):\n    n, d, m = map(int,s.strip().split()[0:3])\n    a = list(map(int,s.strip().split()[3:]))\n    less = []\n    more = []\n    \n    # Separating the numbers greater than m and less than or equal to m.\n    for i in a:\n        if i > m:\n            more.append(i)\n        else:\n            less.append(i)\n    less.sort(reverse=True)\n    more.sort()\n    \n    while len(less) < n : less.append(0) \n    \n    # Pre-calculation\n    for i in range(n-2, -1, -1) : less[i] += less[i + 1]\n    \n    ans = 0\n    sum = 0\n    \n    # Trying different combinations\n    for i in range(len(more)) :\n        if i*d <= n:  \n            sum += more[i]\n            ans_now = sum\n            if i*d < n:\n                ans_now += less[i*d+1]\n            ans = max(ans, ans_now)\n    if d*(len(more)-1) < n : ans = max(ans, sum + less[d*len(more)])\n    return str(ans)+'\\n'"}
{"task_id": 2159, "completion": "def max_interest(s):\n    info = s.strip().split('\\n')\n    n, T = map(int, info[0].split())\n    tasks = []\n    for line in info[1:]:\n        t, q = map(int, line.split())\n        tasks.append((t, q))\n    # Sort tasks by time in descending order\n    tasks.sort(key=lambda x: -x[0])\n    # Initialize DP table\n    dp = [0 for _ in range(T+2)]\n    for i in range(1, n+1):\n        for j in range(T, tasks[i-1][0]-1, -1):\n            # Here we check max between not taking the task or taking the task.\n            dp[j+1] = max(dp[j+1], dp[j-tasks[i-1][0]+1] + tasks[i-1][1])\n    return str(max(dp))"}
{"task_id": 2009, "completion": "def min_distance(test):\n    data = test.strip().split('\\n')\n    n = int(data[0])\n    vectors = []\n    ans = [1]*n\n    for i in range(1, n+1):\n        x, y = map(int, data[i].split())\n        vectors.append((x*x+y*y, i-1))\n    vectors.sort(reverse = True)\n    curx = cury = p = 0\n    for i in range(n):\n        if abs(p+vectors[i][0]) <= abs(p-vectors[i][0]):\n            p += vectors[i][0]\n        else:\n            p -= vectors[i][0]\n            ans[vectors[i][1]] = -1\n    return ' '.join(map(str, ans)) + ' \\n'"}
{"task_id": 2066, "completion": "def warrior_and_archer_fight(input_string):\n    data = list(map(int, input_string.split()))\n    n = data[0]\n    positions = data[1:]\n    positions.sort()\n    min_distance = float(\"inf\")\n    for i in range(n // 2):\n        min_distance = min(min_distance, positions[i + n // 2] - positions[i])\n    return str(min_distance)"}
{"task_id": 2104, "completion": "def minimal_area(data):\n    n, *a = map(int, data.split())\n    a.sort()\n    area = a[n - 1] * a[n]\n    for i in range(n):\n        area = min(area, a[i]*a[2*n-i-1])\n    return str(area)\n\nprint(minimal_area('4 4 1 3 2 3 2 1 3')) # Output: 1\nprint(minimal_area('3 5 8 5 5 7 5')) # Output: 0"}
{"task_id": 2075, "completion": "def bigger_catch(input):\n    input_lines = input.strip().split(\"\\n\")\n    n, m, k = map(int, input_lines[0].split())\n    alice_catch = list(map(int, input_lines[1].split()))\n    bob_catch = list(map(int, input_lines[2].split()))\n    alice_catch.sort(reverse=True)\n    bob_catch.sort(reverse=True)\n    bob_catch += [0]*(n-m)\n    for a, b in zip(alice_catch, bob_catch):\n        if a > b:\n            return 'YES'\n    return 'NO'"}
{"task_id": 2000, "completion": "from heapq import heappush, heappop\n\ndef minimum_time(s):\n    data = s.split('\\n')\n    n, m, a, b = map(int, data[0].split())\n    edge = [list(map(int, line.split())) for line in data[1:-1]]\n    g = [[] for _ in range(n+1)]\n    G = [[] for _ in range(n+1)]\n    ans = [b*70]*n\n    ans[0] = 0\n    E = [[] for _ in range(n+1)]\n    mark = [0]*(n+1)\n    cnt = [0]*(n+1)\n    c = [0]*71\n    d = [[b*71]*71 for _ in range(71)]\n    edge.sort(key=lambda x: -x[2])\n    for u, v, cost in edge:\n        G[u-1].append([v-1, b])\n        G[v-1].append([u-1, b])\n        if cost == a:\n            g[u-1].append(v-1)\n            g[v-1].append(u-1)\n            E[u-1].append([v-1, a])\n            E[v-1].append([u-1, a])\n    used = [0]*(n+1)\n    used[0] = 1\n    q = [0]\n    pnt = 0\n    while len(q) > pnt:\n        x = q[pnt]\n        pnt += 1\n        for y in g[x]:\n            if not used[y]:\n                used[y] = 1\n                q.append(y)\n    for x in range(n):\n        if not c[used[x]]:\n            c[used[x]] = min(q[x] for x in g[x]) if g[x] else x\n    for h in c:\n        if h:\n            cnt[h] += 1\n    for h in c:\n        if h and cnt[h] >= 3:\n            mark[h] = 1\n    d[0][0] = 0\n    for x in range(1, n+1):\n        for y in range(n, -1, -1):\n            for z in range(x):\n                d[x][y] = min(d[x][y], d[z][y] + (x-z-1)*b)\n            if y:\n                d[x][y] = min(d[x][y], min(d[z][y-1] + (x-z)*b for z in range(x)))\n    for _ in range(n):\n        q = []\n        heappush(q, (ans[_], _, _))\n        while q:\n            cost, x, prer = heappop(q)\n            if cost > ans[x]:\n                continue\n            for to, cos in G[x]:\n                if c[used[to]] and c[used[to]] != c[used[prer]] and mark[c[used[to]]]:\n                    ncost = d[cnt[c[used[to]]]][min(cnt[c[used[to]]], n-1)] + cost\n                else:\n                    ncost = cost + cos\n                if ncost < ans[to]:\n                    heappush(q, (ncost, to, to if c[used[to]] else prer))\n                    ans[to] = ncost\n    return \" \".join(map(str, ans[0:n])) + \"\\n\""}
{"task_id": 2065, "completion": "def matryoshka_dolls(dolls):\n    input_lines = dolls.strip().split(\"\\n\")\n    n, k = map(int, input_lines[0].split())\n    data = [0]*n\n    remaining = n\n    total = 0\n    for i in range(k):\n        a = list(map(int,input_lines[i+1].split()))[1:]\n        cur = 1\n        while len(a) > 0 and a[0] == cur:\n            a.pop(0)\n            cur += 1\n            remaining -= 1\n        total += 2*len(a)\n    return str(total+remaining-1)"}
{"task_id": 2198, "completion": "def solve(input):\n    input = input.split('\\n')\n    n = int(input[0])\n    names = set()\n    for i in range(1, n + 1):\n        name = list(input[i])\n        replaced_name = []\n        j = len(name) - 1\n        while j >= 0:\n            if name[j] == 'h':\n                if len(replaced_name) > 0 and replaced_name[-1] == 'k':\n                    replaced_name.pop()\n                    replaced_name.append('h')\n                else:\n                    replaced_name.append('h')\n                j -= 1\n            elif name[j] == 'u':\n                if j > 0 and name[j - 1] == 'o':\n                    j -= 2\n                else:\n                    replaced_name.append('o')\n                    replaced_name.append('o')\n                    j -= 1\n            else:\n                replaced_name.append(name[j])\n                j -= 1\n        replaced_name.reverse()\n        names.add(''.join(replaced_name))\n    return str(len(names))"}
{"task_id": 2073, "completion": "def max_lucky_number(s):\n    n, s = s.split('\\n', 1)\n    s = list(map(int, s.split()))\n    s.append(0)\n    stack = []\n    max_lucky_num = 0\n\n    for num in s:\n        while stack and stack[-1] < num:\n            max_lucky_num = max(max_lucky_num, stack[-1] ^ num)\n            stack.pop()\n\n        if stack:\n            max_lucky_num = max(max_lucky_num, stack[-1] ^ num)\n        \n        stack.append(num)\n\n    return str(max_lucky_num)"}
{"task_id": 2126, "completion": "from math import gcd\n\ndef gcdlcm_pairs(n, sequence):\n        # Sorting the sequence\n    sequence.sort()\n    \n    # Initialize the pre_gcd and post_gcd lists\n    pre_gcd = [0] * n\n    post_gcd = [0] * n\n    \n    # Calculate pre_gcd and post_gcd for each number in the sequence\n    pre_gcd[0] = sequence[0]\n    post_gcd[-1] = sequence[-1]\n    for i in range(1, n):\n        pre_gcd[i] = gcd(pre_gcd[i - 1], sequence[i])\n    for i in range(n - 2, -1, -1):\n        post_gcd[i] = gcd(post_gcd[i + 1], sequence[i])\n    \n    # Calculate the gcd of lcm of all pairs in the sorted sequence\n    pairs_gcd = max([pre_gcd[i-1]*sequence[i]//gcd(pre_gcd[i-1],sequence[i]) for i in range(1, n)])\n\n    return pairs_gcd\n  \n\ndef from_input_string(input_string: str) -> tuple:\n    # Split the input_string into data\n    # The first element is n, the number of integers in the sequence\n    # The second element is the list of numbers in the sequence\n    # n is integer and the list is a mapping of integer values\n    data = input_string.strip().split('\\n')\n    n = int(data[0])\n    sequence = list(map(int, data[1].split(' ')))\n    return n, sequence\n\ndef from_output_string(output_string: str):\n    # The output_string is the gcd value of lcm of all pairs in the sequence\n    # It is an integer value\n    return int(output_string)\n\ndef to_input_string(inputs: tuple) -> str:\n    # Convert the input tuple into an input_string\n    # n is the number of integers in the sequence\n    # sequence is a list of integers\n    n = inputs[0]\n    sequence = ' '.join(str(num) for num in inputs[1])\n    return f\"{n}\\n{sequence}\"\n\ndef to_output_string(output) -> str:\n    # Convert the output integer value into output_string\n    return str(output)"}
{"task_id": 2012, "completion": "def lucky_permutation(n):\n    n = int(n)\n    \n    if n % 4 > 1:\n        return \"-1\\n\" \n    \n    perm = list(range(1, n+1))\n    for i in range(0, n, 2):\n        perm[i], perm[-i-1] = perm[-i-1], perm[i]\n\n    return perm"}
{"task_id": 2162, "completion": "def tree_shrink(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    p2 = [1.0]\n    for _ in range(n):\n        p2.append(p2[-1]*0.5)\n\n    nCr = [[1.0]]\n    for i in range(1, n+1):\n        nCr.append([1.0])\n        for j in range(1, i+1):\n            nCr[i].append(nCr[i-1][j-1] + nCr[i-1][j])\n\n    size = [0]*n\n    dp1 = [0]*n\n    dp2 = [1]*n\n    parent = [-1]*n\n\n    queue = deque([0])\n    while queue:\n        x = queue.popleft()\n        for y in graph[x]:\n            if parent[y] != -1:\n                continue\n            parent[y] = x\n            queue.append(y)\n            size[x] += 1\n\n    for x in reversed(queue):\n        suffix = [0.0]*(size[x]+2)\n        suffix[size[x]+1] = 1.0\n        for i in range(size[x], 0, -1):\n            suffix[i] = suffix[i+1] + p2[i+1]*nCr[size[x]][i]*dp2[graph[x][i-1]]\n        prefix = [0.0]*(size[x]+2)\n        prefix[0] = 1.0\n        dp1[x] = 0.5*dp2[x]\n        for i in range(1, size[x]+1):\n            y = graph[x][i-1]\n            dp1[x] += 0.5*p2[i+1]*nCr[size[x]][i]*prefix[i-1]*suffix[i+2]*dp1[y]\n            prefix[i] = prefix[i-1] + p2[i+1]*nCr[size[x]][i]*dp2[y]\n        dp2[x] *= 0.5*prefix[size[x]]\n\n    total = sum(dp1)\n    return [\"{:.10f}\".format(dp1[x]/total) for x in range(n)]"}
{"task_id": 2192, "completion": "from bisect import bisect_right\n\ndef min_beacons_destroyed(s):\n    s = s.strip().split('\\n')\n    n = int(s[0])\n    ab = sorted([[int(e) for e in r.split()] for r in s[1:]])\n    dp = [1]*n\n    p = [0]*n\n    a = [e[0] for e in ab]\n    if n > 1:\n        dp[1] = 1\n    for i in range(2, n):\n        j = bisect_right(a, a[i] - ab[i][1] - 1)\n        if j > 0: \n            dp[i] = dp[j - 1] + (i - j)\n        dp[i] = min(dp[i], dp[i - 1])\n        \n    return str(n - dp[-1])+'\\n'"}
{"task_id": 2056, "completion": "def min_cost(input_string):\n    lines = input_string.strip().split('\\n')\n    n = int(lines[0])\n    a, b = lines[1], lines[2]\n    one = zero = 0\n    cost = 0\n    for i in range(n):\n        if b[i] == '0':\n            if a[i] == '1': \n                one += 1\n            if zero > 0:\n                zero -= 1\n                cost += 1\n        else:\n            if a[i] == '0':\n                zero += 1\n            if one > 0:\n                one -= 1\n                cost += 1\n    return str(cost)"}
{"task_id": 2060, "completion": "def minimal_processing_time(input):\n    n, k, *a = map(int, input.split())\n    a.sort()\n    dp = [-1] + [0]*(n+1)\n    ok = [0]*(n+1)\n    ok[0] = 1\n    for i in range(n):\n        if ok[i]:\n            for j in range(i+k, min(i+2*k, n+1)):\n                if a[j-1] - a[i] >= a[i+k-j] - a[i]:\n                    ok[j] = 1\n                else:\n                    break\n        dp[i+1] = max(dp[i+1], dp[i])\n        if ok[i+1]:\n            dp[i+1] = max(dp[i+1], dp[i] + a[i+1] - a[i])\n\n    return str(dp[-2]) + '\\n'"}
{"task_id": 2087, "completion": "def min_energy(input1):\n    n, l, r, ql, qr, w = map(str.split, map(str.strip, input1.splitlines()))\n    n, l, r, ql, qr = map(int, [n, l, r, ql, qr])\n    w = list(map(int, w))\n\n    S = [0]*(n+2)\n    S[n+1] = w[n-1]\n    for i in reversed(range(1,n)): S[i] = S[i+1]+w[i-1]\n    S[0] = w[0]\n\n    E = [None]*(n+2)\n    E[0] = r*S[1]\n    E[1] = r*S[1]\n    for i in range(2, n+1):\n        E[i] = min( l*S[i-1]+r*S[i], E[i-1]+(2*ql if i<n else ql) )\n        E[i] = min( E[i], E[i-2]+(2*qr if i>1 else qr) )\n        \n    return str(E[-2])+\"\\n\""}
{"task_id": 2130, "completion": "MOD = 10**9+7\nfact = []\ninv = [1]\nmodInv = [1]\n\ndef prepare(n):\n    for i in range(len(fact), n+1):\n        fact.append(fact[-1]*i%MOD)\n        inv.append(pow(i, MOD-2, MOD))\n        modInv.append(inv[-1]*modInv[-1]%MOD)\n\ndef number_of_ways(input_string: str) -> str:\n    data = list(map(int, input_string.split()))\n    k, balls = data[0], data[1:]\n    total = sum(balls)\n    ways = 1\n    prepare(total)\n    for i in range(k):\n        ways *= fact[total]*modInv[balls[i]]*modInv[total-balls[i]]%MOD\n        total -= balls[i]\n    return str(ways)+\"\\n\""}
{"task_id": 2160, "completion": "from collections import deque\n\ndef solve(input_string):\n    # Split input string into list\n    input_list = input_string.strip().split('\\n')\n\n    # Assign valuesfrom split input list\n    n, k = map(int, input_list[0].split())\n    videos = deque(map(int, input_list[1].split()))\n\n    # Calculate total video duration\n    sum_videos = sum(videos)\n\n    # Check if total video duration can be evenly split into k posts\n    if sum_videos % k != 0:\n        return \"No\"\n\n    target_sum = sum_videos // k\n    counts = []\n    curr_sum = 0\n    curr_count = 0\n\n    # Iteratively sum video durations and count posts\n    while videos:\n        curr_sum += videos.popleft()\n        curr_count += 1\n\n        # Once target sum duration reached, count post and reset count/sum\n        if curr_sum == target_sum:\n            counts.append(curr_count)\n            curr_sum = 0\n            curr_count = 0 \n        elif curr_sum > target_sum:  # Videos cannot be grouped into a post\n            return \"No\"\n    \n    # If all videos can be posted, print YES and number of videos per post\n    if len(counts) == k:\n        posts = \" \".join(map(str, counts)) + \" \"\n        return \"Yes\\n\" + posts\n\n    # Else, print NO\n    else:\n        return \"No\""}
{"task_id": 2153, "completion": "def solve(n):\n    n = int(n)        \n    # if there are 3 vertices we know the arrangement\n    if n == 3:\n        return \"2\\n3 1 2 3\\n3 1 2 3\"\n    else:\n        cycles = []\n        for i in range(1, n+1, 2):\n            a, b = i, i+1 if i+1 <= n else 1\n            # add two cycles of 4 vertices\n            cycles.append('4 {} {} {} {}'.format(a, b, (a+1)%n+1, a%n+1))\n            cycles.append('4 {} {} {} {}'.format(a, b, (b+1)%n+1, a%n+1))\n        # if n is even, need to add four cycles of 3 vertices to cover all edges\n        if n % 2 == 0:\n            cycles.append('3 {} {} {}'.format(n-2, n-1, n))\n            cycles.append('3 {} {} {}'.format(n-2, n, n-1))\n            cycles.append('3 {} {} {}'.format(n-1, n-2, n))\n            cycles.append('3 {} {} {}'.format(n-1, n, n-2))  \n        return str(len(cycles)) + '\\n' + '\\n'.join(cycles)\n\nprint(solve('3'))\nprint(solve('5'))"}
