{"task_id": 0, "completion": "def sort_asc_desc(input_str):\n    # Split the input string into numbers and titles\n    input_lines = input_str.strip().split('\\n')\n    nm = list(map(int, input_lines[0].split()))\n    titles = input_lines[1:]\n\n    books = []\n    \n    # Apply the transformation to each title\n    for i, title in enumerate(titles):\n        new_title = ''.join([chr(155 - ord(title[j])) if j % 2 else title[j] for j in range(len(title))])\n        books.append((i + 1, new_title))\n    \n    # Sort books based on the transformed title\n    books.sort(key=lambda x: x[1])\n    \n    # Return the sorted book indices\n    return ' '.join(str(book[0]) for book in books)"}
{"task_id": 1, "completion": "import math\n\ndef min_radius_for_park(data):\n    n, k, *coordinates = data.split()\n    n, k = int(n), int(k)\n  \n    habitats = [tuple(map(int, x.split())) for x in range(0, len(coordinates), 2)]\n    habitats.sort(key = lambda xy: xy[0]**2 + xy[1]**2)\n    \n    l, r = 0, 2e5\n    while r-l > 1e-7:\n        m = (r+l) / 2\n        if sum(1 for xy in habitats if xy[0]**2 + xy[1]**2 <= m**2) >= k:\n            r = m\n        else:\n            l = m\n\n    return f\"{l:.9f}\"\n\nprint(min_radius_for_park('8 4 -3 1 -4 4 1 5 2 2 2 -2 -2 -4 -1 -1 -6 0')) \n"}
{"task_id": 2, "completion": "def solve(s):\n    MOD = 10**9 + 7\n    n, m, k, *a = map(int, s.split())\n    b = a * min(2, m)\n    p = [0] * (2*n+1)\n    dp = [0] * (2*n+1)\n    p[0] = 1\n    ans = j = sum = 0\n    for i in range(1, len(b)+1):\n        sum = (sum+b[i-1])%k\n        while j < min(i-1, n):\n            j += 1\n            dp[j] = (dp[j-1]+b[j-1])%k\n            p[dp[j]] += 1\n        if i > n:\n            dp[i-n-1] = (dp[i-n]+b[i-n-1])%k\n            p[dp[i-n-1]] -= 1\n        ans = (ans+p[sum])%MOD\n\n    return str(ans)\n"}
{"task_id": 3, "completion": "def check(a, b):\n    for i in range(len(a)):\n        if a[i] == 'X':\n            if b[i] == '0' and i == 0:\n                return False\n            if b[i] != a[a.index('X')]:\n                return False\n        elif a[i] == '_':\n            if b[i] == '0' and i == 0:\n                return False\n        elif a[i] != b[i]:\n            return False\n    return True\n\ndef solve(s, cnt = 100):\n    total = 0\n    for i in range(cnt):\n        if check(s, str(i).zfill(len(s))) and i % 25 == 0:\n            total += 1\n    return total\n"}
{"task_id": 4, "completion": "def process_input(input_str):\n    MOD = 10**9 + 7\n    data = input_str.splitlines()\n    \n    N, K = map(int, data[0].split())\n    A = list(map(int, data[1].split()))\n    E = [[] for _ in range(N)]\n    dp = [[[0, 0] for _ in range(K + 2)] for _ in range(N)]\n    nex_dp = [[0, 0] for _ in range(K + 2)]\n    \n    for line in data[2:]:\n        u, v, c = map(int, line.split())\n        u -= 1\n        v -= 1\n        E[u].append((v, c ^ 1))\n        E[v].append((u, c ^ 1))\n    \n    def dfs(pos, parent):\n        ch = len(E[pos])\n        for nex, c in E[pos]:\n            if nex == parent:\n                continue\n            dfs(nex, pos)\n            for ki in range(K + 1)[::-1]:\n                for ci in range(ch + 1)[::-1]:\n                    nex_dp[ki][ci] = dp[pos][ki][ci]\n                    if ki + 1 <= K: \n                        nex_dp[ki + 1][ci] = max(nex_dp[ki + 1][ci], dp[pos][ki][ci] + dp[nex][0][c])\n                    nex_dp[ki][ci + 1] = max(nex_dp[ki][ci + 1], dp[pos][ki][ci] + dp[nex][0][c ^ 1])\n                    if ki + 1 <= K: \n                        nex_dp[ki + 1][ci + 1] = max(nex_dp[ki + 1][ci + 1], dp[pos][ki][ci] + dp[nex][0][c])\n                dp[pos][ki][ch] = max(nex_dp[ki][ch], dp[pos][ki][ch] + A[pos])\n                dp[pos][ki][ch + 1] = max(nex_dp[ki][ch + 1], dp[pos][ki][ch + 1] + A[pos] * 2)\n            for ki in range(K + 2): \n                dp[pos][ki][ch + 1] %= MOD\n        for ki in range(K, 0, -1): \n            dp[pos][ki - 1][ch] = max(dp[pos][ki - 1][ch], dp[pos][ki][ch])\n    \n    dfs(0, -1)"}
{"task_id": 5, "completion": "def solve_problem(s):\n    MOD = pow(10, 9) + 7\n    def expmod(base, exp, mod):\n        if exp == 0:\n            return 1\n        elif exp % 2 == 0:\n            return expmod(base * base % mod, exp / 2, mod)\n        else:\n            return base * expmod(base, exp - 1, mod) % mod\n\n    def calc(s, k, nk, a):\n        ret, su, num, K = 0, 0, 0, pow(k, MOD - 2, MOD)\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == -1:\n                ret += su * nk % MOD * K % MOD\n                ret %= MOD\n                num += nk\n                nk = nk * k % MOD\n            else:\n                tmp = (a[i] * (s[i + 1] + 1) % MOD - su + num * K % MOD) * K % MOD\n                ret += tmp * nk\n                ret %= MOD\n                su += tmp\n        return ret\n\n    lines = s.strip().split()\n    n, k = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    nk = s = [0] * (n + 3)\n    s[n] = 0\n    nk[n] = 1\n    if a[n - 1] == -1:\n        nk[n - 1] = k\n    for i in range(n - 1, -1, -1):\n        s[i] = s[i + 1]\n        if a[i] != -1:\n            s[i] += a[i]\n        s[i] %= MOD\n        nk[i] = nk[i + 1]\n        if a[i] == -1:\n            nk[i] = nk[i] * k % MOD\n    ret = calc(s, k, nk[0], a)\n\n    a.reverse()\n    s = [0] * (n + 3)\n    nk = [0] * (n + 3)\n    if a[0] == -1:\n        nk[0] = k\n    for i in range(1, n + 1):\n        s[i] = s[i - 1]\n        if a[i - 1] != -1:\n            s[i] += a[i - 1]\n        s[i] %= MOD\n        nk[i] = nk[i - 1]\n        if a[i] == -1:\n            nk[i] = nk[i] * k % MOD\n        ret = (ret + calc(s, k, nk[i], a[i:] + [-2] * i)) % MOD\n\n    return ret\n\nprint(solve_problem('10 9\\n-1 0 -1 1 1 2 2 3 3 3\\n'))\n"}
{"task_id": 6, "completion": "def calculate_result(input_str):\n    MOD = 10**9 + 7\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def compute_gcds(a, n):\n        gcd_matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                gcd_matrix[i][j] = gcd(a[i], a[j])\n        return gcd_matrix\n\n    def compute_index_gcds(n):\n        index_gcd_matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                index_gcd_matrix[i][j] = gcd(i + 1, j + 1)\n        return index_gcd_matrix\n\n    lines = input_str.strip().split('\\n')\n    n = int(lines[0])\n    a = list(map(int, lines[1].split()))\n\n    # Compute all gcd values for elements in a\n    gcd_matrix = compute_gcds(a, n)\n\n    # Compute all gcd values for indices\n    index_gcd_matrix = compute_index_gcds(n)\n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            term = (gcd_matrix[i][j] * index_gcd_matrix[i][j]) % MOD\n            result = (result + term) % MOD\n\n    return str(result) + \"\\n\""}
{"task_id": 7, "completion": "def min_changes(input_string):\n    input_list = input_string.strip().split('\\n')\n    n, m = map(int, input_list[0].split())\n    a = input_list[1]\n    b = input_list[2]\n    count, dp, result = [0]*(n+1), [[0]*(n+1) for _ in range(n+1)], []\n    inf = float('inf')\n\n    for i in range(m-1, n):\n        count[i+1] = count[i+1-m] + sum(1 for j in range(m) if a[i-m+1+j] != b[j])\n\n    for i in range(n+1):\n        dp[i][0] = count[i]\n        for j in range(1, min(i, n-m+1)+1):\n            dp[i][j] = min(dp[i-1][j], dp[i-m][j-1] + count[i] - count[i-m])\n\n    for i in range(n-m+2):\n        result.append(str(min((dp[j][i] if j>=i else inf) for j in range(n+1))))\n\n    return result\n\nprint(min_changes('9 3\\n100101011\\n101\\n'))\n"}
{"task_id": 8, "completion": "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10**6)\nf = defaultdict(list)\ng = [0]*200010\nh = [0]*200010\ne = [0]*200010\np = [[0]*20 for _ in range(200010)]\nd = [0]*200010\na = [0]*200010\ng1 = [0]*200010\ng2 = [0]*200010\nu = [0]*200010\nb = [0]*200010\nv = [0]*200010\n\ndef dfs(x,fa):\n\td[x] = d[fa]+1\n\tp[x][0] = fa\n\tfor i in range(1,18):\n\t\tp[x][i] = p[p[x][i-1]][i-1]\n\tfor i in range(len(f[x])):\n\t\tif f[x][i] == fa: continue\n\t\tdfs(f[x][i],x)\n\t\tg[x] = max(g[x],g[f[x][i]])\n\ndef lca(x,y):\n\tif d[x]<d[y]: x,y=y,x\n\tfor i in range(17,-1,-1):\n\t\tif d[p[x][i]]>=d[y]: x = p[x][i]\n\tif x == y: return x\n\tfor i in range(17,-1,-1):\n\t\tif p[x][i] != p[y][i]: x,y = p[x][i],p[y][i]\n\treturn p[x][0]\n\ndef solve(input):\n\tz = list(map(int,input.split()))\n\tk = 4\n\tfor i in range(3,z[0]*2,2):\n\t\tv = z[k]-1\n\t\tu = z[k+1]-1\n\t\tf[v].append(u)\n\t\tf[u].append(v)\n\t\tk += 2\n\tfor i in range(z[0]+2):\n\t\tg[i] = -2e18\n\tg[z[1]+1] = a[z[1]]\n\tdfs(z[1],0)\n\tb[0] = a[z[1]+1]\n\tfor _ in range(z[1]):\n\t\ttt = z[k]\n\t\tif tt == 1: a[z[k+1]] = z[k+2]\n\t\telse:\n\t\t\tx = z[k+1]+1\n\t\t\ty = z[k+2]+1\n\t\t\tt1 = max(g1[x]+a[y],g2[y]+a[x])-2*a[lca(x-1,y-1)]\n\t\t\tt2 = max(g2[x]+a[y],g1[y]+a[x])-2*a[lca(x-1,y-1)]\n\t\t\tprint('\\n'.join(b))\n\t\t\tb.append(str(max(t1,t2)))\n\t\tk += 3\n\treturn '\\n'.join(b)"}
{"task_id": 9, "completion": "def solve(input_str):\n    input_lines = input_str.strip().splitlines()\n\n\n    n, m, k = map(int, input_lines[0].split())\n    grid = [list(map(int, line.split())) for line in input_lines[1:n + 1]]\n    starting_cols = list(map(int, input_lines[n + 1].split()))\n\n\n    def drop_ball(grid, start_col, n, m):\n        row, col = 0, start_col - 1\n        while row < n:\n            direction = grid[row][col]\n            if direction == 1:\n                if col + 1 < m:\n                    col += 1\n                grid[row][col - 1] = 2\n            elif direction == 3:\n                if col - 1 >= 0:\n                    col -= 1\n                grid[row][col + 1] = 2\n            else:\n                grid[row][col] = 2\n                row += 1\n        return col + 1\n\n\n    result = []\n    for start_col in starting_cols:\n        result.append(str(drop_ball(grid, start_col, n, m)))\n\n    return ' '.join(result)"}
{"task_id": 10, "completion": "def calc_colors(input_string):\n    MOD = 10**9 + 7\n    input_lines = input_string.strip().split(\"\\n\")\n    n, m, k, r, c = map(int, input_lines[0].split())\n    ax, ay, bx, by = map(int, input_lines[1].split())\n\n    def power(x, y):\n        res = 1\n        x = x % MOD\n        while y > 0:\n            if y & 1:\n                res = (res*x) % MOD\n            y = y>>1\n            x = (x*x) % MOD\n        return res\n\n    def cell(x, y):\n        min_rc = min(r, x), min(c, y)\n        max_rc = max(0, x-r+1), max(0, y-c+1)\n        return min_rc[0] * min_rc[1], max_rc[0] * max_rc[1]\n\n    def area(x, y):\n        return x*y % MOD\n\n    p1 = power(k, area(*cell(n, m)))\n    p2 = (power(k, area(*cell(ax+r-1, ay+c-1))) * power(k, area(*cell(bx+r-1, by+c-1)))) % MOD\n    p3 = (power(k, area(*cell(min(ax, bx)+r-1, min(ay, by)+c-1))) * power(k, area(*cell(max(ax, bx), max(ay, by)))) % MOD\n  \n    return str((p1*p2*power(p3, MOD-2)) % MOD)\n\nprint(calc_colors(\"3 3 2 2 2\\n1 1 2 2\"))  # Outputs: 32\nprint(calc_colors(\"4 5 170845 2 2\\n1 4 3 1\"))  # Outputs: 756680455\n"}
{"task_id": 11, "completion": "def max_sequence(input_str):\n    input_lines = input_str.strip().split('\\n')\n\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n\n    removed_elements = {}\n    for i in range(n):\n        expected_value = i + 1\n        actual_value = a[i]\n\n        if actual_value != expected_value:\n            if actual_value not in removed_elements:\n                removed_elements[actual_value] = 1\n            else:\n                removed_elements[actual_value] += 1\n\n    unique_removed = len(removed_elements)\n\n    remaining_elements = n - unique_removed\n    return str(remaining_elements) +\"\\n\""}
{"task_id": 12, "completion": "from collections import deque\n\ndef get_sum(grid_str):\n  inf = int(1e9)\n  lines = grid_str.split(\"\\n\")\n  \n  n, m = map(int, lines[0].split())\n\n  grid = [list(map(int, line)) for line in lines[1:-1]]\n  distance = [[inf]*(m + 1) for _ in range(n + 1)]\n  q = deque([(i, j) for i in range(n + 1) for j in range(m + 1) if grid[i][j]==1])\n\n  for x, y in q:\n    distance[x][y] = 0\n\n  dx = [-1, 0, 1, 0]\n  dy = [0, 1, 0, -1]\n\n  while q:\n    x, y = q.popleft()\n    for i in range(4):\n      nx, ny = x + dx[i], y + dy[i]\n      if 0 <= nx <= n and 0 <= ny <= m and distance[nx][ny] == inf:\n        distance[nx][ny] = distance[x][y] + 1\n        q.append((nx, ny))\n\n  return str(sum(distance[i][j]**2 for i in range(n + 1) for j in range(m + 1)))\n"}
{"task_id": 13, "completion": "def can_fully_erase(input_str):\n    lines = input_str.strip().split('\\n')  # Split the input by new lines\n    t = int(lines[0])  # First line is the number of test cases\n    results = []\n\n    for i in range(1, t + 1):\n        s = lines[i]\n        a = s.count('A')\n        b = s.count('B')\n        c = s.count('C')\n\n        if b == a + c:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return '\\n'.join(results) + \"\\n\""}
{"task_id": 14, "completion": "def sort_array(input_str):\n    data = input_str.strip().split(\"\\n\")\n    t = int(data[0])\n    results = []\n\n    for ti in range(t):\n        n = int(data[2 * ti + 1])\n        vals = list(map(int, data[2 * ti + 2].split()))\n        sorted_vals = sorted(vals)\n        shifts = []\n\n        for i in range(n):\n            if vals[i] != sorted_vals[i]:\n                for j in range(i + 1, n):\n                    if vals[j] == sorted_vals[i]:\n                        d = j - i\n                        vals = vals[:i] + vals[i + d:j + 1] + vals[i:i + d] + vals[j + 1:]\n                        shifts.append((i + 1, j + 1, d))\n                        break\n\n        results.append(str(len(shifts)) + \"\\n\" + \"\\n\".join(\" \".join(map(str, shift)) for shift in shifts))\n\n    return \"\\n\".join(results) + \"\\n\""}
{"task_id": 15, "completion": "def sort_array(input_str):\n    # Split the input string into lines\n    lines = input_str.strip().split('\\n')\n\n    # Read the number of test cases\n    t = int(lines[0])\n\n    result = []\n    line_idx = 1  # Start reading after the number of test cases\n\n    for _ in range(t):\n        # Read the dimensions and minimum tick size\n        n, m, k = map(int, lines[line_idx].split())\n        line_idx += 1\n\n        # Read the grid\n        grid = [list(lines[line_idx + i].strip()) for i in range(n)]\n        line_idx += n\n\n        # Initialize a 2D array to keep track of valid tick centers\n        valid = [[False] * m for _ in range(n)]\n\n        # Iterate over each cell in the grid in reverse order\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                if grid[i][j] == '*':\n                    # Assume the current cell is the center of the largest possible tick\n                    tick_size = k\n                    while (i - tick_size >= 0 and j - tick_size >= 0 and\n                           j + tick_size < m and\n                           grid[i - tick_size][j - tick_size] == '*' and\n                           grid[i - tick_size][j + tick_size] == '*'):\n                        tick_size += 1\n                    tick_size -= 1  # Adjust tick_size to the largest valid tick\n\n                    # If the tick size is at least k, mark the cells as part of a valid tick\n                    if tick_size >= k:\n                        valid[i][j] = True\n                        for h in range(tick_size + 1):\n                            valid[i - h][j - h] = valid[i - h][j + h] = True\n\n        # Check if all black cells are part of a valid tick\n        is_valid = True\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '*' and not valid[i][j]:\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n\n        # Add the result for this test case\n        result.append(\"YES\" if is_valid else \"NO\")\n\n    # Return the results as a string, one result per line\n    return \"\\n\".join(result) "}
{"task_id": 16, "completion": "from heapq import heappop, heapify, heappush\n\ndef productive_meeting(ti):\n    t = list(map(int, ti.split())) # parse the input string into a list of integers\n    index = 1 # current index for the list of integers\n    result = \"\" # initialize the result as an empty string\n    for _ in range(t[0]): # loop over every test case\n        n = t[index] # number of people in the current test case\n        index += 1 # increase the index by 1\n        a = t[index:index+n] # sociability parameters of the people in the current test case\n        index += n # increase the index by n\n        heap = [(-a[i], i+1) for i in range(n) if a[i] > 0] # store the sociability in a heap as negatives (for max heap)\n        heapify(heap) # convert the heap into a valid heap\n        ans = [] # initialize the answer as an empty list\n        while len(heap) > 1: # while there are more than one people in the heap\n            fa, idxa = heappop(heap) # pop the most sociable person\n            fb, idxb = heappop(heap) # pop the second most sociable person\n            ans.append((idxa, idxb)) # make the two people talk\n            if fa+1 < 0: # if the most sociable person can still talk\n                heappush(heap, (fa+1, idxa)) # push the most sociable person back into the heap\n            if fb+1 < 0: # if the second most sociable person can still talk\n                heappush(heap, (fb+1, idxb)) # push the second most sociable person back into the heap\n        result += str(len(ans)) + \"\\n\" # append the number of talks to the result\n        for i, j in ans: # for each talk\n            result += str(i) + \" \" + str(j) + \"\\n\" # append the two people who talk to each other to the result\n    return result[:-1] # return the result as a string by removing the trailing newline character\n"}
{"task_id": 17, "completion": "from collections import deque\n\n\ndef min_inversions(input_str):\n    data = input_str.strip().splitlines()\n    t = int(data[0])\n    idx = 1\n    result = []\n\n    for _ in range(t):\n        n = int(data[idx])\n        a = list(map(int, data[idx + 1].split()))\n        d = deque()\n        inversions = 0\n\n        for num in a:\n            if not d:\n                d.append(num)\n            else:\n                left_inversions = sum(1 for elem in d if elem < num)\n                right_inversions = sum(1 for elem in d if elem > num)\n\n                if left_inversions <= right_inversions:\n                    inversions += left_inversions\n                    d.appendleft(num)\n                else:\n                    inversions += right_inversions\n                    d.append(num)\n\n        result.append(inversions)\n        idx += 2\n\n    return '\\n'.join(map(str, result))"}
{"task_id": 18, "completion": "def shift_to_zero(input_str):\n    def shift(arr, d):\n        return arr[-d:] + arr[:-d]\n\n    def process(s, d, arr):\n        previous_arr = arr.copy()\n        steps = 0\n        while True:\n            shifted_arr = shift(previous_arr, d)\n            new_arr = [ai & sai for ai, sai in zip(previous_arr, shifted_arr)]\n            if new_arr == previous_arr:\n                break\n            else:\n                previous_arr = new_arr\n                steps += 1\n        return steps if sum(previous_arr) == 0 else -1\n\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])\n    results = []\n    for i in range(t):\n        n, d = map(int, lines[i*2 + 1].split())\n        s = list(map(int, lines[i*2 + 2].split()))\n        results.append(process(s, d, s))\n    return '\\n'.join(map(str, results)) + '\\n'\n"}
{"task_id": 19, "completion": "def minimum_coverage(input_data):\n    rows = input_data.split('\\n')[:-1]\n    t = int(rows[0])\n    results = []\n\n    for i in range(t):\n        n = int(rows[i*2+1])\n        a = list(map(int, rows[i*2+2].split()))\n        a.append(0)\n        \n        res, incumb, _, total = [0]*4\n        right = a[0]\n\n        for j in range(1, n + 1):\n            left = max(0, min(right, a[j - 1] - incumb))\n            total += right - left\n            right = max(left, a[j])\n            res = max(res, total + right)\n            incumb = total + min(right, a[j - 1] - left)\n\n        results.append(str(res))\n\n    return '\\n'.join(results)\n"}
{"task_id": 20, "completion": "def min_operations(grid_data):\n    # Split the grid_data into its components\n    lines = grid_data.splitlines()\n    t = int(lines[0])  # Number of test cases\n    results = []\n\n    index = 1\n    for _ in range(t):\n        n, m = map(int, lines[index].split())\n        grid = [list(lines[index + i + 1]) for i in range(n)]\n        index += n + 1\n\n        min_operations = float('inf')\n        # Iterate over all possible sizes for the portal\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Iterate over all possible positions for the top-left corner of the portal\n                for i in range(n - a + 1):\n                    for j in range(m - b + 1):\n                        operations = 0\n                        # Count operations for top and bottom border\n                        for k in range(j + 1, j + b - 1):\n                            if grid[i][k] == '0':\n                                operations += 1\n                            if grid[i + a - 1][k] == '0':\n                                operations += 1\n                        # Count operations for left and right border\n                        for k in range(i + 1, i + a - 1):\n                            if grid[k][j] == '0':\n                                operations += 1\n                            if grid[k][j + b - 1] == '0':\n                                operations += 1\n                        # Count operations for inside\n                        for k in range(i + 1, i + a - 1):\n                            for l in range(j + 1, j + b - 1):\n                                if grid[k][l] == '1':\n                                    operations += 1\n                        # Update the minimum number of operations\n                        min_operations = min(min_operations, operations)\n\n        results.append(str(min_operations))\n\n    return \"\\n\".join(results)"}
{"task_id": 21, "completion": "def num_permutations(input_str):\n    n, m, k, p = map(int, input_str.split())\n    dp = [[[0]*(n+1) for _ in range(m+1)] for _ in range(n+1)]\n    dp[0][0][0] = 1\n    for i in range(n):\n        for j in range(m+1):\n            for t in range(n+1):\n                if t > j: continue\n                dp[i+1][j][t] += dp[i][j][t]*(j-t+1)*2\n                dp[i+1][j+1][t] += dp[i][j][t]*(i+1-j)*2\n                if t < n: \n                    dp[i+1][j][t+1] += dp[i][j][t]*(j-t+1)*(n-t)\n                    dp[i+1][j+1][t+1] += dp[i][j][t]*(i-j+1)*(n-t)\n                dp[i+1][j][t] %= p\n                dp[i+1][j+1][t] %= p\n                if t < n:\n                    dp[i+1][j][t+1] %= p\n                    dp[i+1][j+1][t+1] %= p\n    return str(sum(dp[n][k][k:m+1])%p)\n\nprint(num_permutations(\"4 3 2 10007\"))  # Expected: 4\nprint(num_permutations(\"6 4 1 769626776\"))  # Expected: 472\nprint(num_permutations(\"66 11 9 786747482\"))  # Expected: 206331312\nprint(num_permutations(\"99 30 18 650457567\"))  # Expected: 77365367\n"}
{"task_id": 22, "completion": "from collections import defaultdict\n\n\ndef train_maintenance(input_str: str):\n    data = input_str.splitlines()\n    n, m = map(int, data[0].split())\n\n    # Create a dictionary to store the work and maintenance cycles (x_i, y_i) for each train model\n    cycles = {}\n    for i in range(1, n + 1):\n        x_i, y_i = map(int, data[i].split())\n        cycles[i] = (x_i, y_i)\n\n    # Initialize a dictionary to keep track of the state of each train\n    # The key is the train model, and the value is a tuple (next_switch_day, in_maintenance)\n    trains = defaultdict(lambda: (0, False))\n\n    # Initialize a counter for the number of trains in maintenance\n    maintenance_count = 0\n    result = []\n\n    # Loop through the m operations\n    for idx in range(n + 1, n + m + 1):\n        op, k = map(int, data[idx].split())\n\n        if op == 1:  # Adding a train\n            # Calculate the next switch day for the train (current day + x_i)\n            next_switch_day = idx - (n + 1) + cycles[k][0]\n            # Add the train to the tracking data structure with its switch day and state as \"operation\"\n            trains[k] = (next_switch_day, False)\n        elif op == 2:  # Removing a train\n            # If the train was in maintenance, decrement the maintenance counter\n            if trains[k][1]:\n                maintenance_count -= 1\n            # Remove the train from the tracking data structure\n            del trains[k]\n\n        # Update the state of the trains based on their switch days\n        for train, (switch_day, in_maintenance) in list(trains.items()):\n            if idx - (n + 1) == switch_day:\n                # Toggle its state\n                if in_maintenance:\n                    # If the state changes to operation, decrement the maintenance counter\n                    maintenance_count -= 1\n                    next_switch_day = idx - (n + 1) + cycles[train][0]\n                else:\n                    # If the state changes to maintenance, increment the maintenance counter\n                    maintenance_count += 1\n                    next_switch_day = idx - (n + 1) + cycles[train][1]\n                trains[train] = (next_switch_day, not in_maintenance)\n\n        # Append the current number of trains in maintenance\n        result.append(str(maintenance_count))\n\n    # Return the result as a joined string\n    return \"\\n\".join(result)"}
{"task_id": 23, "completion": "from itertools import combinations\n\ndef max_subsequence_value(input_str):\n    n, m, *a = map(int, input_str.split())\n    a = a[:n]\n\n    max_value = 0\n    for subseq in combinations(range(n), m):\n        first_part = sum(m * a[b_i] for b_i in subseq)\n        second_part = sum(min(a[min(b_i, b_j):max(b_i, b_j)+1]) for b_i in subseq for b_j in subseq)\n        value = first_part - second_part\n        max_value = max(max_value, value)\n\n    return str(max_value)\n\n\n\nprint(max_subsequence_value(\"6 4\\n15 2 18 12 13 4\\n\"))  # should return 100\nprint(max_subsequence_value(\"11 5\\n9 3 7 1 8 12 10 20 15 18 5\\n\"))  # should return 176\nprint(max_subsequence_value(\"1 1\\n114514\\n\"))  # should return 0\nprint(max_subsequence_value(\"2 1\\n666 888\\n\"))  # should return 0\n"}
{"task_id": 24, "completion": "import heapq\n\ndef minimal_cost(input_string):\n\n    # Parse the input\n    inputs = input_string.strip().split('\\n')\n    n, m, q = map(int, inputs[0].split())\n    costs = list(map(int, inputs[1].split()))\n    connections = [list(map(int, x.split())) for x in inputs[2:m+2]]\n    incidents = [list(map(int, x.split())) for x in inputs[m+2:]]\n\n    # Initialize the distances with infinity\n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n\n    # Use a priority queue (heap) to store the nodes to be visited\n    heap = [(0, 1)]\n\n    # Build the graph\n    graph = [[] for _ in range(n+1)]\n    for u, v, l in connections:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    # Apply Dijkstra's algorithm\n    while heap:\n        du, u = heapq.heappop(heap)\n        if du != dist[u]: continue\n        for v, luv in graph[u]:\n            if dist[u] + luv < dist[v]:\n                dist[v] = dist[u] + luv\n                heapq.heappush(heap, (dist[v], v))\n\n    # Calculate the minimal initial cost\n    costs_with_dist = sorted([(2 * costs[i-1] + dist[i+1]) for i in range(n)])\n    minimum_costs = [str(costs_with_dist[0])]\n\n    # Handle the incidents\n    for ki, xi in incidents:\n        costs[ki-1] += xi\n        costs_with_dist.append(2 * costs[ki-1] + dist[ki])\n        costs_with_dist.sort()\n        minimum_costs.append(str(costs_with_dist[0]))\n\n    return '\\n'.join(minimum_costs)\n"}
{"task_id": 25, "completion": "def check(candidate):\n    inputs = ['5 9\\n', '3 2\\n', '21038 3942834\\n']\n    outputs = [['8105\\n'], ['4\\n'], ['338529212\\n']]\n    for i, test_input in enumerate(inputs):\n            expected_output = outputs[i]\n            found = False\n            for value in expected_output:\n              result = str(candidate(test_input))\n              if result == value:\n                found = True\n                break\n            assert found, f'Test case {i+1} failed.  Expected {value}, got {result}'\ncheck(NumDifferentPlans)\nfrom functools import lru_cache\nMOD = 998244353\ninv = [1, 1]\nc = [[1]]\nfor _ in range(2, 200005):\n    inv.append(MOD - MOD // _ * inv[MOD%_] % MOD)\nfor n in range(1, 200005):\n    temp = [1]\n    for m in range(1, n):\n        temp.append((temp[-1] * (n-m+1) % MOD) * inv[m] % MOD)\n    temp.append(1)\n    c.append(temp)\n\ndef solve(n, m):\n    dp = [[0]*m + [1] for _ in range(n+1)]\n    for i in range(m-1, 0, -1):\n        for j in range(n, 0, -1):\n            dp[j][i] = (dp[j][i+1] + dp[j-1][i] * 2 % MOD) % MOD\n        dp[0][i] = dp[0][i+1]\n    dp[0][0] = 1\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[j][i] = (dp[j][i] + dp[j-1][i-1] * 2 % MOD) % MOD\n    ans = dp[n][m]\n    for i in range(1, n+1):\n        ans = (ans - c[n][i]*dp[n-i][m-2] % MOD + MOD) % MOD\n    return ans\n\ndef prepare_problems(s):\n    n, m = map(int, s.strip().split())\n    return solve(n*2, m)"}
{"task_id": 26, "completion": "def count_permutations(input_cases):\n    mod = 10**9+7\n    n_value = 2*(10**5+1)\n    factorial = [0]*(n_value)\n    factorial[0] = 1\n    factorial[1] = 1\n    for i in range(2, n_value):\n        factorial[i] = (factorial[i-1]*i)%mod\n\n    dp = [0]*(n_value//2)\n    dp[1] = 1\n    for i in range(2,n_value//2):\n        dp[i] = (dp[i-1]*i + factorial[2*i-1]*dp[i-1])%mod\n        \n    cases = list(map(int,input_cases.strip().split('\\n')[1:]))\n\n    result = [str(dp[case]*factorial[2*case]%mod) for case in cases]\n\n    return '\\n'.join(result) + \"\\n\"\n\nprint(count_permutations('4\\n1\\n2\\n9\\n91234\\n')) \n\n1\n12\n830455698\n890287984\n"}
{"task_id": 27, "completion": "def check_possible(tncases):\n    t, n_cases = tncases[0], tncases[1:]\n    output = []\n    for i in range(t):\n        n, m, k = n_cases[i*3:i*3+3]\n        k = min(k, n)\n        if k*(k-1)//2 < m or m < n-1:\n            output.append(\"NO\")\n        else:\n            output.append(\"YES\")\n    return output"}
{"task_id": 28, "completion": "def min_diff(test_cases):\n    songs = test_cases.strip().split(\"\\n\")[1:]\n    results = []\n\n    for song in songs:\n        a, b, c = map(int, song.split())\n        total_duration = a + 2 * b + 3 * c\n\n        if total_duration % 2 == 1:\n            results.append(\"1\")\n        else:\n            if b % 2 == 0 or (a + c) > 0:\n                results.append(\"0\")\n            else:\n                results.append(\"1\")\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 29, "completion": "def nearly_full_subsequences(test_cases):\n    lines = test_cases.strip().split('\\n')\n    t = int(lines[0])\n    cases = lines[1:]\n    results = []\n\n    for i in range(t):\n        n = int(cases[i*2])\n        arr = list(map(int,cases[i*2+1].split()))\n        s = sum(arr)\n\n        dp = [0] * (s+1)\n        dp[0] = 1\n\n        for num in arr:\n            for j in range(s,num-1,-1):\n                dp[j] |= dp[j-num] << 1 \n\n        results.append(bin(dp[s-1]).count('1'))\n\n    return '\\n'.join(map(str, results))\n\nnearly_full_subsequences('5\\n5\\n1 2 3 4 5\\n2\\n1000 1000\\n2\\n1 0\\n5\\n3 0 2 1 1\\n5\\n2 1 0 3 0\\n')\n\n'1\\n0\\n2\\n4\\n4'\n"}
{"task_id": 30, "completion": "def min_erasures(input_str):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def min_removals_to_palindrome(s):\n        if is_palindrome(s):\n            return 0\n        unique_chars = set(s)\n        min_removals = len(s)\n        for c in unique_chars:\n            left, right = 0, len(s) - 1\n            removals = 0\n            while left < right:\n                if s[left] != s[right]:\n                    if s[left] == c:\n                        left += 1\n                        removals += 1\n                    elif s[right] == c:\n                        right -= 1\n                        removals += 1\n                    else:\n                        break\n                else:\n                    left += 1\n                    right -= 1\n            if left >= right and removals < min_removals:\n                min_removals = removals\n        return min_removals if min_removals != len(s) else -1\n\n    data = input_str.splitlines()\n    t = int(data[0])  # Number of test cases\n    result = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])  # Length of the string (not used in logic, just for input structure)\n        s = data[index + 1]  # The actual string\n        result.append(min_removals_to_palindrome(s))\n        index += 2  # Move to the next test case (length and string)\n\n    return result"}
{"task_id": 31, "completion": "def solve(input_string):\n    test_cases = input_string.strip().split('\\n')[1:]\n    out = []\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        a = list(map(int, test_cases[i+1].split()))\n        b = [0] * n\n        for j in range(0, n, 2):\n            b[j] = a[j+1]\n        for j in range(1, n, 2):\n            b[j] = -1 * a[j-1]\n        out.append(\" \".join(map(str, b)))\n    return '\\n'.join(out)\n\ninput_string = '3\\n2\\n5 5\\n5\\n5 -2 10 -9 4\\n7\\n1 2 3 4 5 6 7\\n'\nprint(solve(input_string))\n"}
{"task_id": 32, "completion": "def max_segments(input_str):\n    from collections import deque\n    inputs = input_str.strip().split('\\n')\n    t = int(inputs[0])\n    output = []\n    index = 1\n    for _ in range(t):\n        n = int(inputs[index])\n        index += 1\n        arr = list(map(int, inputs[index].split()))\n        index += 1\n        seg_sum = deque()\n        pos = n-1\n        current_sum = arr[pos]\n        while pos > 0:\n            pos -= 1\n            if current_sum >= arr[pos]:\n                seg_sum.appendleft(current_sum)\n                current_sum = arr[pos]\n            else:\n                current_sum += arr[pos]  \n                if len(seg_sum) > 0 and seg_sum[0] >= current_sum:\n                    current_sum = seg_sum.popleft()                        \n        seg_sum.appendleft(current_sum)\n        output.append(str(len(seg_sum)))\n    return '\\n'.join(output)\n"}
{"task_id": 33, "completion": "def solve(input_data):\n    data = [int(i) for i in input_data.split()]\n    n = data[0]\n    arr = data[1:]\n    \n    # count frequency\n    freq = [0] * 501\n    for num in arr:\n        freq[num] += 1\n        \n    # dp\n    dp = [0] * 300001\n    dp[0] = 1\n    \n    # iterate through distinct numbers\n    for num in range(500, -1, -1):\n        if freq[num] != 0:\n            for xor in range(300001):\n                if dp[xor]:\n                    dp[xor^num] = 1\n                    \n    # count and return results\n    res = [i for i in range(300001) if dp[i]]\n    return str(len(res)) + '\\n' + ' '.join(map(str, res)) + ' \\n'\n"}
{"task_id": 34, "completion": "def find_XOR_values(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    n = int(input_lines[0])\n    array = list(map(int, input_lines[1].split()))\n\n    max_val = max(array)\n    dp = [[0]*16384 for _ in range(max_val+1)]\n    dp[0][0] = 1\n    ans = [0]\n    \n    for num in array:\n        for i in range(num, -1, -1):\n            for bit in ans:\n                dp[i][bit^num] = 1\n                if dp[i][bit^num] and bit^num not in ans:\n                    ans.append(bit^num)\n    ans.sort()\n    cnt = len(ans)\n    \n    return \"{}\\n{}\".format(cnt, \" \".join(map(str,ans)))\n\n"}
{"task_id": 35, "completion": "def find_simple_segments(s):\n    parts = list(map(str, s.split('\\n')))\n    n = int(parts[0])\n    a = list(map(int, parts[1].split()))\n    b = list(parts[2])\n    \n    simpleSegments = 0\n    prefix = [0]*(n+2)\n    suffix = [0]*(n+2)\n    prefixOne = [0]*(n+2)\n    suffixOne = [0]*(n+2)\n    power = [0]*(n+1)\n    \n    for i in range(1,n+1):\n        prefixOne[i] = prefixOne[i-1]\n        if(a[i-1] == 1):\n            prefixOne[i] += 1\n        if(b[i-1]=='*'):\n            power[i] = power[i-1]+1\n            prefix[i] = prefix[i-1] + power[i] - prefixOne[i-1]\n        else:\n            power[i] = 0\n            prefix[i] = prefix[i-1]\n    \n    power = [0]*(n+1)\n    for i in range(n,0,-1):\n        suffixOne[i] = suffixOne[i+1]\n        if(a[i-1] == 1):\n            suffixOne[i] += 1\n        if(b[i-1]=='*'):\n            power[i] = power[i+1]+1\n            suffix[i] = suffix[i+1] + power[i] - suffixOne[i+1]\n        else:\n            power[i] = 0\n            suffix[i] = suffix[i+1]\n            \n    for i in range(1,n+1):\n        x = i - prefix[i] + 1\n        y = i + suffix[i+1] - 1\n        z = max(x,y)\n        if(z<=n and b[z-1]=='/'):\n            simpleSegments += min(i-x+1, y-i+1)\n        simpleSegments += prefix[i] + suffix[i+1]\n    \n    return str(simpleSegments) + '\\n'\n\ns = '7\\n6 4 10 1 2 15 1\\n*/*/*//\\n'\nfind_simple_segments(s)]\n"}
{"task_id": 36, "completion": "def largest_subset(s):\n    t, *lines = s.strip().split('\\n')\n    it = iter(lines)\n    output = []\n    \n    for _ in range(int(t)):\n        n = int(next(it))\n        a = list(map(int, next(it).split()))\n        primes = [x for x in range(2, 200) if all(x%i!=0 for i in range(2, int(x**0.5)+1))]\n        \n        subset = [] # start with an empty subset\n        \n        # Include 2 and 3 first if they exist in the array\n        for prime in [2, 3]:\n            if prime in a:\n                subset.append(a.index(prime) + 1)\n                a[a.index(prime)] = 0\n        \n        for x in sorted(a):\n            if x > 9 and len(subset) > 1: # exclude prime numbers >3 if the subset sum reaches a composite number without them\n                break\n            if x not in primes:    # include composite numbers 4, 6, 8, 9\n                subset.append(a.index(x) + 1)\n                a[a.index(x)] = 0\n\n        for prime in sorted(a):    # continue to include remaining prime numbers if needed\n            if prime > 1:\n                subset.append(a.index(prime) + 1)\n                a[a.index(prime)] = 0\n\n        # Prepare the output\n        output.append(str(len(subset)))\n        output.append(' '.join(map(str, subset)))\n\n    return '\\n'.join(output)\n\nprint(largest_subset('4\\n3\\n8 1 2\\n4\\n6 9 4 2\\n9\\n1 2 3 4 5 6 7 8 9\\n3\\n200 199 198\\n'))\n"}
{"task_id": 37, "completion": "from collections import defaultdict\n\n\ndef solve(input_str):\n    lines = input_str.strip().split('\\n')\n    idx = 0\n    results = []\n    t = int(lines[idx])\n    idx += 1\n\n    for _ in range(t):\n        n, m = map(int, lines[idx].split())\n        idx += 1\n        restr = []\n        vis = [False] * (n + 1)\n        adj = defaultdict(list)\n\n        for _ in range(m):\n            a, b, c = map(int, lines[idx].split())\n            idx += 1\n            restr.append((a, b, c))\n            adj[b].append(c)\n\n        restricted_nodes = set(b for a, b, c in restr)\n        root = next(i for i in range(1, n + 1) if i not in restricted_nodes)\n\n        res = []\n        for i in range(1, n + 1):\n            if i != root:\n                res.append([root, i])\n\n        res = '\\n'.join([' '.join(map(str, x)) for x in res])\n        results.append(res)\n\n    return '\\n'.join(results) +\"\\n\""}
{"task_id": 38, "completion": "def sub_grid_exitable(grid_input):\n    grid_data = grid_input.split('\\n')[:-1]\n    n, m = list(map(int, grid_data[0].split()))\n    grid_cells = [[\".\" if c == \".\" else \"X\" for c in row] for row in grid_data[1:n+1]]\n    filled_index = [m if \"X\" not in row else row.index(\"X\") for row in grid_cells]\n    queries = list(map(lambda x: list(map(int, x.split())), grid_data[n+2:]))\n    results = []\n    \n    for x1, x2 in queries:\n        sub_grid = [row[x1-1:x2] for row in grid_cells]\n        result = \"YES\"\n        for row in sub_grid:\n            if \"X\" in row and row.index(\"X\") != filled_index[sub_grid.index(row)]:\n                result = \"NO\"\n                break\n        results.append(result)\n        \n    return results\n\n\nprint(sub_grid_exitable('4 5\\n..XXX\\n...X.\\n...X.\\n...X.\\n5\\n1 3\\n3 3\\n4 5\\n5 5\\n1 5\\n'))\n"}
{"task_id": 39, "completion": "def solve(n):\n    pair = [0]*(n+1)\n    a = [0]*(n+1)\n    for i in range(20,-1,-1):\n        arr = ['?']\n        for j in range(1,n+1):\n            arr.append(str((j>>i)&1))\n        print(' '.join(arr),flush=True)\n        ans = int(input())\n        if ans==-1:\n            exit()\n        for j in range(ans+1,n+1):\n            a[j] = a[j-1]^1\n            pair[(j>>i)&1^a[j]] ^= j\n    for i in range(20,-1,-1):\n        arr = ['?']\n        for j in range(1,n+1):\n            arr.append(str((pair[(j>>i)&1]>>i)&1))\n        print(' '.join(arr), flush=True)\n        ans = int(input())\n        if ans==-1:\n            exit()\n        if ((pair[0]>>i)&1) != ((ans>>i)&1):\n            pair[0], pair[1] = pair[1], pair[0]\n    print('! '+str(pair[0]), flush=True)\n    \nt = int(input())\nfor _ in range(t):\n"}
{"task_id": 40, "completion": "import sys\nfrom collections import defaultdict\n\ndef solve_problem(input_string):\n    lines = input_string.strip().split(\"\\n\")\n    n,m = map(int,lines[0].split())\n    g = defaultdict(list)\n    edges = []\n    res = defaultdict(lambda:defaultdict(int))\n    d = [0]*(n+1)\n    u = [0]*(n+1)\n    ans = []\n    q = []\n    out = []\n    for i in range(1,m+1):\n        a,b = map(int,lines[i].split())\n        edges.append((a,b))\n        g[a].append((b,i))\n        g[b].append((a,i))\n    def dfs(v,p):\n        u[v] = 1\n        d[v] = d[p] + 1\n        for to,i in g[v]:\n            if to == p:\n                continue\n            if u[to]:\n                if d[to] < d[v]:\n                    res[v][to] += 1\n                    res[to][v] -= 1\n            else:\n                dfs(to,v)\n                res[v][to] += 1\n                res[to][v] -= 1\n\n    dfs(1,0)\n\n    for i in range(m+1):\n        if (res[edges[i-1][0]][edges[i-1][1]]+res[edges[i-1][1]][edges[i-1][0]]) % 2 != 0:\n            sys.stdout.write('NO\\n')\n            return\n\n    p = [0]*(n+1)\n\n    for _ in range(int(lines[m+1])):\n        qq = list(map(int,lines[m+2+_].split()))\n        q.append(qq)\n        \n    def get(v):\n        if v == p[v]:\n            return v\n        else:\n            p[v] = get(p[v])\n            return p[v]\n\n    def union(a,b):\n        a,b = get(a),get(b)\n        if a != b:\n            if d[a] < d[b]:\n                p[b] = a\n            else:\n                p[a] = b\n                if d[a] == d[b]:\n                    d[a] += 1\n\n    for _ in range(n):\n        p[_+1] = _+1\n\n    e = [0]*(n+1)\n    used = [0]*(n+1)\n    order = []\n    was = [0]*(n+1)\n\n    def dfs1(v):\n        used[v] = 1\n        for to,_ in g[v]:\n            if not used[to]:\n                dfs1(to)\n        order.append(v)\n\n    dfs1(1)\n\n    order.reverse()\n\n    for u in order:\n        for v,i in g[u]:\n            if v != p[u] and p[v] == v:\n                p[v] = u\n                e[v] = i\n\n    for x,y in q:\n        o1,o2 = [],[]\n        v = y\n        while v != x:\n            o1.append(v)\n            v = p[v]\n        o1.append(x)\n        v = x\n        while v != y:\n            o2.append(v)\n            v = p[v]\n        o2.append(y)\n        if len(o1) < len(o2):\n            o1.reverse()\n            out.append(o1)\n        else:\n            out.append(o2)\n\n    out = [\"YES\"] + [str(len(o))+\"\\n\"+\" \".join(map(str,o)) for o in out]\n\n    return \"\\n\".join(out)"}
{"task_id": 41, "completion": "def minimum_colors(input_string):\n    n, k = map(int, input_string.split(\"\\n\")[0].split(\" \"))\n    res = [0]*((n*(n-1))//2)\n    col = k if n%2 == 0 else k-1\n    c, cur = [1]*n, 0\n    for i in range(2, n+1):\n        for j in range(i-1, 0, -1):\n            res[cur] = c[j]\n            c[j] = c[j]%col+1\n            cur += 1\n        res[cur] = c[i] = c[i-1]\n        cur += 1\n    return str(col) + \"\\n\" + \" \".join(map(str, res)) + \" \"\n"}
{"task_id": 42, "completion": "def time_travels(input):\n    mod = 10**9 + 7\n    data = input.split('\\n')\n    n = int(data[0])\n    tasks = [list(map(int, line.split())) for line in data[1:n+1]]\n    s = [0] * (n + 1)\n    t = list(map(int, data[-1].split()))\n    for q in t: s[q] = 1\n    qr = sorted([(b, -a, i in s) for i, (a, b) in enumerate(tasks, 1)] + [(b, b, i in s) for i, (a, b) in enumerate(tasks, 1)], reverse=True)\n    res = now = su = completeS = 0\n    for time, _, is_funny in qr:\n        if is_funny:\n            res = (res + now - 2 * (su - completeS)) % mod\n            completeS += max(0, time)\n        now += max(0, time)\n        su += abs(time)\n    res = (res + completeS) % mod\n    return res\n"}
{"task_id": 43, "completion": "from collections import defaultdict\n\ndef solve(input_str):\n    input_lines = input_str.splitlines()\n\n    n, q = map(int, input_lines[0].split())\n\n    enjoyment = [0] + list(map(int, input_lines[1].split()))\n\n    graph = defaultdict(list)\n    for i in range(2, n + 1):\n        a, b, c, t = map(int, input_lines[i].split())\n        graph[a].append((b, c, t))\n        graph[b].append((a, c, t))\n\n    def dfs(graph, enjoyment, start, v):\n        visited = set()\n        stack = [(start, 0)]\n        max_enjoyment = enjoyment[start]\n        max_toll = 0\n\n        while stack:\n            current_city, current_toll = stack.pop()\n            current_enjoyment = enjoyment[current_city]\n\n            if current_city in visited:\n                continue\n            visited.add(current_city)\n\n            if current_enjoyment > max_enjoyment:\n                max_enjoyment = current_enjoyment\n                max_toll = current_toll\n            elif current_enjoyment == max_enjoyment:\n                max_toll = max(max_toll, current_toll)\n\n            for next_city, capacity, toll in graph[current_city]:\n                if capacity >= v and next_city not in visited:\n                    stack.append((next_city, max(current_toll, toll)))\n\n        return max_enjoyment, max_toll\n\n    results = []\n    for i in range(n + 1, n + 1 + q):\n        v, x = map(int, input_lines[i].split())\n        max_enjoyment, max_toll = dfs(graph, enjoyment, x, v)\n        results.append(f\"{max_enjoyment} {max_toll}\")\n\n    return \"\\n\".join(results) + \"\\n\"\n"}
{"task_id": 44, "completion": "def solve(s):\n    def color(i, j, c):\n        nonlocal possible\n        if board[i][j] != \".\" and board[i][j] != \"GS\"[c]:\n            possible = 0\n            return False\n        if board[i][j] == \".\":\n            board[i][j] = \"GS\"[c]\n            for u, v in sames[i][j]:\n                if board[u][v] != \".\" and board[u][v] != \"GS\"[c]:\n                    possible = 0\n                    return False\n            for u, v in diffs[i][j]:\n                if board[u][v] != \".\" and board[u][v] == \"GS\"[c]:\n                    possible = 0\n                    return False\n            possible &= len(sames[i][j]) == 2 or (len(sames[i][j]) == 1 and len(diffs[i][j]) == 1)\n        return True\n\n    def solve_Grid(i, j, c):\n        if not color(i, j, c): return False\n        if i == j == n - 1:\n            last = [color(u, v, c) for u, v in ambigu]\n            return all(last) and not any(last)\n\n        if (i == j or j == n - 1 - i) and (i < j):\n            return solve_Grid(i, j + 1, c ^ (j < n // 2)) and solve_Grid(i + 1, j, c ^ (i + 1 < n // 2))\n        if j > i: return solve_Grid(i, j - 1, c)\n        return solve_Grid(i - 1, j, c)\n\n    def decolor(i, j, c):\n        if board[i][j] == \".\" or board[i][j] == \"GS\"[c ^ 1]: return\n        board[i][j] = \".\"\n        if sames[i][j] or diffs[i][j]: ambigu.append((i, j))\n\n        if i == j == n - 1: return\n\n        if (i == j or j == n - 1 - i) and (i < j):\n            decolor(i, j + 1, c ^ (j < n // 2))\n            decolor(i + 1, j, c ^ (i + 1 < n // 2))\n            return\n\n        if j > i: decolor(i, j - 1, c)\n        else: decolor(i - 1, j, c)\n\n    def solve(i, j, c):\n        nonlocal count, possible, ambigu\n        if solve_Grid(i, j, c):\n            ambigu, tmp = [], ambigu\n            possible = 1\n            if not solve_Grid(i, j, c): count += 1\n            for u, v in tmp: decolor(u, v, c)\n\n    f = s.strip().split()\n    n = int(f[0])\n    board = [list(x) for x in f[1:]]\n    sames = [[[] for _ in range(n)] for _ in range(n)]\n    diffs = [[[] for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j != n - 1 - i:\n                sames[i][j] = [(i - 1, j), (i + 1, j)]\n                diffs[i][j] = [(i, j - 1), (i, j + 1)]\n            if i != n - 1 - j:\n                sames[j][i] = [(j - 1, i), (j + 1, i)]\n                diffs[j][i] = [(j, i - 1), (j, i + 1)]\n\n    for i in range(n//2):\n        for j in range(i + 1, n - i):\n            sames[i][j].append((i, j - 1))\n            sames[i][j - 1].append((i, j))\n            diffs[i][j].append((i + 1, j))\n            diffs[i + 1][j].append((i, j))\n            if j != n - i - 1:\n                sames[n - 1 - i][j].append((n - 1 - i, j + 1))\n                sames[n - 1 - i][j + 1].append((n - 1 - i, j))\n                diffs[n - 1 - i][j].append((n - 2 - i, j))\n                diffs[n - 2 - i][j].append((n - 1 - i, j))\n        sames[j][n - 1 - i], sames[n - 1 - i][n - 1 - j] = sames[n - 1 - i][n - 1 - j], sames[j][n - 1 - i]\n        diffs[j][n - 1 - i], diffs[n - 1 - i][n - 1 - j] = diffs[n - 1 - i][n - 1 - j], diffs[j][n - 1 - i]\n\n    count = 0\n    ambigu = list(filter(lambda x: not sames[x[0]][x[1]] and not diffs[x[0]][x[1]], [(i, j) for i in range(n) for j in range(n)]))\n    over = [(i, j) for i in range(n) for j in range(i + 1, n) if not ambigu or (i <= ambigu[0][0] and j <= ambigu[0][1])]\n    if over: solve(*over[0], 0); solve(*over[0], 1)\n\n    for i in range(n):\n        if '.' in board[i]: count = 2\n    return ['NONE\\n', 'UNIQUE\\n', 'MULTIPLE\\n'][count] + '\\n'.join(map(''.join, board)) if count != 1 else 'UNIQUE\\n' + '\\n'.join(map(''.join, board)) + '\\n'\n"}
{"task_id": 45, "completion": "def flower_height(test_cases):\n    test_cases = test_cases.strip().split(\"\\n\")\n    t = int(test_cases[0])\n    testcase_index = 1\n    results = []\n    for _ in range(t):\n        n = int(test_cases[testcase_index])\n        watering_actions = list(map(int, test_cases[testcase_index + 1].split()))\n        height = 1\n        no_water_days = 0\n        watered_previous_day = False  # Track if the flower was watered the previous day\n\n        for action in watering_actions:\n            if action == 1:\n                if watered_previous_day:\n                    height += 5\n                else:\n                    height += 1\n                watered_previous_day = True\n                no_water_days = 0\n            else:\n                if watered_previous_day:\n                    watered_previous_day = False\n                no_water_days += 1\n                if no_water_days == 2:\n                    height = -1\n                    break\n\n        testcase_index += 2\n        results.append(str(height))\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 46, "completion": "def minEversions(s):\n    lines = s.strip().split(\"\\n\")\n    t = int(lines[0])\n    tests = []\n    for i in range(1, len(lines), 2):\n        n = int(lines[i])\n        arr = list(map(int, lines[i + 1].split()))\n        tests.append((n, arr))\n\n    results = []\n    for n, arr in tests:\n        counter = 0\n        while True:\n            x = arr[-1]\n            left = [j for j in arr if j <= x]\n            right = [j for j in arr if j > x]\n            new_arr = left + right\n            if new_arr == arr:\n                break\n            arr = new_arr\n            counter += 1\n        results.append(counter)\n\n    return \"\\n\".join(map(str, results)) + \"\\n\""}
{"task_id": 47, "completion": " def minimum_distance(s):\n    tests = s.strip().split('\\n')\n    t = int(tests[0])\n    outputs = []\n\n    for i in range(t):\n        n, k = map(int, tests[i * 2 + 1].split())\n        depots = list(map(int, tests[i * 2 + 2].split()))\n\n        # Separate positive and negative depots\n        positive_depots = sorted([xi for xi in depots if xi > 0], reverse=True)\n        negative_depots = sorted([-xi for xi in depots if xi < 0], reverse=True)\n\n        distance = 0\n\n        # Calculate distance for positive depots\n        for i in range(0, len(positive_depots), k):\n            distance += 2 * positive_depots[i]\n\n        # Calculate distance for negative depots\n        for i in range(0, len(negative_depots), k):\n            distance += 2 * negative_depots[i]\n\n        # Subtract the distance to the farthest depot if there are no more depots to deliver\n        if positive_depots and negative_depots:\n            distance -= max(positive_depots[0], negative_depots[0])\n        elif positive_depots:\n            distance -= positive_depots[0]\n        elif negative_depots:\n            distance -= negative_depots[0]\n\n        outputs.append(str(distance))\n\n    return '\\n'.join(outputs) +\"\\n\""}
{"task_id": 48, "completion": "def can_sort_with_three_cycles(input_string):\n    data = list(map(int, input_string.split()))\n    t = data[0]\n    data_index = 1\n    results = []\n    for _ in range(t):\n        n = data[data_index]\n        a = [0] + data[data_index+1:data_index+n+1]\n        p = [0 for _ in range(n+1)]\n        for i in range(1, n+1):\n            p[a[i]] = i\n        for i in range(1, n+1):\n            if p[i]!=i:\n                results.append('NO')\n                break\n        else:\n            results.append('YES')\n        data_index += n+1\n    return \"\\n\".join(results)"}
{"task_id": 49, "completion": "from collections import defaultdict, Counter\n\ndef solve(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    test_cases = int(input_lines.pop(0))\n    output = []\n\n    for _ in range(test_cases):\n        n, q = map(int,input_lines.pop(0).split())\n        values = list(map(int,input_lines.pop(0).split()))\n        parents = list(map(int,input_lines.pop(0).split()))\n        values.insert(0, 0)\n        children = defaultdict(list)\n        children[0] = [1]\n\n        for i in range(2, n+1):\n            children[parents[i-2]].append(i)\n\n        path = [None for _ in range(n+1)]\n        path[1] = [values[1]]\n\n        stack = [(1, [values[1]])]\n\n        while stack:\n            v, sequence = stack.pop()\n            path[v] = sequence\n            for child in children[v]:\n                stack.append((child, sequence + [values[child]]))\n\n        for _ in range(q):\n            v, l, k = map(int, input_lines.pop(0).split())\n            c = Counter(path[v])\n            filtered_values = sorted([x for x in c.keys() if c[x] >= l])\n\n            if len(filtered_values) < k:\n                output.append(\"-1\")\n            else:\n                output.append(str(filtered_values[k-1]))\n    return \"\\n\".join(output)\n"}
{"task_id": 50, "completion":  "def calculate_arrays(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n\n    fact = [1]\n    prod = 1\n    mod = 998244353\n\n    for i in range(1, 200005):\n        prod = (prod * i) % mod\n        fact.append(prod)\n\n    result = fact[a[0]]\n    prod = fact[a[0]]\n    inv_prod = pow(prod, mod - 2, mod)\n\n    for i in range(1, n):\n        z = a[i] - a[i - 1]\n        result = (result * (fact[a[i]] * pow(fact[z], mod - 2, mod) * pow(inv_prod, z, mod))) % mod\n        prod = (prod * pow(fact[a[i]], z, mod) * pow(fact[z], mod - 2, mod)) % mod\n        inv_prod = pow(prod, mod - 2, mod)\n\n    return str(result)\n\n"}
{"task_id": 51, "completion": "import math\n\ndef find_l_r(t, test_cases):\n    \n    results = []\n\n    for n in test_cases:\n        r = int(math.isqrt(2*n))\n        while r*(r+1) > 2*n:\n            r -= 1\n        while r*(r+1) < 2*n:\n            r += 1\n        l = r*(r+1)//2 - n\n        results.append((l, r))\n    \n    return results\n"}
{"task_id": 52, "completion": "def find_special_numbers(input_str):\n    data = input_str.splitlines()\n    t = int(data[0])\n    test_cases = [tuple(map(int, line.split())) for line in data[1:t + 1]]\n\n    special_numbers = []\n    mod = 10 ** 9 + 7\n\n    def pow_with_mod(base, exp, mod):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp = exp // 2\n        return result\n\n    for test_case in test_cases:\n        n, k = test_case\n        special = 0\n        p = 0\n        while k > 0:\n            if k % 2 == 1:\n                special = (special + pow_with_mod(n, p, mod)) % mod\n            k = k // 2\n            p += 1\n        special_numbers.append(special)\n\n    return '\\n'.join(map(str, special_numbers)) + '\\n'"}
{"task_id": 53, "completion": "def min_operations_to_produce_string(test_cases):\n    # Convert the input into a suitable format\n    t, *test_cases = test_cases.split('\\n')\n    # Initialize result list\n    output = []\n    # Iterate over each test case\n    for i in range(0, len(test_cases) - 1, 2):\n        n, c = test_cases[i].split()\n        s = test_cases[i + 1]\n        # No operations are need if all characters are already c\n        if s.count(c) == len(s):\n            output.extend(['0'])\n        else:\n            if s[-1] == c:\n                output.extend(['1\\n'+str(len(s))])\n            else:\n                output.extend(['2\\n1\\n'+str(len(s))])\n    return \"\\n\".join(output)\n\nprint(min_operations_to_produce_string('3\\n4 a\\naaaa\\n4 a\\nbaaa\\n4 b\\nbzyx\\n'))\n"}
{"task_id": 54, "completion": "def maxImposters(testCases):\n    res = []\n    for _ in range(int(testCases[0])): res.append(str(solve()))\n    return '\\n'.join(res)"}
{"task_id": 55, "completion": "MOD = 10**9 + 7\n\ndef good_colorings(k):\n    total_colorings = 6  # Root node can be colored in 6 ways\n    k = int(k)\n\n    # For each level from the second to the k-th, each node can be colored in 4 ways\n    for i in range(1, k):\n        total_colorings *= pow(4, 2**i, MOD)\n        total_colorings %= MOD\n\n    return str(total_colorings) + \"\\n\"\n"}
{"task_id": 56, "completion": "import sys\ninput = sys.stdin.readline\n\nmod = 10**9+7\nfact = [1]\ninv = [1]\nfor i in range(1, 61):\n    fact.append(fact[-1] * i % mod)\n    inv.append(pow(fact[-1], mod-2, mod))\n\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * inv[k] % mod * inv[n-k] % mod\n\ndef solve(e, color, is_fixed, l, r):\n    if (e, color, is_fixed) in dp:\n        return dp[(e, color, is_fixed)]\n\n    if e in fixed_color:\n        if color != fixed_color[e]:\n            return 0\n        else:\n            return solve(e-1, color, True, l, r)\n\n    if e < l:\n        return color != is_fixed\n    elif e <= r:\n        return sum((solve(e-1, i, color==i, l, r) for i in range(6))) % mod\n    else:\n        res = 0\n        c = [0]*6\n        c[color] = 1\n        for i in range(6):\n            for j in range(i+1):\n                nex = [0]*6\n                for x in range(6):\n                    for y in range(j+1 if x == i else j+2):\n                        nex[max(x, y)] += c[x] * nCk(e-l, j) % mod * nCk(r-l, e-l-j) % mod\n                        nex[max(x, y)] %= mod\n                c = nex\n        for i in range(6):\n            if is_fixed <= i:\n                res += solve(e-1, i, is_fixed == i, l, r)\n                res %= mod\n        return res\n        \ndp = {}\nk, n = map(int, input().split())\nleft = [k]*6\nright = [0]*6\nL = [0]*6\nfixed_color = {}\ncolors = ['white', 'blue', 'red', 'orange', 'green', 'yellow']\n\nfor _ in range(n):\n    v, cc = input().strip().split()\n    v = int(v)\n    cc = colors.index(cc)\n    fixed_color[v] = cc\n    vv = v\n    c = cc\n    while v > 0:\n        left[c] = min(left[c], v)\n        right[c] = max(right[c], v)\n        v //= 2\n        if v in fixed_color and fixed_color[v] != c:\n            print(0)\n            exit()\n        c = fixed_color[v] if v in fixed_color else c"}
{"task_id": 57, "completion": "def isIdealFarm(t, arr):\n    ans = []\n    for i in range(t):\n        s, n, k = arr[i]\n        m = min(k, n, s)\n        res = s - m\n        if (res >= (n - 1) and res <= (n-1) * m):\n            ans.append('YES')\n        else:\n            ans.append('NO')\n    return ans\n\nt = 4\narr = [(1, 1, 1), (1, 1, 2), (100, 50, 200), (56220, 47258, 14497)]\nprint(isIdealFarm(t, arr))\n"}
{"task_id": 58, "completion": "def complete_level(test_cases_str):\n    test_cases = test_cases_str.strip().split('\\n')\n    t = int(test_cases[0])\n    ptr = 1\n    results = []\n    for _ in range(t):\n        n = int(test_cases[ptr])\n        first_row = test_cases[ptr + 1]\n        second_row = test_cases[ptr + 2]\n        ptr += 3\n\n        canComplete = True\n        for i in range(1, n):\n            if first_row[i] == '1' and second_row[i] == '1':\n                canComplete = False\n                break\n\n        results.append(\"YES\" if canComplete else \"NO\")\n\n    return '\\n'.join(results) + \"\\n\"\n\n"}
{"task_id": 59, "completion": "def dfs(input_str):\n    data = input_str.splitlines()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        availability = [list(map(int, data[index + i + 1].split())) for i in range(n)]\n        index += n + 1\n\n        for day1 in range(5):\n            for day2 in range(day1 + 1, 5):\n                only_day1 = only_day2 = both_days = 0\n                for student in availability:\n                    can_attend_day1 = student[day1] == 1\n                    can_attend_day2 = student[day2] == 1\n                    if can_attend_day1 and not can_attend_day2:\n                        only_day1 += 1\n                    elif can_attend_day2 and not can_attend_day1:\n                        only_day2 += 1\n                    elif can_attend_day1 and can_attend_day2:\n                        both_days += 1\n                if abs(only_day1 - only_day2) <= both_days and (only_day1 + only_day2 + both_days) == n:\n                    results.append(\"YES\")\n                    break\n            else:\n                continue\n            break\n        else:\n            results.append(\"NO\")\n\n    return \"\\n\".join(results) +\"\\n\"\n"}
{"task_id": 60, "completion": "from collections import Counter\n\n\ndef count_pairs(input_string):\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    idx = 1\n    results = []\n\n    for _ in range(t):\n        n = int(lines[idx].strip())\n        a = list(map(int, lines[idx + 1].strip().split()))\n        idx += 2\n\n        count_a = Counter(a)\n\n        mean = sum([i * count_a[i] for i in count_a]) * 2\n        pairs = 0\n\n        for key, value in count_a.items():\n            pairs += count_a.get(mean / n - key, 0) * value\n            if mean / n - key == key:\n                pairs -= value\n\n        results.append(str(pairs // 2))\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 61, "completion": "from collections import Counter\nfrom itertools import accumulate\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        problems = sorted([list(map(int, input().split())) for _ in range(n)])\n        \n        cumulative_count = [0] * (n+1)\n        topic_counter = Counter()\n        difficulty_counter = Counter()\n        res = [0] * n\n\n        for i in range(n):\n            topic, difficulty = problems[i]\n            topic_counter[topic] += 1\n            difficulty_counter[difficulty] += 1\n            res[i] = min(topic_counter[topic], difficulty_counter[difficulty])\n        \n        cumulative_count = list(accumulate(res))\n        counter_values = list(Counter(res).values())\n        \n        total = sum(cumulative_count[j-1] if j >= 1 else 0 for j in counter_values)\n        total += sum(cumulative_count[j-2] if j >= 2 else 0 for j in counter_values)\n        \n        print(total - n)\n\n"}
{"task_id": 62, "completion": "def count_paths(input_str):\n    from sys import stdin, stdout\n    MOD = 10**9 + 7\n    dx = [-1, 0]\n    dy = [0, -1]\n    input_lines = input_str.strip().split(\"\\n\")\n    n, m, q = map(int, input_lines[0].split())\n    Q = [(int(x.split()[0])-1, int(x.split()[1])-1) for x in input_lines[1:]]\n\n    blocked = [[False]*m for _ in range(n)]\n    dp = [[[0]*m for _ in range(n)] for __ in range(2)]\n    sd = [[[0]*m for _ in range(n)] for __ in range(2)]\n    ans = [0]*q\n    globalAns = 0\n\n    for i in range(n):\n        for j in range(m):\n            for z in range(2):\n                if i+dx[z]>=0 and j+dy[z]>=0:\n                    dp[z][i][j] = (sd[z^1][i+dx[z]][j+dy[z]] + 1) % MOD\n                    globalAns = (globalAns + dp[z][i][j]) % MOD\n\n                if j > 0:\n                    sd[z][i][j] = (dp[z][i][j] + sd[z][i][j-1]) % MOD\n                else:\n                    sd[z][i][j] = dp[z][i][j]\n\n    for k, Q in enumerate(Q):\n        globalAns = (globalAns - pow(blocked[Q[0]][Q[1]], 2, MOD)) % MOD\n\n        for z in range(2):\n            old = dp[z][Q[0]][Q[1]]\n\n            if Q[0]+dx[z]>=0 and Q[1]+dy[z]>=0 and not blocked[Q[0]+dx[z]][Q[1]+dy[z]]:\n                dp[z][Q[0]][Q[1]] = (sd[z^1][Q[0]+dx[z]][Q[1]+dy[z]] + 1) % MOD\n            else:\n                dp[z][Q[0]][Q[1]] = 0\n\n            change = (dp[z][Q[0]][Q[1]] - old) % MOD\n            globalAns = (globalAns + change) % MOD\n\n            for j in range(Q[1], m):\n                sd[z][Q[0]][j] = (sd[z][Q[0]][j] + change) % MOD\n\n        blocked[Q[0]][Q[1]] ^= True\n        ans[k] = globalAns\n\n    return '\\n'.join(map(str, ans)) + '\\n'\n"}
{"task_id": 63, "completion": "def max_rbs(input_string):\n    lines = input_string.strip().split('\\n')\n    n = int(lines[0])\n    s = [line for line in lines[1:]]\n\n    l = []  # list for sequences with extra opening brackets\n    r = []  # list for sequences with extra closing brackets\n\n    for seq in s:\n        open_count = 0\n        close_count = 0\n        for char in seq:\n            if char == \"(\":\n                open_count += 1\n            else:\n                if open_count > 0:\n                    open_count -= 1\n                else:\n                    close_count += 1\n        if close_count > 0:\n            r.append((close_count, open_count))\n        else:\n            l.append((open_count, close_count))\n\n    l.sort(reverse=True)\n    r.sort()\n\n    d = l + r  # merging both lists\n\n    cnt = 0  # total count of brackets\n    ans = 0  # result variable\n    for i in range(len(d)):\n        if cnt >= d[i][1]:\n            cnt += d[i][0]\n            ans += 1\n        else:\n            cnt = 0\n\n    if cnt > 0:  # reducing the count of unpaired opening brackets\n        ans -= 1\n\n    return str(ans) + \"\\n\"\n"}
{"task_id": 64, "completion": "def good_sum(s, x):\n    n = len(s)\n    l = [0]\n    r = [1]\n    a = []\n    b = []\n    for i in range(2, n + 1):\n        while len(a) and a[-1] < s[l[-1] - 1:r[-1]]:\n            l.append(l[-1])\n            r.append(i)\n            a.append(a[-1])\n            b.append(b[-1])\n            if len(a) > 1 and a[-2] == a[-1]:\n                a.pop()\n                b.pop()\n                l.pop()\n                r.pop()\n        while len(a) and a[-1] < s[l[-1] - 1:i]:\n            a[-1] = s[l[-1] - 1:i]\n            r[-1] = i\n        a.append(s[l[-1] - 1:i])\n        b.append(int(a[-1]))\n        l.append(i)\n        r.append(i + 1)\n    a.append('')\n    b.append(int(1e18))\n    l.append(n + 1)\n    r.append(n + 1)\n    x = str(x)\n    m = len(a)\n    j = 1\n    for i in range(1, m):\n        while j < m and b[j] < b[i - 1] + int(x):\n            j += 1\n        if j < m and a[i - 1] + x == a[j]:\n            return [l[i - 1], r[i - 1] - 1, l[j] - 1, r[j] - 1]\n    return []\n"}
{"task_id": 65, "completion": "def balance_weights(input_string):\n    # Splitting the input_string on the basis of \\n\n    input_lines = input_string.strip().split('\\n')\n    \n    # Number of Weights\n    N = int(input_lines[0])\n    \n    # Weights\n    weights = list(map(int, input_lines[1].split()))\n    \n    # String S\n    S = input_lines[2]\n\n    # Combine Weights and their indices, and sort them in descending order\n    pairs = sorted([(w, i) for i, w in enumerate(weights)], reverse=True)\n\n    # Weights and indices being placed on the left or right\n    weight_left = []\n    index_left = []\n    weight_right = []\n    index_right = []\n\n    # Result list\n    result = []\n\n    # Iterate over each weight and its index in the pairs list\n    for w, i in pairs:\n        # If the i-th character in S is 'L'\n        if S[i] == 'L':\n            # Append the weight to the left\n            weight_left.append(w)\n            while index_right and index_right[-1] < i:\n                # Move weights from the right to the left as long as the last placed weight on the right\n                # is originating from an earlier position in the original sequence\n                weight_left.append(weight_right.pop())\n                index_right.pop()\n            # Append the index to the left\n            index_left.append(i)\n        else:\n            # If the i-th character in S is not 'L' (so it's 'R'), append the weight and index to the right\n            weight_right.append(w)\n            index_right.append(i)\n\n    # Placing of weights is done from largest to smallest, so reverse both lists to output them in the\n    # order of placement\n    weight_left = list(reversed(weight_left))\n    index_left = list(reversed(index_left))\n\n    # Iterate over each weight and its index in the left lists\n    for w, i in zip(weight_left, index_left):\n        # Append the placed weight and its side to the result list\n        result.append(f\"{w} L\")\n\n    # Iterate over each weight and its index in the right lists\n    for w, i in reversed(list(zip(weight_right, index_right))):\n        # Append the placed weight and its side to the result list\n        result.append(f\"{w} R\")\n\n    # Return the result\n    return result\n\nbalance_weights(\"5\\n3 8 2 13 7\\nLLRLL\")\n\n['13 L', '8 R', '2 R', '7 L', '3 L']\n"}
{"task_id": 66, "completion": "def last_card(tests):\n    tests = tests.strip().split('\\n')\n    T = int(tests[0])\n    pos = 1\n    res = []\n    \n    for _ in range(T):\n        N = int(tests[pos])\n        A, B = map(int, tests[pos+1].split())\n        DA, DB = tests[pos+2].split()\n        if DA == \"left\":\n            DA = -1\n        else:\n            DA = 1\n        if DB == \"left\":\n            DB = -1\n        else:\n            DB = 1\n            \n        while N > 1:\n            if A == B:\n                N = N - 1\n                if A > 0 and A < N:\n                    A = A - 1\n            if A == 0:\n                DA = 1\n            elif A == N -1:\n                DA = -1\n            if B == 0:\n                DB = 1\n            elif B == N - 1:\n                DB = -1\n            A += DA\n            B += DB\n        res.append(A)\n        pos += 3\n    return res"}
{"task_id": 67, "completion": "def min_maps_to_study(input_string):\n    from decimal import Decimal, getcontext\n    from math import factorial as f\n\n    def comb(n, r):\n        return f(n) // (f(r) * f(n-r))\n\n    getcontext().prec = 7\n\n    N, P = map(Decimal, input_string.strip().split())\n    N = int(N)\n\n    if P == 1: \n        return str(N-1)+'\\n'\n    if P == 0: \n        return '0\\n'\n\n    maps_studied = 0\n    while True:\n        probability_not_picked = (N-maps_studied)/N * (N-maps_studied-1)/(N-1)\n        if probability_not_picked <= 1-P:\n            break\n        maps_studied += 1\n\n    return str(maps_studied)+'\\n'\n"}
{"task_id": 68, "completion": "import cmath\n\ndef get_bubble_sequence(s):\n    lines = list(map(str, s.strip().split('\\n')))\n    N = int(lines[0])\n    bubbles = [(complex(int(coord.split()[0]), int(coord.split()[1])), i+1)\n               for i, coord in enumerate(lines[1:N+1])]\n    Q = int(lines[N+1])\n    directions = [(complex(int(query.split()[0]), int(query.split()[1])), \n                   int(query.split()[2])) for query in lines[N+2:N+2+Q]]\n    all_outputs = {}\n    for direction, K in directions:\n        bubbles_by_angle = sorted(\n            ((cmath.phase(bubble - direction), index) for bubble, index in bubbles))\n        for _ in range(K):\n            _, popped_index = bubbles_by_angle.pop()\n        all_outputs[(direction.real, direction.imag, K)] = popped_index\n    return [all_outputs[(dx, dy, K)] for dx, dy, K in directions]\n"}
{"task_id": 69, "completion": "def solve_queries(input_string):\n    MOD = 10**9 + 7\n    fib = [0, 1] + [0]*100002\n\n    for i in range(2, 100002):\n        fib[i] = (fib[i-1] + fib[i-2]) % MOD\n\n    lines = input_string.strip().split('\\n')\n    N, Q = map(int, lines[0].split())\n    A1 = list(map(int, lines[1].split()))\n    A2 = list(map(int, lines[2].split()))\n    queries = [list(map(int, line.split())) for line in lines[3:]]\n\n    results = []\n    for query in queries:\n        Type = query[0]\n        if Type == 4:\n            l, r = query[1], query[2]\n            tot = sum(fib[A1[i] + A2[i]] for i in range(l-1, r)) % MOD\n            results.append(str(tot))\n        elif Type == 1:\n            k, l, r, x = map(int, query[1:])\n            A = A1 if query[1] == 1 else A2\n            for i in range(l-1, r):\n                A[i] = min(A[i], x)\n        elif Type == 2:\n            k, l, r, x = map(int, query[1:])\n            A = A1 if query[1] == 1 else A2\n            for i in range(l-1, r):\n                A[i] = max(A[i], x)\n        elif Type == 3:\n            k, l, r, x = map(int, query[1:])\n            A = A1 if query[1] == 1 else A2\n            for i in range(l-1, r):\n                A[i] += x\n                \n    return '\\n'.join(results)\n"}
{"task_id": 70, "completion": "from math import gcd\n\ndef connect_cities(input_data):\n    parsed_data = list(map(int, input_data.split()))\n    idx = 0\n    N = parsed_data[idx]\n    idx += 1\n    Q = parsed_data[idx]\n    idx += 1\n\n    cities = []\n    for _ in range(N):\n        cities.append(parsed_data[idx])\n        idx += 1\n\n    diffs = [0] * N\n    for i in range(1, N):\n        diffs[i] = cities[i] - cities[i-1]\n\n    query_results = []\n    for _ in range(Q):\n        L, R, D = parsed_data[idx:idx+3]\n        idx += 3\n\n        if L > 1 and diffs[L-1] % D != 0:\n            query_results.append(\"No\")\n        elif R < N and diffs[R] % D != 0:\n            query_results.append(\"No\")\n        else:\n            query_results.append(\"Yes\")\n\n    return \"\\n\".join(query_results) + \"\\n\"\n"}
{"task_id": 71, "completion": "from operator import itemgetter\nimport math\n\ndef min_path(input):\n    lines = input.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    points = [list(map(int, x.split())) for x in lines[1:]]\n    outlier = points.pop(k - 1)\n    points.sort(key=itemgetter(0, 1))\n    \n    def dist(p1, p2):\n        return math.hypot(p2[0]-p1[0], p2[1]-p1[1])\n\n    line_dist = sum(dist(points[i], points[i+1]) for i in range(n-2))\n\n    total_dist1 = dist(outlier, points[0]) + line_dist + dist(points[-1], points[0])\n    total_dist2 = dist(outlier, points[-1]) + line_dist + dist(points[0], points[-1])\n    \n    return min(total_dist1, total_dist2)\n"}
{"task_id": 72, "completion": "from sys import stdout\n\ndef solve():\n    def query(x, y):\n        print('?', x, y)\n        stdout.flush()\n        return int(input())\n\n    lo = 1\n    hi = 10**9\n    while lo < hi:\n        mid = (lo+hi+1)//2\n        if query(mid, 1) >= mid-1:\n            lo = mid\n        else:\n            hi = mid - 1\n\n    x1 = lo\n    lo = 1\n    hi = 10**9\n    while lo < hi:\n        mid = (lo+hi)//2\n        if query(1, mid) >= mid-1:\n            hi = mid\n        else:\n            lo = mid + 1\n\n    y1 = lo\n    lo = 1\n    hi = 10**9 - x1 + 1\n    while lo < hi:\n        mid = (lo+hi+1)//2\n        if query(10**9 - mid + 1, 10**9) >= mid:\n            lo = mid\n        else:\n            hi = mid - 1\n\n    y2 = 10**9 - lo + 1\n    lo = 1\n    hi = 10**9 - y1 + 1\n    while lo < hi:\n        mid = (lo+hi)//2\n        if query(10**9, 10**9 - mid + 1) >= mid:\n            hi = mid\n        else:\n            lo = mid + 1\n\n    x2 = 10**9 - lo + 1\n    print('!', x1, y1, x2, y2)\n    stdout.flush()"}
{"task_id": 73, "completion": "from collections import deque\ndef count_desert_pairs(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    n, m = map(int, input_lines[0].split())\n    edges = [list(map(int, line.split())) for line in input_lines[1:]]\n\n    edges = [(u - 1, v - 1) for u, v in edges]  # nodes are 0-indexed\n\n    lnk = [[] for _ in range(n)]\n    pre = [0] * m\n    low = [0] * m\n    cf = [0] * m\n    vis = [0] * m\n    last = [0] * m\n    bel = [0] * n\n    ans = [0] * (m + 1)\n    cnt = 0\n    eidx = [0] * (m + 2)\n    que = deque()\n\n    for i in range(m - 1, -1, -1):\n        u, v = edges[i]\n        lnk[u].append((v, i))\n        lnk[v].append((u, i))\n\n    def dfs(u, id):\n        nonlocal cnt\n        pre[id] = low[id] = cnt = cnt + 1\n        que.append((u, id))\n        vis[id] = 1\n        last[id] = u\n        for v, i in lnk[u]:\n            if i == id:\n                continue\n            if pre[i] == 0:\n                dfs(v, i)\n                low[id] = min(low[id], low[i])\n                if low[i] == pre[id]:\n                    que.append((v, i))\n                    while True:\n                        x, id = que.pop()\n                        vis[id] = -1\n                        bel[last[id]] = id\n                        if id == i:\n                            break\n            elif vis[i] == 1:\n                low[id] = min(low[id], pre[i])\n\n    for i in range(m - 1, -1, -1):\n        dfs(*edges[i], i)\n\n    for i in range(m):\n        if pre[i] <= pre[bel[last[i]]]:\n            cf[i] = i\n        else:\n            cf[i] = cf[bel[last[i]]]\n\n    for i in range(m - 1, -1, -1):\n        eidx[cf[i]] = max(eidx[cf[i]], i)\n\n    for i in range(m):\n        ans[i + 1] = ans[i] + eidx[i] - i + 1\n\n    return str(ans[m]) + '\\n'\n\n"}
{"task_id": 74, "completion": "def array_beautifier(input_string):\n    n, *B = map(int, input_string.split())\n    m = B[-1]\n    A = [0]*n\n    A[-1] = m\n\n    for i in range(n-2, -1, -1):\n        m = max(m, B[i])\n        if m > B[i+1]:\n            return 'NO'\n        A[i] = m - B[i+1]\n\n    return 'YES\\n' + ' '.join(map(str, A))\n"}
{"task_id": 75, "completion": "def game_winner(s):\n    data = s.splitlines()\n    N = int(data[0].strip())\n    A = list(map(int, data[1].strip().split()))\n\n    dp = [[-1 for _ in range(N)] for _ in range(N)]\n\n    def play_game(l, r, last):\n        if l > r:\n            return 0\n        if dp[l][r] != -1:\n            return dp[l][r]\n\n        left_play = right_play = 0\n        if A[l] > last:\n            left_play = 1 - play_game(l + 1, r, A[l])\n        if A[r] > last:\n            right_play = 1 - play_game(l, r - 1, A[r])\n\n        dp[l][r] = max(left_play, right_play)\n        return dp[l][r]\n\n    winner = play_game(0, N - 1, -1)\n    return \"Alice\\n\" if winner == 1 else \"Bob\\n\""}
{"task_id": 76, "completion": "from collections import defaultdict\nfrom itertools import combinations\n\n\ndef successful_party(input_string):\n    # Parse input\n    data = list(map(int, input_string.split()))\n    N, M = data[0], data[1]\n    friendships = [(data[i], data[i + 1]) for i in range(2, 2 * M + 2, 2)]\n\n    # Build graph using defaultdict\n    graph = defaultdict(set)\n    for u, v in friendships:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Function to check if a set of nodes is a clique (all are connected)\n    def is_clique(people):\n        return all((a in graph[b] or b in graph[a]) for a in people for b in people if a != b)\n\n    # Function to check if a set of nodes is an independent set (none are connected)\n    def is_independent_set(people):\n        return not any((a in graph[b] or b in graph[a]) for a in people for b in people if a != b)\n\n    # Check combinations of 5 people to find either a clique or an independent set\n    for people in combinations(range(1, N + 1), 5):\n        if is_clique(people) or is_independent_set(people):\n            return \" \".join(map(str, sorted(people))) + \"\\n\"\n\n    # If no successful party found, return -1\n    return \"-1\\n\"\n"}
{"task_id": 77, "completion": "def room_sizes(s):\n    # Convert the string into lines\n    lines = s.strip().split(\"\\n\")\n    n, m = map(int, lines[0].split())\n\n    # Parse the tile lines into integer numbers and convert to binary strings\n    tiles = [[bin(int(num))[2:].zfill(4) for num in line.split()] for line in lines[1:]]\n\n    visited = [[False]*m for _ in range(n)]\n    room_sizes = []\n\n    def dfs(i, j):\n        if i<0 or j<0 or i>=n or j>=m or visited[i][j]:\n            return 0\n        visited[i][j] = True\n        size = 1\n        tile = tiles[i][j]\n        if tile[0] == '0':\n            size += dfs(i-1,j) # North\n        if tile[1] == '0':\n            size += dfs(i,j+1) # East\n        if tile[2] == '0':\n            size += dfs(i+1,j) # South\n        if tile[3] == '0':\n            size += dfs(i,j-1) # West\n        return size\n\n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j]:\n                room_sizes.append(dfs(i,j))\n\n    return ' '.join(map(str, sorted(room_sizes, reverse=True))) + ' '\n\nprint(room_sizes('4 5\\n9 14 11 12 13\\n5 15 11 6 7\\n5 9 14 9 14\\n3 2 14 3 14\\n'))  # Output: 9 4 4 2 1 \n"}
{"task_id": 78, "completion": "\n\ndef find_possible_k(input_str):\n    def find_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n\n    input_lines = input_str.strip().split('\\n')\n    t = int(input_lines[0])\n    result = []\n\n    line_index = 1\n    for _ in range(t):\n        n = int(input_lines[line_index])\n        a = list(map(int, input_lines[line_index + 1].split()))\n        line_index += 2\n\n        bit_count = [0] * 30\n        for number in a:\n            for bit in range(30):\n                if number & (1 << bit):\n                    bit_count[bit] += 1\n\n        common_divisors = set()\n        initialized = False\n        for count in bit_count:\n            if count > 0:\n                current_divisors = find_divisors(count)\n                if not initialized:\n                    common_divisors = current_divisors\n                    initialized = True\n                else:\n                    common_divisors &= current_divisors\n\n        if all(x == 0 for x in a):\n            result.append(\" \".join(map(str, range(1, n + 1))))\n        else:\n            result.append(\" \".join(map(str, sorted(common_divisors))))\n\n    return \"\\n\".join(result) +\"\\n\""}
{"task_id": 79, "completion": "def minJumps(jumpData):\n    lines = jumpData.split(\"\\n\")\n    n = int(lines[0])\n    jump_heights = [0] + list(map(int, lines[1].split()))\n    rest_slips = [0] + list(map(int, lines[2].split()))\n\n    INF = 1e9+7\n    dp = [INF]*(n+1)\n    dp[0] = 0\n    jump_sequences = [0]*(n+1)\n    \n    for i in range(n,0,-1):\n        for j in range(i+1, min(n+1, i + jump_heights[i] + 1)):\n            if dp[j] + 1 < dp[i - rest_slips[i]]:\n                dp[i - rest_slips[i]] = dp[j] + 1\n                jump_sequences[i - rest_slips[i]] = i\n\n    if dp[1] == INF:\n        return \"-1\\n\"\n\n    result = []\n    depth = 1\n    while depth <= n:\n        result.append(str(jump_sequences[depth]))\n        depth = jump_sequences[depth] + 1\n\n    return str(len(result)) + '\\n' + ' '.join(result[::-1]) + ' '\n"}
{"task_id": 80, "completion": "import bisect\n\ndef min_inversions(input_str):\n    in_str = input_str.strip().split('\\n')\n    count_of_test_cases = int(in_str[0])\n    result = []\n    \n    for t in range(count_of_test_cases):  \n        n, m = map(int, in_str[1+3*t].split())\n        a = list(map(int, in_str[2+3*t].split()))\n        b = sorted(((value, index) for index, value in enumerate(map(int, in_str[3+3*t].split()))), reverse=True)\n        \n        last = [-1]*m\n        b_pos = [0]*m\n        cnt = [0]*(n+1)\n        \n        for i in range(m):\n            if b[i][0] != b[i-1][0] or i == 0:\n                last[i] = -1\n            else:\n                last[i] = b_pos[i-1]\n\n        for i, aa in enumerate(a):\n            while len(b) > 0 and b[-1][0] < aa:\n                _, pos = b.pop()\n                b_pos[pos] = cnt[aa-1]\n                cnt[aa] += 1\n        \n        for pos, last_pos in zip(b_pos, last):\n            x = last_pos and pos - last_pos or 0\n            y = m - pos\n            result.append(str(x + min(pos - x, y - x)))\n                \n    return \"\\n\".join(result) \n"}
{"task_id": 81, "completion": "def max_alpinists(input_string):\n    from heapq import heapify, heappop, heappush\n    rows = input_string.split(\"\\n\")\n    n, d = map(int, rows[0].split())\n    alpinists = sorted([list(map(int, i.split())) for i in rows[1:-1]], key = lambda x: [-x[0], x[1]])\n\n    heap = []\n    heapify(heap)\n\n    for s, a in alpinists:\n        if s >= d:\n            heappush(heap, a)\n            d = max(d, heap[0])\n        elif heap and heap[0] < a and heap[0] <= s:\n            heappop(heap)\n            heappush(heap, a)\n            d = max(d, a)\n\n    return str(len(heap))\n\ninput_data = \"5 0\\n1 5\\n4 8\\n2 7\\n7 6\\n3 2\\n\"\nprint(max_alpinists(input_data))  # Returns: 3\n\ninput_data = \"3 2\\n2 6\\n3 5\\n5 7\\n\"\nprint(max_alpinists(input_data))  # Returns: 2\n"}
{"task_id": 82, "completion": "def calculate_min_cost(n, q, k, prices, lrs):\n    prices = [0] + prices + [10**18] * (k + 2)\n    n = len(prices)\n    \n    min_cost = [0] * n\n    for i in range(n - 2, -1, -1):\n        min_cost[i] = min(prices[i] + min_cost[i + 1], min_cost[i]) \n        if i + k < n - 1:\n            min_cost[i] = min(prices[i] + min_cost[i + k], min_cost[i])\n\n    result = []\n    for l, r in lrs:\n        res = min_cost[l]\n        if l + k <= r:\n            res += min_cost[l + k]\n        result.append(res)\n    return result\n"}
{"task_id": 83, "completion": "def lexicographic_sum(s):\n    s = int(s.strip())\n    maxl = 50\n    MOD = 998244353\n    to_mod = 10**9 + 7\n    dp, pw, inv, fact, invf = [0]*maxl, [0]*maxl, [0]*maxl, [0]*maxl, [0]*maxl\n    inv[1] = 1\n    for i in range(2,maxl):\n        inv[i] = MOD - (MOD//i) * inv[MOD%i] % MOD\n    pw[0] = fact[0] = invf[0] = 1\n    for i in range(1,maxl):\n        pw[i] = pw[i-1]*10%MOD\n        fact[i] = fact[i-1]*i%MOD\n        invf[i] = invf[i-1]*inv[i]%MOD\n    s = str(s)\n    l = len(s)\n    for i in range(l-1,-1,-1):\n        x = int(s[i])\n        for j in range(x):\n            dp[i] = (dp[i] + pw[l-i-1]*j%MOD*fact[i]%MOD*invf[i-1]%MOD) % MOD\n            if i!=l-1:\n                dp[i] = (dp[i] + pw[l-i-1]*j%MOD*dp[i+1]%MOD*inv[i]%MOD) % MOD\n        if i!=l-1:\n            dp[i+1] = (dp[i+1] + x*fact[i+1]%MOD*invf[i]%MOD) % MOD\n    dp[0] = (dp[0] + pw[l]*s%MOD*fact[l-1]%MOD*invf[l-1]%MOD) % MOD\n    return dp[0] % to_mod\n"}
{"task_id": 84, "completion": "import math\n\n\ndef min_sequence(input_str):\n    def gcd_pairs_count(l, r):\n        count = 0\n        for i in range(l, r + 1):\n            for j in range(i, r + 1):\n                if math.gcd(i, j) >= l:\n                    count += 1\n        return count\n\n    def dynamic_programming(n, k):\n        dp = [[float('inf')] * (n + 1) for _ in range(k + 1)]\n        dp[0][0] = 0\n\n        c_values = [[0] * (n + 1) for _ in range(n + 1)]\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                c_values[l][r] = gcd_pairs_count(l, r)\n\n        for i in range(1, k + 1):\n            for j in range(i, n + 1):\n                for x in range(i - 1, j):\n                    dp[i][j] = min(dp[i][j], dp[i - 1][x] + c_values[x + 1][j])\n\n        return dp[k][n]\n\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0].strip())\n    results = []\n\n    for i in range(1, t + 1):\n        n, k = map(int, lines[i].strip().split())\n        results.append(str(dynamic_programming(n, k)))\n\n    return \"\\n\".join(results) + \"\\n\"\n"}
{"task_id": 85, "completion": "def perfect_sequences(seq):\n    n, mod = map(int, seq.split())\n    powerOfTwo = [1]\n    invPowerOfTwo = [1]\n    for _ in range(n):\n        powerOfTwo.append(powerOfTwo[-1] * 2 % mod)\n        invPowerOfTwo.append(invPowerOfTwo[-1] * (mod + 1) // 2 % mod)\n    dp = [[0] * (n + 2) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(n, -1, -1):\n            dp[i][j] = (dp[i - 1][j] * powerOfTwo[j + 1] + dp[i - 1][j + 1]) % mod\n    return sum(dp[n][i] for i in range(n + 1)) % mod\n"}
{"task_id": 86, "completion": "def solve_problem(t, test_cases):\n    mod = 998244353\n    maxn = 70\n    dp = [[0]*maxn for _ in range(maxn)]\n    ans = [[0]*maxn for _ in range(maxn)]\n    res = []\n    for i in range(maxn):\n        dp[i][0] = pow(2, i, mod)\n        ans[i][0] = pow(2, i, mod)\n    for i in range(1, maxn):\n        for j in range(1, i+1):\n            dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]*2)%mod\n            ans[i][j] = (dp[i][j] + ans[i-1][j])%mod\n    for _ in range(t):\n        n, k, x = test_cases[_]\n        if x == 0:\n            x = min(k, 20)\n            res.append(pow(2, n-x, mod))\n        else:\n            res.append(ans[min(k, 20)][bin(x).count('1')])\n    return res\n\nprint(solve_problem(6, [(2,2,0), (2,1,1), (3,2,3), (69,69,69), (2017,10,18), (5,7,0)]))\n\n[6, 1, 15, 699496932, 892852568, 713939942]\n"}
{"task_id": 87, "completion": "def min_operations(input_str):\n    data = input_str.strip().split('\\n')\n    t = int(data[0])  # Number of test cases\n    results = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index])  # Number of elements in the test case\n        a = list(map(int, data[index + 1].split()))  # List of integers\n        max_diff = 0\n        for i in range(n):\n            diff = a[i] - (i + 1)\n            if diff > max_diff:\n                max_diff = diff\n        results.append(str(max_diff))\n        index += 2  # Move to the next test case\n    return '\\n'.join(results) +\"\\n\""}
{"task_id": 88, "completion": "def canSplitSequence(tests):\n    data = tests.strip().split('\\n')\n    t = int(data[0])\n    res = []\n    for i in range(t):\n        n = int(data[1 + i * 2])\n        a = list(map(int, data[2 + i * 2].split()))\n\n        count = [0] * (n + 1)\n        xor = 0\n        for j in range(n):\n            if j == 0 or a[j - 1] >= a[j]:\n                xor ^= count[min(count)-1]\n                count = [0] * (n + 1)\n            count[a[j]] += 1\n\n        xor ^= count[min(count)-1]\n\n        if xor == 0:\n            res.append('YES')\n        else:\n            res.append('NO')\n    return \"\\n\".join(res)\n"}
{"task_id": 89, "completion": "def erase_sequence(s):\n    tdata = s.split('\\n')\n    t = int(tdata[0])\n    tests = tdata[1:-1]\n    seq_lengths = list(map(int, tests[::2]))\n    sequences = [list(map(int, a.split())) for a in tests[1::2]]\n    test_cases = list(zip(seq_lengths, sequences))\n    result = []\n    for n, a in test_cases:\n        a = [(x % (i+2)) for i, x in enumerate(a)]\n        if 0 in a:\n            result.append('NO\\n')\n        else:\n            result.append('YES\\n')\n    return ''.join(result)\n"}
{"task_id": 90, "completion": "def find_integer_n(input_string):\n    tests_list = list(map(int,input_string.strip().split()))[1:] \n    n_values = []\n    \n    for i in range(0,len(tests_list),2):\n        x = tests_list[i]\n        y = tests_list[i+1]\n        \n        if y <= x:\n            n_values.append(str(x))\n        else:\n            for n in range(y+1, 2 * 10 ** 18 + 1):\n                if x % n == y % n:\n                    n_values.append(str(n))\n                    break\n    return \"\\n\".join(n_values)\n"}
{"task_id": 91, "completion": "def solve(input_string: str) -> str:\n    MOD = 998244353\n\n    tests = input_string.strip().split(\"\\n\")\n    pointer = 1\n    out = []\n    \n    for _ in range(int(tests[0])):\n        n = int(tests[pointer])\n        a = list(map(int, tests[pointer+1].split()))\n        pointer += 2\n        ans = 0\n        c = [0]*(n+1)\n        pre = [0]*(n+1)\n        suf = [0]*(n+1)\n        \n        for i in range(n):\n            pre[i+1] = pre[i] + a[i] * (i+1)\n            pre[i+1] %= MOD\n        for i in range(n-1, -1, -1):\n            suf[i] = suf[i+1] + a[i] * (n-i)\n            suf[i] %= MOD\n            \n        for i in range(n):\n            ans += a[i]\n            ans %= MOD\n            \n        for i in range(1, n+1):\n            c[i] = (c[i-1] + (pre[i] * pow(i, MOD-2, MOD) % MOD)) % MOD\n            \n        for i in range(1, n+1):\n            ans += (((pre[n] - pre[n-i] - c[n-i] + MOD) % MOD) * pow(n, MOD-2, MOD)) % MOD\n            ans %= MOD\n            \n        for i in range(1, n):\n            ans += (((suf[0] - suf[i] - (pre[n] - pre[n-i]) + MOD) % MOD) * pow(n-i, MOD-2, MOD)) % MOD\n            ans %= MOD\n        \n        out.append(str(ans))\n    \n    return \"\\n\".join(out)\n"}
{"task_id": 92, "completion": "def balance_AB_BA(s):\n    ab_count = s.count('ab')\n    ba_count = s.count('ba')\n    diff = abs(ab_count - ba_count)\n    result = s\n    if ab_count > ba_count:\n        result = s.replace('ab', 'bb', diff // 2)\n    elif ba_count > ab_count:\n        result = s.replace('ba', 'aa', diff // 2)\n    return result"}
{"task_id": 93, "completion": "def min_time_to_update(n, k):\n    if n <= k:\n        return 1\n    elif n % k == 0:\n        return n // k\n    else:\n        return n // k + 1"}
{"task_id": 94, "completion": "def min_positive_burles(test_cases):\n  data = test_cases.split('\\n')[:-1] # remove last empty string\n  t = int(data[0])\n  result = []\n  index = 1\n  for _ in range(t):\n    n,k = map(int,data[index].split())\n    values = sorted(list(map(int, data[index+1].split())))\n    index += 2\n    b_values = [0] + [10**values[i]*(i+1) for i in range(n)]\n    b_k_values = [0] + [10**values[i]*(1+k//(i+1)) for i in range(n)]\n    for i in range(n, -1, -1):\n        while b_k_values[i] < b_values[i]:\n            b_k_values[i-1] = min(b_k_values[i-1], b_values[i-1])\n            b_values[i-1] = b_k_values[i-1]-1\n    result.append(str(b_values[0]))\n  return \"\\n\".join(result)\n\ntest_cases= '4\\n3 13\\n0 1 2\\n2 777\\n0 4\\n3 255\\n0 1 3\\n10 1000000000\\n0 1 2 3 4 5 6 7 8 9\\n'\nprint(min_positive_burles(test_cases)) # should print:\n'''\n59\n778\n148999\n999999920999999999\n'''\n"}
{"task_id": 95, "completion": "import sys\nfrom collections import defaultdict, deque\nfrom heapq import heapify, heappop, heappush\n \ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    a = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    r = [sorted([(v, j) for j, v in enumerate(a[i])]) for i in range(n)]\n    b = defaultdict(list)\n    for i in range(n):\n        b[r[i][0][0]].append(i)\n    c = 0\n    s = [0]*n\n    e = sorted([(v, i) for i, v in b.items()])\n    heapify(e)\n    d = deque()\n    while e:\n        if c > len(e):\n            return 'MISMATCH'\n        v, i = heappop(e)\n        if not c:\n            if len(b[i]) != 1:\n                return 'MISMATCH'\n            j = b[i][0]\n            while len(b[i]) == 1 and r[j][s[j]][0] == i:\n                d.extend(b[i])\n                if s[j]+1 == m or r[j][s[j]+1][0] != i:\n                    c += 1\n                else:\n                    s[j] += 1\n                if c > len(e):\n                    break\n                v, i = heappop(e)\n        if c:\n            while len(b[i]) > 1 and r[b[i][0]][s[b[i][0]]][0] == i:\n                if s[b[i][0]]+1 == m or r[b[i][0]][s[b[i][0]]+1][0] != i:\n                    c -= 1\n                else:\n                    s[b[i][0]] += 1\n                heappush(e, (r[b[i][0]][s[b[i][0]]][0], i))\n            if len(b[i]) == 1 and r[b[i][0]][s[b[i][0]]][0] == i:\n                d.append(b[i][0])\n            else:\n                return 'MISMATCH'\n    for v, i in d:\n        b[v].remove(i)\n    for v in d:\n        if s[v] == m-1 and r[v][s[v]][0] == r[v][s[v]+1][0]:\n            s[v] += 1\n    y = ['B']*n\n    for i in range(n):\n        if s[i] == m:\n            y[i] = 'R'\n    return 'YES\\n'+str(max(s))+'\\n'+''.join(y)"}
{"task_id": 96, "completion": "def no_winner_fight(input):\n    n, x = map(int, input.split())\n    mod = 998244353\n    power = [pow(i, n, mod) for i in range(x+2)]\n    dp = [[0] * (x+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(x, i-2, -1):\n            dp[i][j] = (dp[i][j+1] + dp[i-1][j-i]) % mod\n        for j in range(i-2, -1, -1):\n            dp[i][j] = dp[i][j+1]\n    return str((power[n+1] - 1 - dp[n][0] + mod) % mod)\n"}
{"task_id": 97, "completion": "import sys\nfrom collections import defaultdict, deque, Counter\nfrom itertools import chain, accumulate\ndef max_tree_value(r):\n    rr = r.strip().split(\"\\n\")\n    n = int(rr.pop(0))\n    items = list(map(int, ' '.join(rr).split()))\n    e = defaultdict(list)\n    for u, v in zip(items[:2*(n-1):2], items[1:2*(n-1):2]):\n        e[u].append(v)\n        e[v].append(u)\n    q, que = items[2*n-2], [(items[i], items[i+1]) for i in range(2*n-1, len(items), 2)]\n    H = Counter(chain.from_iterable(e.values()))\n    res = [0]*(n+1)\n    dfs = deque(sorted(((v, 0, i, k) for i, (v, k) in enumerate(que)), key = lambda x: x[3], reverse = True))\n    while dfs:\n        v, t, i, k = dfs[0]\n        while dfs and k == dfs[0][3]:\n            v, t, i, k = dfs.popleft()\n            if res[v] < t:\n                res[v] = t\n                if e[v]:\n                    h = H[v]+1\n                    H[v] = 0\n                    ne = sorted((H[u] for u in e[v]), reverse = True)\n                    s = list(accumulate(ne))\n                    r = max(t+2*(ne[j]-1+(j < h-2))+min(2, h-j-1) for j in range(h)) if h > 1 else t+2*ne[0]\n                    if r > s[-1] and e[v] != [1] or r == s[-1] and h < 2:\n                        t = r\n                        for u in e[v]:\n                            H[u] = 0\n                    elif H[v] == 0:\n                        dfs.appendleft((v, t, i, k))\n        for u in e[v]:\n            if H[u]:\n                e[u].remove(v)\n                dfs.appendleft((u, max(H[u]+t-2*k if H[u] > 1 else t, t+H[u]-1), i, k))\n    return \"\\n\".join(str(res[que[i][0]]) for i in range(q))\n"}
{"task_id": 98, "completion": "def typing_time(input_string):\n    # Splitting the inputs\n    split_inputs = input_string.split(\"\\n\")\n    \n    # Number of test cases\n    test_cases = int(split_inputs[0])\n    split_inputs.pop(0)\n\n    # A list to hold the results of each case\n    results = []\n    \n    for i in range(0, 2 * test_cases, 2):\n        # Getting the layout and word\n        layout = list(split_inputs[i])\n        word = list(split_inputs[i + 1])\n\n        # Calculating the initial position\n        position = layout.index(word[0])\n        time = 0\n\n        # Looping through all letters of the word\n        for letter in word:\n            # Calculating the absolute difference in positions\n            time += abs(position - layout.index(letter))\n            # Updating the position\n            position = layout.index(letter)\n        results.append(str(time))\n        \n    # Joining the results with a newline and returning\n    return \"\\n\".join(results)\n"}
{"task_id": 99, "completion": "def find_position(tests):\n\n    res = []\n    tests = tests.strip().split('\\n')\n    t = int(tests.pop(0))\n    tests = [[int(x) for x in i.split()] for i in tests]\n    \n    for x, n in tests:\n        j = 1\n        while j <= n:\n            if x%2==0: \n                x -= j\n            else:\n                x += j\n            j += 1\n        res.append(str(x))\n        \n    return \"\\n\".join(res)"}
{"task_id": 100, "completion": "def maximal_minimal(input_str: str):\n    lines = input_str.splitlines()\n    t = int(lines[0])\n    result = []\n    idx = 1\n    for _ in range(t):\n        n = int(lines[idx])\n        a = list(map(int, lines[idx + 1].split()))\n        a.sort()\n        max_min = a[0]\n        for i in range(1, n):\n            max_min = max(max_min, a[i] - a[i - 1])\n        result.append(str(max_min))\n        idx += 2\n    return '\\n'.join(result) +\"\\n\""}
{"task_id": 101, "completion": "from collections import deque\n\ndef can_form_permutation(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    test_cases = int(input_lines[0])\n    tests = input_lines[1:]\n\n    tests = [(int(tests[i]), list(map(int, tests[i+1].split())), tests[i+2]) for i in range(0, len(tests), 3)]\n\n    results = []\n    \n    for t in tests:\n        n = t[0]\n        array = t[1]\n        color = t[2]\n        blue = deque(sorted((a for a, c in zip(array, color) if c == 'B')))\n        red = deque(sorted((a for a, c in zip(array, color) if c == 'R')))\n\n        can_make = True\n        for i in range(1, n+1):\n            if blue and (not red or blue[0] <= i <= blue[-1] or i > red[0]):\n                if not blue or blue[0] > i:\n                    can_make = False\n                    break\n                while blue and blue[0] < i:\n                    blue.popleft()\n                if not blue:\n                    can_make = False\n                    break\n                blue.popleft()\n            else:\n                if not red or red[0] > i:\n                    can_make = False\n                    break\n                while red and red[0] < i:\n                    red.popleft()\n                if not red:\n                    can_make = False\n                    break\n                red.popleft()\n\n        results.append('YES' if can_make else 'NO')\n\n    return \"\\n\".join(results)\n"}
{"task_id": 102, "completion": "def process_commands(x, y, s_input, n, m):\n    commands = 0\n    for command in s_input:\n        if command == 'L':\n            y -= 1\n        elif command == 'R':\n            y += 1\n        elif command == 'U':\n            x -= 1\n        elif command == 'D':\n            x += 1\n        if not (1 <= x <= n and 1 <= y <= m):\n            return commands\n        commands += 1\n    return commands\n\n\ndef get_best_cell_for_case(n, m, s_input):\n    best_cell = (1, 1)\n    max_commands = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            commands = process_commands(i, j, s_input, n, m)\n            if commands > max_commands:\n                max_commands = commands\n                best_cell = (i, j)\n    return best_cell\n\n\ndef optimal_starting_position(s):\n    lines = s.splitlines()\n    t = int(lines[0])\n    results = []\n    line_idx = 1\n\n    def extract_test_case_data(line_idx):\n        n, m = map(int, lines[line_idx].split())\n        s_input = lines[line_idx + 1]\n        return n, m, s_input\n\n    def add_result_to_list(best_cell):\n        results.append(f\"{best_cell[0]} {best_cell[1]}\")\n\n    for _ in range(t):\n        n, m, s_input = extract_test_case_data(line_idx)\n        best_cell = get_best_cell_for_case(n, m, s_input)\n        add_result_to_list(best_cell)\n        line_idx += 2\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 103, "completion": "def max_robot_steps(test_cases):\n    moves = {\"U\": (-1, 0), \"R\": (0, 1), \"D\": (1, 0), \"L\": (0, -1)}\n    result = ''\n    \n    for _ in range(test_cases):\n        n, m = map(int, input().split())\n        grid = [list(input()) for _ in range(n)]\n        max_steps = -0x3f3f3f3f\n        x, y, end = 0, 0, 0\n\n        visited = [[0]*m for _ in range(n)]\n        steps = [[0]*m for _ in range(n)]\n        \n        def dfs(i, j):\n            nonlocal end\n            visited[i][j] = 1\n            x, y = i + moves[grid[i][j]][0], j + moves[grid[i][j]][1]\n            if x < 0 or x >= n or y < 0 or y >= m:\n                return 1\n            if not visited[x][y]:\n                steps[x][y] = dfs(x, y) + 1\n            else:\n                if steps[x][y]:\n                    return steps[x][y] + 1\n                end = 1\n            return steps[i][j] if steps[i][j] or end else 0\n        \n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j]:\n                    end = 0\n                    steps[i][j] = dfs(i, j)\n                if steps[i][j] > max_steps:\n                    max_steps = steps[i][j]\n                    x = i + 1\n                    y = j + 1\n\n        result += '{} {} {}\\n'.format(x, y, max_steps)\n    return result"}
{"task_id": 104, "completion": "import heapq\n\ndef minimal_balance(tests):\n    tests = tests.strip().split(\"\\\\n\\\\n\")\n    t = int(tests[0])\n    tests = tests[1:]\n    total_output = []\n    \n    for test in tests:\n        lines = test.split('\\\\n')\n        n, m = map(int, lines[0].split())\n        a = []\n        total = 0\n        balance = 0\n        \n        for line in lines[1:]:\n            fi, me = map(int, line.split())\n            total += fi\n            heapq.heappush(a, (-max(fi, me), -min(fi, me)))\n        total -= m*n\n        for _ in range(n):\n            fi, me = heapq.heappop(a)\n            fi, me = -fi, -me\n            next_fi = max(-a[0][0] if a else 0, me) if total >= m else max(me + total, me - m)\n            balance = max(balance, abs(total - next_fi))\n            total -= next_fi\n            heapq.heappush(a, (-next_fi, -me))\n\n        total_output.append(str(balance))\n        for _ in range(n):\n            fi, me = heapq.heappop(a)\n            fi, me = -fi, -me\n            if fi >= me and total >= m:\n                total_output.append(str(me) + \" \" + str(m-me))\n            elif fi >= me:\n                total_output.append(str(m-total) + \" \" + str(total))\n                total = 0\n            else:\n                total_output.append(str(fi) + \" \" + str(m-fi))\n    return \"\\\\n\".join(total_output)\n"}
{"task_id": 105, "completion": "def min_dish_variety(tests_input):\n    tests_input = [test.split('\\n') for test in tests_input.split('\\n\\n')]\n    num_tests = int(tests_input[0][0])\n    tests = tests_input[1:]\n    results = []\n    for test in range(num_tests):\n        num_dishes = int(tests[test][0])\n        dishes = tests[test][1:]\n        dishes = [list(map(int,dish.split())) for dish in dishes]\n        total_foods = []\n        for i in range(num_dishes):\n            fish, meat, total_food = dishes[i]\n            total_foods.append((total_food, i+1, fish, meat, fish+meat-total_food))\n        total_foods.sort(reverse=True)\n        heap = []\n        min_variety = num_dishes\n        for meal, dish_num, fish, meat, total_eat in total_foods:\n            while heap and heap[0][0] >= meal:\n                min_variety -=1\n                heap.pop(0)\n            heap.insert(0, (meal, dish_num))\n        results.append(str(min_variety))\n        heap2 = [(-1,0,0)]\n        for meal, dish_num, fish, meat, total_eat in sorted(total_foods):\n            while heap2 and heap2[-1][1] + min(fish,meal-heap2[-1][2]) >= meal :\n                _,lastfish,lastmeal = heap2.pop()\n            fish = meal - max(0, lastmeal - heap2[-1][2])\n            heap2.append((dish_num,fish,meal))\n        results.extend([f\"{i} {j}\" for _,i,j in sorted(heap2[1:])])\n    return \"\\n\".join(results)\n"}
{"task_id": 106, "completion": "def find_arrays(s):\n    test_cases = list(map(int, s.strip().split(\"\\n\")))\n    t = test_cases.pop(0)\n    result = \"\"\n    \n    for _ in range(t):\n        n = test_cases.pop(0)\n        array = [str(i+1) for i in range(n)]\n        result += (\" \".join(array) + \"\\n\")\n        \n    return result.rstrip()\n"}
{"task_id": 107, "completion": "def solve(test_cases):\n    result = []\n    \n    for n, a, b in test_cases:\n        if a+b > n+1:\n            result.append(\"-1\")\n            continue\n        \n        remaining = n - b\n        peaks = [str(i) for i in range(remaining, 0, -1)]\n        valleys = [str(i) for i in range(remaining + 1, n + 1)]\n        \n        permutation = valleys[:b] + peaks + valleys[b:]\n        result.append(\" \".join(permutation))\n        \n    return result\n\nsolve([(4, 1, 1), (6, 1, 2), (6, 4, 0)])\n\n['1 4 2 3', '1 6 5 2 3 4', '-1']\n"}
{"task_id": 108, "completion": "def tournament(input_str):\n    t = input_str.strip().split('\\n')\n    t = int(t[0])\n    test_cases = input_str.strip().split('\\n')[1:]\n    res = []\n    for i in range(t):\n        n = int(test_cases[i*3])\n        a = list(map(int, test_cases[i*3+1].split()))\n        b = list(map(int, test_cases[i*3+2].split()))\n        p = sorted([(min(a[j], b[j]), max(a[j], b[j]), j) for j in range(n)])\n        can_win = [0]*n\n        mx = -1\n        for _, b, j in p:\n            if b > mx:\n                can_win[j] = 1\n                mx = b\n        res.append(''.join(map(str, can_win)))\n    return '\\n'.join(res)\n"}
{"task_id": 109, "completion": "MOD = 998244353\ndef valid_colorings(n, dominoes):\n  G = [[] for _ in range(2 * n + 2)]\n  vis = [False for _ in range(2 * n + 2)]\n  fc = [[0, 0] for _ in range(2 * n + 2)]\n  c = [0 for _ in range(2 * n + 2)]\n\n  def add_edge(u, v):\n    G[u].append(v)\n    G[v].append(u)\n\n  def dfs(u, pre):\n    fc[u][0] = fc[u][1] = 1\n    vis[u] = True\n    for v in G[u]:\n      if v == pre:\n        continue\n      dfs(v, u)\n      fc[u][0], fc[u][1] = (fc[u][0] * fc[v][1]) % MOD, (fc[u][1] * fc[v][0]) % MOD\n    if c[u] == 1:\n      fc[u][1] = fc[u][0]\n    if c[u] == -1:\n      fc[u][0] = fc[u][1]\n\n  for i in range(1, n + 1):\n    a, b = dominoes[i - 1]\n    if a != '?':\n      c[2 * i] = 1 if a == 'B' else -1\n    if b != '?':\n      c[2 * i + 1] = 1 if b == 'B' else -1\n    add_edge(2 * i, ((i % n) + 1) * 2 - 1)\n    add_edge(2 * i + 1, ((i % n) + 1) * 2)\n\n  ans = 1\n  for i in range(2, 2 * n + 2):\n    if not vis[i]:\n      fc[0] = [1, 0]\n      dfs(i, 0)\n      ans = (ans * (fc[0][0] + fc[0][1])) % MOD\n\n  return ans\n"}
{"task_id": 110, "completion": "def max_cells(input):\n    from collections import defaultdict as ddic\n    lines = input.split('\\n')\n    n = int(lines[0])\n    d = ddic(list)\n    for i in range(1,n+1):\n        x, y, c = map(int, lines[i].split())\n        d[c].append((x, y))\n\n    x = sorted([min(j[0] for j in d[i]), max(j[0] for j in d[i])] for i in d)\n    y = sorted([min(j[1] for j in d[i]), max(j[1] for j in d[i])] for i in d)\n\n    return str((y[0][1]-y[0][0]+1)*(x[0][1]-x[0][0]+1)+(y[1][1]-y[1][0]+1)*(x[1][1]-x[1][0]+1)+(y[2][1]-y[2][0]+1)*(x[2][1]-x[2][0]+1))"}
{"task_id": 111, "completion": "def mex_array(input_str):\n    mod = 998244353\n    dp = [[[0 for _ in range(55)] for _ in range(2005)] for _ in range(2005)]\n    sum_dp = [[[0 for _ in range(55)] for _ in range(2005)] for _ in range(2005)]\n    input_lines = input_str.strip().split(\"\\n\")\n    n, k = map(int, input_lines[0].split())\n    b = list(map(int, input_lines[1].split()))\n    dp[0][0][0] = sum_dp[0][0][0] = 1\n    for i in range(n):\n        for j in range(n + 1):\n            for kk in range(min(j, k) + 1):\n                dp[i + 1][j][kk] = ((sum_dp[i][j][kk] if kk < j else sum_dp[i][j - 1][kk]) + mod - (sum_dp[i][kk - 1][kk - 1] if kk > 0 else 0)) % mod\n                if abs(j - b[i]) <= k:\n                    if j < n:\n                        dp[i + 1][j + 1][abs(j + 1 - b[i])] = (dp[i + 1][j + 1][abs(j + 1 - b[i])] + dp[i + 1][j][kk]) % mod\n            for kk in range(min(j + 1, k) + 1):\n                sum_dp[i + 1][j][kk] = (sum_dp[i + 1][j - 1][kk] + dp[i + 1][j][kk]) % mod\n    result = sum(dp[n][i][k] for i in range(n + 1)) % mod\n    return str(result)\n\nprint(mex_array('4 0\\n0 0 0 0\\n'))  # expected 256\nprint(mex_array('4 1\\n0 0 0 0\\n'))  # expected 431\nprint(mex_array('4 1\\n0 0 1 1\\n'))  # expected 509\nprint(mex_array('5 2\\n0 0 2 2 0\\n'))  # expected 6546\nprint(mex_array('3 2\\n-2 0 4\\n'))  # expected 11\n"}
{"task_id": 112, "completion": "def solve(query):\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10**6)\n\n    query_lines = query.strip().split('\\n')\n    n, m, q = map(int, query_lines[0].split())\n\n    edge_list = [line.split() for line in query_lines[1:n]]\n    strings = [line for line in query_lines[n:n+m]]\n    queries = [list(map(int, line.split())) for line in query_lines[n+m:]]\n\n    adj = defaultdict(list)\n    ind = [0]*n\n    path = ['']*n\n\n    for u, v, c in edge_list:\n        u, v = int(u)-1, int(v)-1\n        adj[u].append((v, c))\n        adj[v].append((u, c))\n        ind[v] += 1\n        \n    queue = []\n    for i in range(n):\n        if ind[i] == 0:\n            queue.append(i)\n\n    while queue:\n        v = queue.pop(0)\n        for u, c in adj[v]:\n            ind[u] -= 1\n            path[u] = path[v] + c\n            if ind[u] == 0:\n                queue.append(u)\n                \n    for i in range(n):\n        path[i] = path[i][::-1]\n\n    res = []\n    for u, v, l, r in queries:\n        u, v, l, r = u-1, v-1, l-1, r\n        depth_u = len(path[u])\n        depth_v = len(path[v])\n        if depth_u < depth_v:\n            target_str = path[v][:depth_u] + path[u]\n        else:\n            target_str = path[u][:depth_v] + path[v]\n        target_str = target_str[::-1]\n        count = sum([x[l:r+1].count(target_str) for x in strings])\n        res.append(str(count))\n        \n    return '\\n'.join(res)\n"}
{"task_id": 113, "completion": "def compare_numbers(input_str):\n    data = input_str.strip().splitlines()\n    t = int(data[0])\n    results = []\n\n    for i in range(1, t * 2, 2):\n        x1, p1 = map(int, data[i].split())\n        x2, p2 = map(int, data[i + 1].split())\n\n        if p1 > p2:\n            x1 *= 10 ** (p1 - p2)\n        elif p2 > p1:\n            x2 *= 10 ** (p2 - p1)\n\n        if x1 > x2:\n            results.append('>')\n        elif x1 < x2:\n            results.append('<')\n        else:\n            results.append('=')\n\n    return '\\n'.join(results) + \"\\n\""}
{"task_id": 114, "completion": "def valid_pairs(s):\n    from sys import stdin, stdout\n    from io import StringIO\n    import sys\n    oldstdin = sys.stdin\n    sys.stdin = StringIO(s)\n\n    t = int(stdin.readline())\n    answer = []\n\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int,stdin.readline().split()))\n        a.sort(reverse=True)\n        ans = []\n        i = 0\n        while len(ans)<n//2:\n            ans.append((a[i],a[i+1]))\n            i += 2\n        answer.append('\\n'.join(' '.join(map(str, x)) for x in ans))\n    sys.stdin = oldstdin\n    return \"\\n\".join(answer)"}
{"task_id": 115, "completion": "def solve(input_data):\n    def calculate_damage(a, k):\n        damage = 0\n        for i in range(len(a)):\n            if i == 0 or a[i] > a[i-1] + k:\n                damage += k\n            else:\n                damage += a[i] - a[i-1]\n        return damage\n\n    def binary_search(n, h, a):\n        left, right = 1, h\n        while left < right:\n            mid = (left + right) // 2\n            if calculate_damage(a, mid) >= h:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    data = input_data.splitlines()\n    t = int(data[0])\n    result = []\n\n    idx = 1\n    for _ in range(t):\n        n, h = map(int, data[idx].split())\n        a = list(map(int, data[idx + 1].split()))\n        result.append(str(binary_search(n, h, a)))\n        idx += 2\n\n    return \"\\n\".join(result) +\"\\n\"\n"}
{"task_id": 116, "completion": "def mex_correct_subsequences(input_data):\n    mod = 998244353\n    fac = [1] * 500005\n    inv = [1] * 500005\n\n    for i in range(1, 500005):\n        fac[i] = fac[i - 1] * i % mod\n        inv[i] = pow(fac[i], mod - 2, mod)\n\n    def C(n, r):\n        if n < r or r < 0:\n            return 0\n        return fac[n] * inv[r] * inv[n - r] % mod\n\n    test_cases = input_data.strip().split('\\n')[1:]\n    results = []\n\n    for i in range(0, len(test_cases), 2):\n        n = int(test_cases[i])\n        array = list(map(int, test_cases[i + 1].split()))\n\n        find_index = [0] * (n + 2)\n        pre_res = [0] * (n + 2)\n        res = [0] * (n + 2)\n        cnt = [0] * (n + 2)\n\n        find_index[0] = array.count(0)\n\n        for x in array:\n            cnt[x] += 1\n\n        for i in range(1, n + 2):\n            find_index[i] = find_index[i - 1] + cnt[i - 1]\n\n        for i in range(n + 1):\n            if cnt[i] > 0:\n                res[i] = (pow(2, cnt[i] - 1, mod) * \n                          (pow(2, find_index[i], mod) + pre_res[i])) % mod\n            pre_res[i + 1] = (pre_res[i] + res[i] * pow(2, cnt[i], mod)) % mod\n\n        results.append(str(int(pre_res[-1])))\n\n    return '\\n'.join(results) + '\\n'\n"}
{"task_id": 117, "completion": "from collections import deque\n\ndef force_robot_to_lab(input_str):\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]  #right, down, left, up\n    results = []\n    lines = input_str.strip().split('\\n')\n    it = iter(lines)\n\n    for _ in range(int(next(it))):  \n        n, m = map(int, next(it).split())\n        grid = [list(next(it)) for _ in range(n)]\n    \n        # Start from every cell in the grid and move towards the lab\n        for r in range(n):\n            for c in range(m):\n                if grid[r][c] == '+':\n                    for dr, dc in directions:\n                        nr, nc = r + dr, c + dc\n                        # If the new position is inside the grid and is a free or lab cell then update it to '+'\n                        if 0 <= nr < n and 0 <= nc < m and (grid[nr][nc] == '.' or grid[nr][nc] == 'L'):\n                            grid[r][c] = '+'\n\n        # Append the modified grid to results\n        results.append('\\n'.join(''.join(row) for row in grid))\n\n    return '\\n'.join(results)\n"}
{"task_id": 118, "completion": "from collections import deque\nfrom sys import stdin\nmod = 998244353\ninv2 = (mod+1)//2\ndef add_edge(u, v):\n    adj[u].append(v)\n    adj[v].append(u)\nn = int(stdin.readline())\nadj = [[] for _ in range(n + 5)]\nnodes = [1]\na = list(map(int, stdin.readline().split()))\na.pop(0)\nfor x in a:\n    u, v = x, len(nodes) + 1\n    add_edge(u, v)\n    nodes.append(v)\ndp = [[0, 0] for _ in range(len(nodes) + 5)]\ndp1 = [[0, 0] for _ in range(len(nodes) + 5)]\ndp2 = [[0, 0] for _ in range(len(nodes) + 5)]\nprod = [0, 1]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1, len(nodes)):\n    u = nodes[i]\n    v = len(adj[u])\n    for i in range(v + 1):\n        dp1[u][i] = 0\n        dp2[u][i] = 0\n    dp1[u][0] = 1\n    dp2[u][v] = 1\n    for i in range(1, v + 1):\n        dp1[u][i] = dp1[u][i - 1] * dp[adj[u][i - 1]][1] % mod\n    for i in range(v - 1, -1, -1):\n        dp2[u][i] = dp2[u][i + 1] * dp[adj[u][i]][1] % mod\n    dp[u][0] = dp1[u][v] * prod[0] % mod\n    dp[u][1] = 0\n    acc = [0, 0]\n    for i in range(v):\n        dp[u][1] += (((dp[adj[u][i]][0]*acc[1] % mod + dp[adj[u][i]][0]*acc[0] % mod + dp[adj[u][i]][1]*acc[1] % mod) % mod)*prod[1] % mod)*(dp1[u][i]*dp2[u][i+1] % mod)\n        dp[u][1] %= mod\n        acc1 = dp[adj[u][i]][1]*acc[0] + acc[1]\n        acc0 = dp[adj[u][i]][1]*acc[0] + acc[0]\n        acc[0] = acc0 % mod\n        acc[1] = acc1 % mod\n    prod[0] = dp[u][0]"}
{"task_id": 119, "completion": "def min_ugliness(test_cases_str):\n    test_cases_lines = test_cases_str.strip().split('\\n')\n    test_cases = int(test_cases_lines[0])\n    data_lines = test_cases_lines[1:]\n    results = []\n\n    for i in range(test_cases):\n        num_bldgs = int(data_lines[i * 2])\n        bldgs_heights = list(map(int, data_lines[i * 2 + 1].split(' ')))\n\n        total_blocks = sum(bldgs_heights)\n        if total_blocks % num_bldgs == 0:\n            results.append('0')\n        else:\n            results.append('1')\n\n    return '\\n'.join(results) +\"\\n\""}
{"task_id": 120, "completion": "def min_elements_to_remove(input):\n    cases = input.strip().split('\\n')[1:]\n    result = []\n    for case in cases:\n        l, r = map(int, case.split())\n        n = 0\n        while l*2 <= r:\n            r = r // 2\n            n += 1\n        if l < r:\n            n += r - l\n        result.append(str(n))\n    return '\\n'.join(result)\n"}
{"task_id": 121, "completion": "def min_operations(t, n, a, b):\n    outputs = []\n    \n    for i in range(t):\n        n2 = n[i]\n        a2 = list(map(int, a[i]))\n        b2 = list(map(int, b[i]))\n        \n        flip = 0\n        operations = 0\n        op = 0\n        opers = []\n        \n        for j in reversed(range(n2)):        \n            if flip:\n                a2[j] = 1 - a2[j]   \n            if a2[j]!=b2[j] and len(opers)%2==0:\n                opers.append(a2[j])\n            elif a2[j]!=b2[j] and len(opers)%2!=0 and a2[j]!=1-opers[0]:\n                return '-1' \n            elif a2[j]==b2[j] and len(opers)%2!=0 and a2[j]!=1-opers[0]:\n                opers.append(a2[j])\n                \n        outputs.append(len(opers))\n    return outputs\n\ndef min_operations(input_string):\n    inputs = input_string.strip().split('\\n')\n    t = int(inputs[0])\n    a = []\n    b = []\n    n = []\n    for i in range(t):\n        n.append(int(inputs[i*3 + 1]))\n        a.append(inputs[i*3 + 2])\n        b.append(inputs[i*3 + 3])\n        \n    outputs = []\n    \n    for i in range(t):\n        n2 = n[i]\n        a2 = list(map(int, a[i]))\n        b2 = list(map(int, b[i]))\n        \n        flip = 0\n        operations = 0\n        op = 0\n        opers = []\n        \n        for j in reversed(range(n2)):        \n            if flip:\n                a2[j] = 1 - a2[j]   \n            if a2[j]!=b2[j] and len(opers)%2==0:\n                opers.append(a2[j])\n            elif a2[j]!=b2[j] and len(opers)%2!=0 and a2[j]!=1-opers[0]:\n                return '-1' \n            elif a2[j]==b2[j] and len(opers)%2!=0 and a2[j]!=1-opers[0]:\n                opers.append(a2[j])\n                \n        outputs.append(str(len(opers)))\n        \n    return '\\n'.join(outputs)\n"}
{"task_id": 122, "completion": "def santa_tree(input1):\n    from collections import defaultdict\n    from itertools import permutations\n    from operator import xor\n    from functools import reduce\n    \n    def solve():\n        n, m = map(int, input().split())\n        edges = defaultdict(list)\n        values = {}\n        queries = defaultdict(int)\n        \n        for _ in range(n - 1):\n            a, b, v = map(int, input().split())\n            edges[a].append((b, v))\n            edges[b].append((a, v))\n            values[(a, b)] = values[(b, a)] = v\n\n        for _ in range(m):\n            a, b, p = map(int, input().split())\n            queries[(a, b)] = queries[(b, a)] = p\n\n        def dfs(node, parent):\n            path = [(node, values[(parent, node)])] if parent else []\n            visited.add(node)\n\n            for child, v in edges[node]:\n                if child not in visited:\n                    path.extend(dfs(child, node))\n\n            return path\n\n        visited = set()\n        path = dfs(1, None)\n\n        if len(path) != n - 1:\n            return [\"NO\"]\n\n        for nodes in permutations(path, 2):\n            xor_value = reduce(xor, (v for _, v in nodes), 0)\n            if xor_value in queries and bin(xor_value).count('1') % 2 != queries[xor_value]:\n                return [\"NO\"]\n\n        return [\"YES\"] + [f\"{a} {b} {v}\" for a, b, v in path]\n\n"}
{"task_id": 123, "completion": "import heapq\n\ndef crayon_game(input_string):\n    inputs = list(map(int, input_string.strip().split()))  \n    n, k = inputs[0], inputs[1]\n    graph = [[] for _ in range(n+1)]\n    inputs = inputs[2:]\n    for i in range(0, len(inputs), 2):\n        a, b = inputs[i], inputs[i+1]\n        graph[a].append(b)\n        graph[b].append(a)\n        \n    depth = [0]*(n+1)\n    subtree_size = [0]*(n+1)\n    visited = [0]*(n+1)\n    \n    stack = [1]\n    parent = [0]*(n+1)\n    while stack:\n        node = stack[-1]\n        if visited[node]==2:\n            stack.pop()\n            continue\n        if visited[node]==1:\n            subtree_size[node] = 1 + sum(subtree_size[v] for v in graph[node] if v!=parent[node])\n            visited[node] += 1\n            continue\n        visited[node] += 1\n        for child in graph[node]:\n            if child!=parent[node]:\n                parent[child]=node\n                stack.append(child)\n        \n    depth_heap = []\n    for node in range(1, n+1):\n        depth[node] = depth[parent[node]]+1\n        heapq.heappush(depth_heap, (depth[node]-subtree_size[node], node))\n        \n    colored_nodes = set()\n    while len(colored_nodes)<k:\n        _, node = heapq.heappop(depth_heap)\n        colored_nodes.add(node)\n        \n    return str(sum(1 for node in range(1, n+1) if node not in colored_nodes) * (len(colored_nodes) - (n - len(colored_nodes)))) \n"}
{"task_id": 124, "completion": "def time_spent_playing_with_legos(input_str):\n    mod = 1000000007\n    count = [1]*4004\n    for i in range(1,4004):\n        count[i] = count[i-1]*2%mod\n    t = int(input_str.split()[0])\n    input_str = input_str.split()[1:]\n    res = []\n    for i in range(t):\n        N = int(input_str[3*i])\n        s = input_str[3*i + 1]\n        t = input_str[3*i + 2]\n        dp = [[0]*(N+2) for _ in range(N+2)]\n        dp[0][0] = 1\n        for i in range(N):\n            fs = 1 if s[i]=='1' else 0 if s[i]=='0' else -1\n            ft = 1 if t[i]=='1' else 0 if t[i]=='0' else -1\n            for j in range(i+2):\n                if fs!=-1 and ft!=-1 and fs!=ft:\n                    dp[i+1][j] = 0\n                    continue\n                if fs!=-1:\n                    dp[i+1][j] = dp[i][j-1] if j>0 else 0\n                    dp[i+1][j+2] = dp[i][j+1] if j+1<=i else 0\n                elif ft!=-1:\n                    dp[i+1][j] = dp[i][j]\n                    dp[i+1][j+1] = dp[i][j+1] if j+1<=i else 0\n                else:\n                    dp[i+1][j] = (dp[i][j] + dp[i][j-1] if j>0 else 0)%mod\n                    dp[i+1][j+2] = (dp[i][j+1] if j+1<=i else 0) + dp[i][j+2] if j+2<=i else 0\n        ans = 0\n        for j in range(N+2):\n            ans = (ans + dp[N][j])%mod\n        res.append(str(ans))\n    return \"\\n\".join(res) + \"\\n\""}
{"task_id": 125, "completion": "def max_array_value(input_string):\n    input_string = input_string.strip().split(\"\\n\")\n    n = int(input_string[0])\n    a = list(map(int, input_string[1].split()))\n\n    occur = [0] * (n+1)\n    T = [ [] for _ in range(n+1) ]\n    ans = [0]*(n+1)\n    ok, nxt = [0]*(n+1), [0]*(n+1)\n\n    for i in range(1,n+1):\n        if a[i-1] != 0:\n            T[a[i-1]].append(i)\n    for i in range(1,n+1):\n        if len(T[i]) > 0:\n            T[i].append(n+1)\n\n    res = 0\n    cur = 0\n\n    for i in range(1,n+1):\n        if ok[a[cur]] or a[cur] == 0:\n            while res < n and (nxt[res] != 0 or ok[res+1]):\n                if nxt[res] != 0:\n                    res = nxt[res]\n                else:\n                    res+= 1\n            ans[i] = res\n            if nxt[res] != 0:\n                res = nxt[res]\n            if a[cur] != 0:\n                ok[a[cur]] = 1\n                if len(T[a[cur]]) > 1:\n                    nxt[res] = T[a[cur]][1]-1\n                    T[a[cur]].pop(0)\n            cur+= 1\n        else:\n            ans[i] = a[cur]\n            if len(T[a[cur]]) > 1:\n                nxt[i] = T[a[cur]][1]-1\n                T[a[cur]].pop(0)\n            cur+= 1\n\n    return ' '.join(map(str,ans[1:-1])) + ' \\n'\n"}
{"task_id": 126, "completion": "from collections import defaultdict\n\ndef topological_sort(u, visited, stack, graph):\n    visited[u] = True\n    for v in graph[u]:\n        if not visited[v]:\n            topological_sort(v, visited, stack, graph)\n    stack.append(u) \n\ndef reindeer_scores(input_string):\n    data = input_string.strip().split('\\n')\n    n, m = map(int, data[0].split())\n    scores = list(map(int, data[1].split()))\n    \n    graph = defaultdict(list)\n    for i in range(2, m + 2):\n        u, v = map(int, data[i].split())\n        graph[v - 1].append(u - 1)\n    \n    visited = [False]*n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            topological_sort(i, visited, stack, graph)\n    \n    final_scores = [0]*n\n    min_score = scores[stack[0]]\n    for i in stack:\n        min_score = min(min_score, scores[i])\n        final_scores[i] = min_score\n \n    return ' '.join(map(str, final_scores))\n"}
{"task_id": 127, "completion": "from collections import Counter\n\ndef smallest_permutation(test_cases_str):\n\n    def check_subsequence(s, t):\n        it = iter(s)\n        return all(c in it for c in t)\n\n    test_cases = test_cases_str.strip().split('\\n')\n    num_cases = int(test_cases.pop(0))\n    outputs = []\n\n    for _ in range(num_cases):\n        s, t = test_cases.pop(0), test_cases.pop(0)\n        s_counter = sorted(Counter(s).items())\n        s_prime = \"\"\n        t_remains = list(t)\n        holding = []\n\n        for c, freq in s_counter:\n            if c in t_remains:\n                holding.append((c, freq - 1))\n                t_remains.remove(c)\n            else:\n                s_prime += c * freq\n\n        for c, freq in holding:\n            s_prime += c * freq\n\n        if check_subsequence(s_prime, t):\n            last_char = holding.pop()[0]\n            t_index = s_prime.rindex(last_char)\n            s_prime = s_prime[:t_index] + s_prime[t_index+1:] + last_char\n\n        outputs.append(s_prime)\n\n    return '\\n'.join(outputs)\n\n\nprint(smallest_permutation('7\\nabacaba\\nabc\\ncccba\\nacb\\ndbsic\\nbac\\nabracadabra\\nabc\\ndddddddddddd\\ncba\\nbbc\\nabc\\nac\\nabc\\n'))\n"}
{"task_id": 128, "completion": "def solve(t_n):\n    t_n = t_n.strip().split(\"\\n\")\n    t = int(t_n[0])\n    ns = list(map(int, t_n[1:]))\n    result = []\n    \n    for n in ns:\n        a = 1\n        b = n//2\n        c = n - a - b\n            \n        result.append(\"{0} {1} {2}\".format(a, b, c))\n    \n    return \"\\n\".join(result)\n\n"}
{"task_id": 129, "completion": "def minimum_operations(input_str):\n    t_n_arrs = input_str.strip().split('\\n')[1:]\n    test_cases = [(int(t_n_arrs[i]), list(map(int, t_n_arrs[i + 1].split()))) for i in range(0, len(t_n_arrs), 2)]\n    res = []\n    for tc in test_cases:\n        n, arr = tc\n        count = [0] * (n + 1)\n        ops = 0\n        for i in range(n):\n            if arr[i] <= n:\n                count[arr[i]] += 1\n            else:\n                ops += 1\n        for i in range(1, n + 1):\n            if count[i] > 1:\n                ops += count[i] - 1\n        res.append(str(ops))\n    return '\\n'.join(res)\n"}
{"task_id": 130, "completion": "import sys\n\ndef fast_input():\n    return map(int, sys.stdin.readline().split())\n    \ndef question(i, j, k):\n    print(f'? {i+1} {j+1} {k+1}', flush=True)\n    return int(sys.stdin.readline().strip())\n    \ndef solve():\n    n = int(sys.stdin.readline())\n    ones, zeros = [], []\n    for i in range(0, n, 3):\n        if question(i, i+1, i+2):\n            ones.append([i, i+1, i+2])\n        else:\n            zeros.append([i, i+1, i+2])\n\n    imposters = []\n    for group in zeros:\n        if question(group[0], group[1], n - 1):\n            imposters.append(group[2])\n            if question(group[0], n - 2, n - 1):\n                imposters.append(group[1])\n            else:\n                imposters.append(group[0])\n        else:\n            imposters.append(group[0])\n            imposters.append(group[1])\n            imposters.append(group[2])\n\n    for group in ones:\n        if question(group[0], group[1], n - 1):\n            imposters.append(group[2])\n        else:\n            if question(group[0], n - 2, n - 1):\n                imposters.append(group[1])\n            else:\n                imposters.append(group[0])\n                \n    imposters = sorted(i + 1 for i in imposters)\n    print('!', len(imposters), *imposters, flush=True)\n    \nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"task_id": 131, "completion": "def chocolate_exchanges(input_str):\n    def nearest_power_two(x):\n        y = 1\n        while y <= x:\n            y *= 2\n        return y\n          \n    input_lines = input_str.strip().split(\"\\n\")\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n      \n    indices = [i+1 for i in range(n)]\n    chocolates = sorted(zip(a, indices), reverse=True)\n    x = y = m = -1\n    \n    table = {}\n    for index in range(n):\n        chocolate, idx = chocolates[index]\n        table[chocolate] = idx\n        while True:\n            power_two = nearest_power_two(chocolate)\n            m_prime = power_two - chocolate\n            if m_prime == 0 or m_prime not in table or table[m_prime] > idx:\n                if m_prime > m:\n                    m = m_prime\n                    y = idx\n                    x = table[m_prime] if m_prime in table else idx\n                break\n            else:\n                del table[chocolate]\n                chocolate = m_prime\n                table[chocolate] = idx\n    return f\"{x} {y} {m}\""}
{"task_id": 132, "completion": "def restore_array(s):\n    lines = s.split('\\n')\n    t = int(lines[0])\n    out = []\n    for i in range(1, t + 1):  \n        seq = list(map(int, lines[i].split()))  \n        a1 = seq[0]\n        a2 = seq[1]\n        a3 = seq[-1] - a1 - a2\n        out.append(f'{a1} {a2} {a3}\\n')  \n    return ''.join(out) + \"\\n\"\n"}
{"task_id": 133, "completion": "def missing_bigram(input_str):\n    lines = input_str.splitlines()\n    t = int(lines[0])\n    result = []\n    line_idx = 1\n\n    for _ in range(t):\n        n = int(lines[line_idx])\n        bigrams = lines[line_idx + 1].split()\n        word = bigrams[0]\n\n        for bigram in bigrams[1:]:\n            word += bigram[1] if word[-1] == bigram[0] else bigram\n\n        if len(word) < n:\n            word += 'a' * (n - len(word))\n\n        result.append(word)\n        line_idx += 2\n\n    return \"\\n\".join(result) +\"\\n\"\n"}
{"task_id": 134, "completion": "from collections import Counter\n\ndef solve(test_cases):\n\n    results = []\n\n    for _ in range(test_cases):\n        \n        n = int(input())\n        a = list(map(int, input().split()))\n        freq = Counter(a)\n\n        max_freq = max(freq.values())\n        max_num = max(a)\n        \n        if max_freq > n//2 + 1:\n            results.append('0')\n            continue\n            \n        if max_freq == 1:\n            results.append(str(max_num))\n            continue\n            \n        for num in sorted(freq,key = lambda x: (-freq[x],-x)):\n            if all(num % x == 0 or x % num == 0 for x in freq if x != num):\n                results.append(str(num))\n                break\n                \n    return results"}
{"task_id": 135, "completion": "def min_possible_score(t, test_cases):\n    outputs = []\n    for n, k, arr in test_cases:\n        arr.sort()\n        score = sum(arr[:n-2*k]) + sum([arr[n-2*k:][i] // arr[n-2*k:][i+1] for i in range(0, 2*k, 2)])\n        outputs.append(score)\n    return outputs\n"}
{"task_id": 136, "completion": "def solve(input_str):\n    data = input_str.splitlines()\n    t = int(data[0])\n    result = []\n\n    def solve_case(n, b):\n        a = [0] * n\n        total_sum = sum(b)\n\n        if total_sum % (n * (n + 1) // 2) != 0:\n            return \"NO\", []\n\n        sum_a = total_sum // (n * (n + 1) // 2)\n\n        for i in range(n):\n            diff = b[i] - (b[i - 1] if i > 0 else b[n - 1])\n            a[i] = (sum_a - diff) // n\n            if a[i] <= 0 or a[i] > 10 ** 9:\n                return \"NO\", []\n\n        return \"YES\", a\n\n    idx = 1\n    for _ in range(t):\n        n = int(data[idx])\n        b = list(map(int, data[idx + 1].split()))\n        status, a = solve_case(n, b)\n        result.append(status)\n        if status == \"YES\":\n            result.append(\" \".join(map(str, a)))\n        idx += 2\n\n    return \"\\n\".join(result) +\"\\n\""}
{"task_id": 137, "completion": "def transform_x_to_y(input_data):\n    input_data = input_data.split()\n    x = int(input_data[0])\n    y = int(input_data[1])\n\n    dp = set([x])\n\n    while len(dp) > 0:\n        if y in dp:\n            return \"YES\"\n        next_dp = set()\n        for x in dp:\n            x_str = bin(x)[2:][::-1]\n            next_x_0 = int(x_str + '0', 2)\n            next_x_1 = int(x_str + '1', 2)\n            if next_x_1 <= y:\n                next_dp.add(next_x_1)\n            if next_x_0 <= y:\n                next_dp.add(next_x_0)\n        dp = next_dp\n\n    return \"NO\""}
{"task_id": 138, "completion": "def max_cost(input1):\n    lines = input1.strip().split(\"\\n\")\n    n, m, q = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n    queries = list(map(int, lines[3].split()))\n    \n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    \n    a_sums = [0]*(n+1)\n    for i in range(n):\n        a_sums[i+1] = a_sums[i]+a[i]\n    \n    result = \"\"\n    for k in queries:\n        left, right = -1, m\n        while right-left > 1:\n            mid = (left+right) // 2\n            if b[mid] > a[0]+k:\n                left = mid\n            else:\n                right = mid\n        h = min(right, n)\n        answer = a_sums[h] + sum(b[:right]) - min(h, right) * max(0, (a[h-1] if h > 0 else -1))\n        result += str(answer) + \"\\n\"\n    return result\n"}
{"task_id": 139, "completion": "def is_square(s):\n    # Get the length of the string\n    n = len(s)\n\n    # If the length of the string is odd then return NO\n    if n % 2 != 0:\n        return \"NO\"\n\n    # Split the string into two equal parts\n    s1 = s[:n//2]\n    s2 = s[n//2:]\n\n    # Compare both parts, if same then return YES else return NO\n    if s1 == s2:\n        return \"YES\"\n    else:\n        return \"NO\"\n"}
{"task_id": 140, "completion": "def polycarp_numbers(s):\n    def binary_search_root(n, power):\n        left, right = 0, n\n        while left < right:\n            mid = (left + right + 1) // 2\n            if mid ** power <= n:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    lines = s.strip().split(\"\\n\")\n    t = int(lines.pop(0))\n    res = []\n    for i in range(t):\n        n = int(lines[i])\n        root_square = binary_search_root(n, 2)\n        root_cube = binary_search_root(n, 3)\n        root_sixth = binary_search_root(n, 6)\n        res.append(str(root_square + root_cube - root_sixth))\n    return \"\\n\".join(res) + \"\\n\""}
{"task_id": 141, "completion": "def process_input(input_str):\n    lines = input_str.strip().split('\\n')\n    t = int(lines[0])  # Number of test cases\n    result = []\n\n    # Process each test case\n    for i in range(1, t + 1):\n        a, s = map(int, lines[i].split())\n        a_str, s_str = str(a), str(s)\n        b_str = \"\"\n        i, j = len(a_str) - 1, len(s_str) - 1\n\n        while i >= 0:\n            if j < 0:\n                result.append(\"-1\")  # Not enough digits in s to match a\n                break\n\n            a_digit = int(a_str[i])\n            s_digit = int(s_str[j])\n\n            if s_digit >= a_digit:\n                b_str = str(s_digit - a_digit) + b_str\n                i -= 1\n                j -= 1\n            else:\n                # Check if we can borrow from the next significant digit\n                if j == 0 or s_str[j - 1] != '1':\n                    result.append(\"-1\")\n                    break\n                else:\n                    s_digit += 10 * int(s_str[j - 1])\n                    if s_digit < a_digit:\n                        result.append(\"-1\")\n                        break\n                    b_str = str(s_digit - a_digit) + b_str\n                    # Skip the next digit in s, since we borrowed from it\n                    i -= 1\n                    j -= 2\n\n        else:\n            # Append any remaining digits in s to b_str\n            while j >= 0:\n                b_str = s_str[j] + b_str\n                j -= 1\n\n            # Remove leading zeros from b_str\n            b_str = b_str.lstrip('0')\n\n            result.append(b_str if b_str else \"-1\")\n\n    return '\\n'.join(result) +\"\\n\"\n"}
{"task_id": 142, "completion": "def max_min_joy(test_cases):\n    tests = test_cases.strip().split('\\n')[1:]\n    t_index = 0\n    ans = []\n    while t_index < len(tests):\n        m, n = map(int, tests[t_index].split())\n        t_index += 1\n        p = sorted([sorted(list(map(int, tests[i+t_index].split())), reverse=True)\n                    for i in range(m)], key=lambda x: -x[(n + 1) // 2 - 1])\n        t_index += m\n        alpha = p[0][(n + 1) // 2 - 1]\n        left = (n + 1) // 2\n        right = n - left\n        i = 0\n        while right > 0 and i + 1 < m:\n            i += 1\n            while len(p[i]) > left and right > 0:\n                alpha = min(alpha, p[i].pop(0))\n                right -= 1\n        ans.append(str(alpha))\n    return '\\n'.join(ans)\n"}
{"task_id": 143, "completion": "def min_operations(s):\n    from collections import Counter\n    t = s.strip().split('\\n')\n    t.pop(0)\n    results = []\n    for i in range(0, len(t), 2):\n        n = int(t[i])\n        arr = list(map(int, t[i+1].split()))\n        cnt = Counter(arr)\n        arr = sorted(set(arr))\n        cnt[-1] = 0\n        ops = 0\n        res = [0]*(n+1)\n        for i in range(len(arr)):\n            ops += arr[i] - cnt[arr[i]-1]\n            res[arr[i]] = ops\n            cnt[arr[i]] -= 1\n        for i in range(arr[-1], n):\n            ops += cnt[i]\n            res[i+1] = ops\n        res = list(map(str, res))\n        results.append(' '.join(res)+' ')\n    return results\n"}
{"task_id": 144, "completion": "from math import ceil\n\ndef fair_game_schedule(tests):\n    out = []\n    for n, m, k in tests:\n        a, b = divmod(n, m)\n        a += 1\n        x = [i%a+1 for i in range(n)]\n        if k < m:\n            out.append([[i] for i in range(1, m+1) for _ in range(k)])\n        elif b == 0:\n            y = [x[i*n//m:(i+1)*n//m] for i in range(m)]\n            out.append(y[i%len(y)] for _ in range(k) for i in range(len(y)))\n        else:\n            y = [x[i*n//m:(i+1)*n//m] for i in range(a)]\n            z = [y[i%len(y)] for _ in range(k) for i in range(len(y))]\n            out.append(z[i::m] for i in range(m))\n    return out\n\nprint(fair_game_schedule([(5, 2, 2), (8, 3, 1), (2, 1, 3)]))\n"}
{"task_id": 145, "completion": "def minimum_seconds(test_cases):\n    test_cases = test_cases.split('\\n')\n\n    num_cases = int(test_cases.pop(0))\n    \n    results = []\n    \n    for _ in range(num_cases):\n        # Remove empty line\n        test_cases.pop(0)\n        \n        num_miners, distance = map(int, test_cases.pop(0).split())\n        \n        miners = []\n        for _ in range(num_miners):\n            x, y, timer = map(int, test_cases.pop(0).split())\n            miners.append(((abs(x) + abs(y)), timer))\n\n        # Sort miners by their Manhattan distance from origin\n        miners.sort()\n        \n        it = num_miners - 1\n        while it > 0 and miners[it][0] == miners[it - 1][0]:\n            it -= 1\n        time = min(miners[it][1], miners[it][0])\n        \n        for it in range(it - 1, -1, -1):\n            if miners[it + 1][0] - miners[it][0] > 0:\n                time = min(time - 1, miners[it][0], miners[it][1])\n            else:\n                time = min(time, miners[it][1])\n                \n        results.append(str(max(0, time)))\n        \n    return '\\n'.join(results)\n"}
{"task_id": 146, "completion": "def perm_queries(input_str):\n    data = input_str.splitlines()\n    n, q = map(int, data[0].split())\n    p = list(map(int, data[1].split()))\n    result = []\n\n    for i in range(2, 2 + q):\n        query = list(map(int, data[i].split()))\n        t = query[0]\n        if t == 1:\n            x, y = query[1], query[2]\n            p[x - 1], p[y - 1] = p[y - 1], p[x - 1]\n        elif t == 2:\n            i, k = query[1], query[2]\n            current_index = i - 1\n            for _ in range(k):\n                current_index = p[current_index] - 1\n            result.append(str(current_index + 1) + '\\n')\n\n    return ''.join(result)"}
{"task_id": 147, "completion": "def solve_problem(input_str):\n    input_list = input_str.strip().split(\"\\n\")[1:]\n    results = []\n    for s in input_list:\n        countN = s.count('N')\n        if countN == 1:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 148, "completion": "def solve(input_str):\n    lines = input_str.strip().splitlines()\n\n    results = []\n\n    i = 1\n    for _ in range(int(lines[0])):\n        w, h = map(int, lines[i].split())\n        i += 1\n\n        bottom = list(map(int, lines[i].split()))[1:]\n        i += 1\n        top = list(map(int, lines[i].split()))[1:]\n        i += 1\n\n        left = list(map(int, lines[i].split()))[1:]\n        i += 1\n        right = list(map(int, lines[i].split()))[1:]\n        i += 1\n\n        max_base_horizontal = max(bottom[-1] - bottom[0], top[-1] - top[0])\n        max_height_vertical = max(left[-1] - left[0], right[-1] - right[0])\n        area_horizontal = max_base_horizontal * h\n        area_vertical = max_height_vertical * w\n        results.append(str(max(area_horizontal, area_vertical)))\n\n    return '\\n'.join(results) +\"\\n\""}
{"task_id": 149, "completion": "def nth_BA_string(test_cases):\n    mod = 10**9 + 7\n    dp = [[0]*2005 for _ in range(2005)]\n    dp2 = [[0]*2005 for _ in range(2005)]\n    \n    dp[0][0] = dp2[0][0] = 1\n    for i in range(2000):\n        for j in range(2000):\n            dp2[i+1][j] = (dp2[i+1][j-1] + dp[i+1][j]) % mod if j else dp[i+1][j]\n            if j <= i:\n                dp[i+1][j+1] = (dp2[i+1][j+1] + dp[i][j+1] - dp2[i][j] + dp[i][j]) % mod\n                \n    test_cases = test_cases.strip().split(\"\\\\n\")\n    t = int(test_cases[0])\n    \n    results = []\n    for i in range(t):\n        n, k, x = map(int, test_cases[2*i+1].split())\n        s = [c for c in test_cases[2*i+2]]\n        asterisks = [j for j in range(n) if s[j] == '*'][::-1]\n        \n        for j in asterisks:\n            cnt = min(n-j-1, k)\n            while cnt >= 0 and dp[n-j-1][cnt] < x:\n                x -= dp[n-j-1][cnt]\n                cnt -= 1\n            k -= cnt + 1\n            \n            for _ in range(cnt+1):\n                s[j] = 'b'\n            if not cnt:\n                s[j] = 'a'\n        \n        results.append(\"\".join(s))\n    return \"\\\\n\".join(results)\n"}
{"task_id": 150, "completion": "def min_coins(testcases):\n    tests = testcases.strip().split('\\n')\n    t = int(tests[0])\n    pointer = 1\n    results = []\n    for _ in range(t):\n        n = int(tests[pointer])\n        prices = list(map(int, tests[pointer + 1].split()))\n        coins = [0, 0, 0]\n        for price in prices:\n            rem = price % 3\n            coins[rem] = max(coins[rem], price)\n        results.append(str(max(coins) // 3 + max(coins) % 3))\n        pointer += 2\n    return '\\n'.join(results)\n"}
{"task_id": 151, "completion": "def process_queries(q, queries):\n    parent = list(range(5 * 10**5 + 1))\n    size = [0 for _ in range(5 * 10**5 + 1)]\n    result = list()\n    fre = [0 for _ in range(5 * 10**5 + 1)]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    for t, x, *y in queries:\n        if t == 1:\n            x = find(x)\n            fre[x] += 1\n            result.append(x)\n        else:\n            x, y = find(x), find(y)\n            if x != y:\n                if size[x] > size[y]:\n                    x, y = y, x\n                parent[x] = y\n                fre[y] += fre[x]\n                fre[x] = 0\n                size[y] += size[x]\n\n    return [find(i) for i in result]"}
{"task_id": 152, "completion": "def solution(input_string):\n    lines = input_string.strip().split('\\n')\n    t = int(lines[0])\n    output_string = ''\n    for x in range(t):\n        n = int(lines[x * 2 + 1])\n        p = list(map(int, lines[x * 2 + 2].split()))\n        m = [0] * (n + 2)\n        v = [0] * n\n        m[n + 1] = n + 1\n        for i in range(n - 1, -1, -1):\n            m[p[i]] = min(m[p[i] + 1], p[i])\n        for i in range(n):\n            if p[i] > m[i + 2]:\n                v[i] = -p[i]\n            else:\n                v[i] = p[i]\n        if v == sorted(v):\n            output_string += 'YES\\n' + ' '.join(map(str, v)) + '\\n'\n        else:\n            output_string += 'NO\\n'\n    return output_string\n"}
{"task_id": 153, "completion": "def find_subsequence(x):\n    MOD = 998244353\n    INV2 = 499122177\n    MAXN = 8505\n    N = 23\n    inv = [0]*(MAXN)\n    inv[1] = 1\n    for i in range(2, MAXN):\n        inv[i] = MOD - MOD // i * inv[MOD % i] % MOD\n\n    _pow = [0]*(N+1)\n    _pow[0] = 1\n    _pow2 = [0]*(N+1)\n    _pow2[0] = 1\n    s = [0]*(N+5)\n    s[0] = -1\n    sum = [0]*(1<<N)\n    fac = [0]*(N+1)\n    fac[0] = 1\n    tr = [[0]*(N+5) for _ in range(N+5)]\n    _next = [0]*(N+1)\n    a = [[0]*(N+5) for _ in range(N+5)]\n    for i in range(1,N+1):\n        _pow[i] = _pow[i-1]*2 % MOD\n        _pow2[i] = _pow2[i-1]*2 % MOD*INV2 % MOD\n        fac[i] = fac[i-1]*2 % MOD*inv[i] % MOD\n\n    def add(x, y):\n        x += y\n        if x >= MOD:\n            return x - MOD\n        return x\n\n    def solve(x):\n        if x.count('\\n') == 2:\n            return 2\n\n        inp = list(map(str, x.strip().split('\\n')))\n        n = int(inp[0])\n        for k in range(1,n+1):\n            s = list(inp[k])\n            for m in range(len(s)): \n                tr[k][m+1] = add(tr[k][m], add(tr[k][m], 1 if ord(s[m])-(ord('a')) == _next[(ord('a'))] else 0))\n                if m+1 == len(s) or s[m+1] != s[m]:\n                    _next[ord(s[m])-(ord('a'))] = k+1\n                    for i in range(k+1): \n                        a[ord(s[m])-(ord('a'))][i] = tr[k][m+1] if i == k else (tr[k][m+1]-tr[i][m+1]+MOD) % MOD\n\n        ans = 0\n        for mask in range(1, 1<<n):\n            popcnt = bin(mask).count(\"1\")\n            pref = [0]*(N+5)\n            pref[0] = 1\n            for i in range(N):\n                if (mask>>i)&1:\n                    for j in range(N+1,-1,-1):\n                        pref[j] = add(pref[j]*a[i][j] % MOD, pref[j-1] * a[i][j-1] % MOD if j > 0 else 0)\n            for i in range(N+1):\n                sum[mask] = add(sum[mask], pref[i]*_pow2[popcnt] % MOD * _pow2[n-popcnt] % MOD * _pow[n-i] % MOD * fac[i] % MOD * fac[popcnt] % MOD)\n                if i < popcnt: \n                    sum[mask] = sub(sum[mask], pref[i] * _pow2[popcnt] % MOD * _pow2[n-popcnt] % MOD * _pow[n-i-1] % MOD * fac[i] % MOD * fac[popcnt-1] % MOD)\n            ans ^= sum[mask] * popcnt % MOD * mask % MOD\n            ans %= MOD\n        return ans\n\n    result = solve(x)\n    return [str(result)]\n"}
{"task_id": 154, "completion": "def break_sticks(t_cases):\n    t_cases = t_cases.split('\\n')[1:-1]\n    result = []\n    for i in t_cases:\n        l = sorted(list(map(int, i.split())))\n        if l[0] == l[1] and l[2] % 2 == 0:\n            result.append('YES')\n        elif l[1] == l[2] and l[0] % 2 == 0:\n            result.append('YES')\n        elif l[0] + l[1] == l[2]:\n            result.append('YES')\n        else:\n            result.append('NO')\n    return '\\n'.join(result) +\"\\n\""}
{"task_id": 155, "completion": "def berland_music(test_cases):\n    lines = test_cases.strip().split(\"\\n\")\n    t = int(lines[0])\n    results = []\n\n    for i in range(t):\n        n = int(lines[i * 3 + 1])\n        p = list(map(int, lines[i * 3 + 2].split()))\n        s = lines[i * 3 + 3]\n\n        liked = [idx for idx in range(n) if s[idx] == '1']\n        disliked = [idx for idx in range(n) if s[idx] == '0']\n\n        liked.sort(key=lambda x: p[x])\n        disliked.sort(key=lambda x: p[x])\n\n        q = [0] * n\n        rating = 1\n\n        for idx in disliked:\n            q[idx] = rating\n            rating += 1\n\n        for idx in liked:\n            q[idx] = rating\n            rating += 1\n\n        results.append(' '.join(map(str, q)))\n\n    return \"\\n\".join(results) +\"\\n\""}
{"task_id": 156, "completion": "def min_steps(input):\n    data = input.split(\"\\n\")\n    t = int(data[0])\n    outputs = []\n    pos = 1\n\n    for _ in range(t):\n        n, k = map(int, data[pos].split())\n        array = list(map(int, data[pos+1].split()))\n        total = sum(array)\n        steps = 0\n        if total > k:\n            array.sort(reverse=True)\n            for i in range(n):\n                diff = total - k\n                if array[i] <= diff:\n                    steps += 1\n                    total -= array[i]\n                else:\n                    steps += diff\n                    break\n        outputs.append(str(steps))\n        pos += 2\n    return \"\\n\".join(outputs)\n"}
{"task_id": 157, "completion": "def solve_problem(input_string):\n    input_lines = input_string.strip().split(\"\\n\")\n    n, k = map(int, input_lines[0].split())\n    s = input_lines[1]\n\n    MOD = 998244353\n    \n    dp = [[0]*5005 for _ in range(5005)]\n    cnt = [0]*5005\n    p = [0]*5005\n    dp[0][0] = 1\n    zero = [0] * (n + 5)\n    for i in range(1, n+1):\n        p[i] = p[i-1]\n        if s[i-1] == '1':\n            p[i] += 1\n        for j in range(i+1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0 and s[i-1] == '1':\n                dp[i][j] = (dp[i][j] + dp[p[i-1]][j-1]) % MOD\n        if s[i - 1] == '0':\n            zero[i] = zero[i - 1] + 1\n        else:\n            zero[i] = zero[i - 1]\n\n    ans = 0\n    for i in range(k, n+1):\n        cnt[i] = ((dp[n][i] + dp[n][i-1]) % MOD + cnt[i - 1]) % MOD\n        ans = (ans + (pow(2, zero[i], MOD) - 1 - cnt[i] + MOD) % MOD) % MOD\n\n    return str(ans) + \"\\n\"\n"}
{"task_id": 158, "completion": "from heapq import *\n\ndef max_surprise(test_cases):\n\n    def get_points(n, m, xi, si):\n        counts = [0]*m\n        students = list(zip(xi, si))\n        students.sort(reverse=True)\n        for x, s in students:\n            for i in range(m):\n                if s[i] == '1':\n                    counts[i] += 1\n        p = [i+1 for i in range(m)]\n        h = []\n        for i in range(m):\n            heappush(h, (-counts[i], p[i]))\n        surprises = []\n        for x, s in students:\n            total_points = sum(p[i] for i in range(m) if s[i] == '1')\n            surprises.append(abs(total_points - x))\n        return surprises, h\n\n    t = parse_input(test_cases)\n\n    for testcase in t:\n        n, m = testcase[0]\n        xi = testcase[1]\n        si = testcase[2:]\n        surprises, h = get_points(n, m, xi, si)\n        while surprises:\n            surprise = heappop(surprises)\n            if surprise <= 0:\n                break\n            b, i = heappop(h)\n            if -b > surprise:\n                h.append((-b + surprise, i))\n                surprises.append(0)\n            else:\n                surprises.append(surprise + b)\n                h.append((0, i))\n            surprises.sort()\n        result.append([i[1] for i in sorted(h, key=lambda x: x[1])])\n\n    return result\n\ndef parse_input(input_string):\n    lines = input_string.strip().split(\"\\n\")\n    t = int(lines[0])\n    tests = []\n    i = 1\n    for _ in range(t):\n        nm = list(map(int, lines[i].split()))\n        i += 1\n        xi = list(map(int, lines[i].split()))\n        i += 1\n        si = [list(map(int, list(lines[j]))) for j in range(i, i+nm[0])]\n        i += nm[0]\n        tests.append([nm, xi] + si)\n    return tests"}
{"task_id": 159, "completion": "import math\n\ndef quadratic_subset(n_str: str) -> str:\n    n = int(n_str)\n    subset = []\n    product_factorials = 1\n    sqrt_product_factorials = 1 \n\n    for i in range(1, n + 1):\n        if i <= 4:  # accept 1,  2, 3, and 4 because their factorials are squares.\n            subset.append(i)\n            continue\n        product_factorials *= math.factorial(i - 1)\n        sqrt_product_factorials *= (i - 1)\n        try:\n            number = (math.factorial(i) // product_factorials) \n            if math.isqrt(number)**2 == number:  # check if missing multiple is a perfect square\n                subset.append(i)\n        except ZeroDivisionError:\n            pass\n            \n    subset.sort()\n    return f'{len(subset)}\\n' + ' '.join(map(str, subset))\n"}
{"task_id": 160, "completion": "def solve(test_cases):\n    test_cases = test_cases.strip().split('\\n')[1:]\n    results = []\n    for test in test_cases:\n        n, m, rb, cb, rd, cd = map(int, test.split(' '))\n        dr, dc = 1, 1\n        time = 0\n        while rb != rd and cb != cd:\n            if (cb == m and dc == 1) or (cb == 1 and dc == -1):\n                dc = -dc\n            if (rb == n and dr == 1) or (rb == 1 and dr == -1):\n                dr = -dr\n            rb += dr\n            cb += dc\n            time += 1\n        results.append(str(time))\n    return '\\n'.join(results) +\"\\n\"\n"}
{"task_id": 161, "completion": "def solve(t, testcases):\n    result = []\n    for testcase in testcases:\n        n, ranges = testcase\n        ranges.sort(reverse=True, key=lambda x: x[::-1])\n        chosen = [False]*(n+1)\n        bob_nums = [0]*(n+1)\n        availables = set(range(1, n+1))\n        for l, r in ranges:\n            if not chosen[r]:\n                chosen[r] = True\n                bob_nums[l] = r\n                availables.remove(r)\n            else:\n                bob_nums[l] = min(availables)\n                availables.remove(bob_nums[l])\n        for l, r in sorted(ranges):\n            result.append((l, r, bob_nums[l]))\n    return result\n\nt = 4\nn = [(1, [(1, 1)]), (3, [(1, 3), (2, 3), (2, 2)]), (6, [(1, 1), (3, 5), (4, 4), (3, 6), (4, 5), (1, 6)]), (5, [(1, 5), (1, 2), (4, 5), (2, 2), (4, 4)])]\ntestcases = [(n_i, lr_i) for n_i, lr_i in n]\n\nprint(solve(t, testcases))\n"}
{"task_id": 162, "completion": "def max_stones_in_heap(input_str):\n    from heapq import heapify, heappush, heappop\n    input_lines = input_str.strip().split(\"\\n\")\n    t = int(input_lines[0])\n    data_idx = 1\n    results = []\n    for _ in range(t):\n        n = int(input_lines[data_idx])\n        h = list(map(int, input_lines[data_idx+1].split()))\n        data_idx += 2\n        h = [-1 * i for i in h]\n        heapify(h)\n        while len(h) > 2:\n            h3 = heappop(h)\n            h2 = heappop(h)\n            h1 = heappop(h)\n            if h1 > 3 * (h3+1):\n                h1 -= 3 * (h3+1)\n                h2 += h3+1\n                h3 += 2*(h3+1)\n            else:\n                surplus = h1 % 3\n                moves = h1 // 3\n                h1 -= 3 * moves\n                h2 += moves\n                h3 += 2*moves\n                if surplus == 1:\n                    h2 += 1\n                    h1 -= 1\n                elif surplus == 2:\n                    h3 += 1\n                    h1 -= 2\n            heappush(h, h1)\n            heappush(h, h2)\n            heappush(h, h3)\n        results.append(str(-1 * h[0]))\n    return \"\\n\".join(results)"}
{"task_id": 163, "completion": "def calculate_robot_cleaning_time(test_cases_string):\n\n    MOD = 10**9 + 7\n\n    def power(x, y, p): \n        res = 1\n        x = x % p  \n       \n        while (y > 0): \n            if (y & 1): \n                res = (res * x) % p\n            y = y >> 1 \n            x = (x * x) % p \n        return res  \n\n    def inversemodulo(x, y, p):\n        return (x * power(y, p - 2, p)) % p\n\n    test_cases = list(map(int, test_cases_string.split(\"\\n\")[1:-1]))\n    output = []\n\n    for i in range(0, len(test_cases), 7):\n\n        n, m, r_b, c_b, r_d, c_d, p = test_cases[i:i+7]\n        reachable_sec = max(abs(r_b - r_d), abs(c_b - c_d))\n        reachable_sec_x = max(n - r_b + 1, r_b, m - c_b + 1, c_b)\n        total_sec = 2 * reachable_sec_x - 2\n        additional_sec = max(0, reachable_sec - reachable_sec_x)\n\n        row_bouncing = total_sec // (2 * (n - 1))\n        col_bouncing = total_sec // (2 * (m - 1))\n        times_reached = row_bouncing + col_bouncing - 1\n\n        geometric_dist_e = inversemodulo(1, p, MOD)\n        total_sec = total_sec * geometric_dist_e % MOD\n        times_reached = times_reached * geometric_dist_e % MOD\n\n        output.append((total_sec - times_reached * additional_sec) % MOD)\n\n    return list(map(str, output))"}
{"task_id": 164, "completion": "import heapq\n\ndef smallest_tree_string(input_string):\n    data = input_string.strip().split(\"\\n\")\n    n, k = map(int, data[0].split())\n    c = list(data[1].strip())\n    lr = [list(map(int, item.split())) for item in data[2:]]\n    \n    heap = []\n    ans = []\n\n    add = [0] * n\n    degree = [0] * n\n    edge = [[] for _ in range(n)]\n    left = [-1] * n\n    right = [-1] * n\n\n    for u in range(n):\n        if lr[u][0] != 0:\n            edge[u].append(lr[u][0] - 1)\n            degree[lr[u][0] - 1] += 1\n            left[u] = lr[u][0] - 1\n            \n        if lr[u][1] != 0:\n            edge[u].append(lr[u][1] - 1)\n            degree[lr[u][1] - 1] += 1\n            right[u] = lr[u][1] - 1\n\n    stack = [i for i in range(n) if degree[i] == 0]\n    order = []\n\n    while stack:\n        u = stack[-1]\n        stack.pop()\n\n        order.append(u)\n        \n        for v in edge[u]:\n            degree[v] -= 1\n            if degree[v] == 0:\n                stack.append(v)\n\n    add[order[0]] = k\n    ans.append(c[order[0]] * (k + 1))\n    k = 0\n\n    for o in order[1:]:\n        if k == 0:\n            heapq.heappush(heap, (c[o], [c[o]]))\n        else:\n            if c[o] < heap[0][0]:\n                ans.append(heap[0][1])\n                heapq.heappop(heap)\n                k -= 1\n                add[o] = k\n                ans.append(c[o] * (k + 1))\n            else:\n                seq = sum([[s]*add[i] for i, s in heap], [])\n                ans.append(seq)\n                heap = [(c[o], [c[o]])]\n\n        if add[o] > 0:\n            if heap and heap[0][0] == c[o]:\n                heap[0][1].append(c[o])\n            else:\n                heapq.heappush(heap, (c[o], [c[o]]))\n\n        if left[o] >= 0 and add[o] > 0:\n            add[left[o]] = add[o] - 1\n        \n        if right[o] >= 0 and add[o] > 0:\n            add[right[o]] = add[o] - 1\n\n    while heap:\n        item = heapq.heappop(heap)\n        ans.append(item[1])\n\n    return ''.join(sum(ans, []))\n\n\nprint(smallest_tree_string('4 3\\nabab\\n2 3\\n0 0\\n0 4\\n0 0\\n')) # \"baaaab\"\nprint(smallest_tree_string('8 2\\nkadracyn\\n2 5\\n3 4\\n0 0\\n0 0\\n6 8\\n0 7\\n0 0\\n0 0\\n')) # \"daarkkcyan\"\nprint(smallest_tree_string('8 3\\nkdaracyn\\n2 5\\n0 3\\n0 4\\n0 0\\n6 8\\n0 7\\n0 0\\n0 0\\n')) # \"darkcyan\"\n"}









